// layer 4 code

Domain global< [ 0, 0, 0 ] to [ 0.05, 0.05, 0.05 ] >

Layout DefCellLayout < Real , Cell > @all {
	duplicateLayers	= [ 0, 0, 0 ]
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceXLayout < Real , Face_x > @all {
	duplicateLayers	= [ 1, 0, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceYLayout < Real , Face_y > @all {
	duplicateLayers	= [ 0, 1, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceZLayout < Real , Face_z > @all {
	duplicateLayers	= [ 0, 0, 1 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout CellStencilLayout < Vector<Real, 7>, Cell > @all {
	duplicateLayers	= [ 0, 0, 0 ]
	ghostLayers		= [ 1, 1, 1 ] // no communication necessary since only required for subexpression re-usage
}

Layout FaceXStencilLayout < Vector<Real, 7>, Face_x > @all {
	duplicateLayers	= [ 1, 0, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication	// only communicate face dim's ghost layers -> fix in communicate call
}

Layout FaceYStencilLayout < Vector<Real, 7>, Face_y > @all {
	duplicateLayers	= [ 0, 1, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout FaceZStencilLayout < Vector<Real, 7>, Face_z > @all {
	duplicateLayers	= [ 0, 0, 1 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

// values associated with u, ie face_x

Field u < global, DefFaceXLayout, 0.0 >[2] @all
Field du < global, DefFaceXLayout, 0.0 > @finest

Field residual_u < global, DefFaceXLayout, 0.0 > @all
Field rhs_u < global, DefFaceXLayout, None > @all

Field AuStencilData< global, FaceXStencilLayout, None > @all
StencilField AuStencil< AuStencilData => SevenPointStencil > @all

// values associated with v, ie face_y

Field v < global, DefFaceYLayout, 0.0 >[2] @all
Field dv < global, DefFaceYLayout, 0.0 > @finest

Field residual_v < global, DefFaceYLayout, 0.0 > @all
Field rhs_v < global, DefFaceYLayout, None > @all

Field AvStencilData< global, FaceYStencilLayout, None > @all
StencilField AvStencil< AvStencilData => SevenPointStencil > @all

// values associated with w, ie face_z

Field w < global, DefFaceZLayout, 0.0 >[2] @all
Field dw < global, DefFaceZLayout, 0.0 > @finest

Field residual_w < global, DefFaceZLayout, 0.0 > @all
Field rhs_w < global, DefFaceZLayout, None > @all

Field AwStencilData< global, FaceZStencilLayout, None > @all
StencilField AwStencil< AwStencilData => SevenPointStencil > @all

// values associated with p and rho, ie cell center

Field rho < global, DefCellLayout, Neumann >[2] @finest
Field p < global, DefCellLayout, Neumann > @finest
Field pc < global, DefCellLayout, Neumann > @all

Field residual_pc < global, DefCellLayout, Neumann > @all
Field rhs_pc < global, DefCellLayout, None > @all

Field ApcStencilData< global, CellStencilLayout, None > @all
StencilField ApcStencil< ApcStencilData => SevenPointStencil > @all

// values associated with phi7, ie cell center

Field phi7 < global, DefCellLayout, applyBC_t@current ( ) >[2] @all
Field residual_t < global, DefCellLayout, Neumann > @all
Field rhs_t < global, DefCellLayout, None > @all

Field AtStencilData< global, CellStencilLayout, None > @all
StencilField AtStencil< AtStencilData => SevenPointStencil > @all

// auxilary fields

Field vis < global, DefCellLayout, Neumann > @finest
Field miu < global, DefCellLayout, Neumann > @finest

Field gamma < global, DefCellLayout, Neumann > @finest

// stencils and stencils templates

Stencil SevenPointStencil@all {
	[ 0,  0,  0] =>  6.0
	[-1,  0,  0] => -1.0
	[ 1,  0,  0] => -1.0
	[ 0, -1,  0] => -1.0
	[ 0,  1,  0] => -1.0
	[ 0,  0, -1] => -1.0
	[ 0,  0,  1] => -1.0
}

Stencil RestrictionCell@all from default restriction on Cell with 'linear'
Stencil CorrectionCell@all from default prolongation on Cell with 'linear'

Stencil RestrictionFaceX@all from default restriction on Face_x with 'linear'
Stencil CorrectionFaceX@all from default prolongation on Face_x with 'linear'

Stencil RestrictionFaceY@all from default restriction on Face_y with 'linear'
Stencil CorrectionFaceY@all from default prolongation on Face_y with 'linear'

Stencil RestrictionFaceZ@all from default restriction on Face_z with 'linear'
Stencil CorrectionFaceZ@all from default prolongation on Face_z with 'linear'

Globals {
	// global states
	Var curTime : Real          = 0.0

	Var totalInitRes : Real     = 0.0
	Var lastTotalInitRes : Real = 0.0

	Var converged_u : Boolean	= false
	Var converged_v : Boolean	= false
	Var converged_w : Boolean	= false
	Var converged_pc : Boolean	= false
	Var converged_t : Boolean	= false

	// printing
	Var nextPrintTime : Real	= maxTime + dt // don't print
	Val printInterval : Real	= 100// * dt

	// solver constants
	Val dt : Real 		        = 0.5
	Val maxTime : Real          = 10.0

	Var relax_1 : Real          = 0.5
	Var relax_2 : Real          = 0.5
	Var relax_3 : Real          = 0.5
	Var relax_4 : Real          = 0.5
	Var relax_7 : Real          = 0.5

	// exit criteria
	Var targetResPerComp : Real		= 1.0e-6
	Var stagnationThreshold : Real	= 1.0e-2
	Val maxSimpleIterations : Int	= 1000000

	// density constants
	Val rhoref : Real           = 0.0
	Val rhocon : Real           = 999.7 // overwritten by updateProperties
	Val visl : Real             = 1.0e-5 // overwritten by updateProperties

	// temperature constants
	Val th : Real               = 283.15
	Val tc : Real               = 273.15
	Val t_ph : Real             = 273.15
	Val temp_ref : Real         = 270.592
	Val delta_temp : Real       = 0.2

	// temperatures solidus & liquidus
	Val t_sol : Real            = t_ph + delta_temp
	Val t_liq : Real            = t_ph - delta_temp

	// phase change enthalpy
	Val hls : Real              = 3.35e5

	// phase properties
	Val miu_liq : Real          = 0.001197941294207
	Val cp_liq : Real           = 4202.1178518932
	Val rho_liq : Real          = 1000.12926014462
	Val cond_liq : Real         = 0.7207161
	Val rho_sol : Real          = 1000.10152281425
	Val cp_sol : Real           = 4202.85969356982
	Val cond_sol : Real         = 0.7204897

	// density contants Gangi et al. (Kohlrausch)
	Val a_den : Real            = 999.840281
	Val b_den : Real            = 0.0673268
	Val c_den : Real            = -0.00894484
	Val d_den : Real            = 8.7846287e-5
	Val e_den : Real            = -6.6213979e-7

	// non-Newtonian parameters
	Val useNonNewtonian : Bool	= false
	Val n_index : Real			= 0.6 // 0.95 // required for power law
	Val tau_y : Real			= 0.1 // 1.0e-4 // required for Bingham
}

/// specialized boundary handling functions
Function applyBC_t@finest ( ) : Unit {
	loop over phi7@current only ghost [-1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * th - phi7[active]@current@[ 1,  0,  0]
	}
	loop over phi7@current only ghost [ 1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * tc - phi7[active]@current@[-1,  0,  0]
	}
	loop over phi7@current only ghost [ 0, -1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  1,  0]
	}
	loop over phi7@current only ghost [ 0,  1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0, -1,  0]
	}
	loop over phi7@current only ghost [ 0,  0, -1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0,  1]
	}
	loop over phi7@current only ghost [ 0,  0,  1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0, -1]
	}
}
Function applyBC_t@(coarsest to (finest - 1)) ( ) : Unit {
	loop over phi7@current only ghost [-1,  0,  0] on boundary {
		phi7[active]@current = 0.0 - phi7[active]@current@[ 1,  0,  0]
	}
	loop over phi7@current only ghost [ 1,  0,  0] on boundary {
		phi7[active]@current = 0.0 - phi7[active]@current@[-1,  0,  0]
	}
	loop over phi7@current only ghost [ 0, -1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  1,  0]
	}
	loop over phi7@current only ghost [ 0,  1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0, -1,  0]
	}
	loop over phi7@current only ghost [ 0,  0, -1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0,  1]
	}
	loop over phi7@current only ghost [ 0,  0,  1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0, -1]
	}
}

/// main functions

Function Application ( ) : Unit {
	startTimer ( 'setup' )

	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )

	initGeometry ( )
	InitFields@finest ( )

	stopTimer ( 'setup' )

	TimeLoop ( )

	//printAllTimers ( )
	destroyGlobals ( )
}

Function TimeLoop ( ) : Unit {
	repeat until curTime >= maxTime {
		startTimer ( 'timeStep' )

		if ( 0.0 == curTime ) {
			// initialize 'negative' timestep
			if ( useNonNewtonian ) {
				UpdatePropertiesNN@finest ( )
			} else {
				UpdateProperties@finest ( )
			}
		}

		AdvanceFields@finest ( )

		Solve@finest ( )
		curTime += dt

		stopTimer ( 'timeStep' )
	}
}

Function Solve@finest ( ) : Unit {
	Var converged : Bool = false
	Var curIt : Int      = 0

	converged_u = false
	converged_v = false
	converged_w = false
	converged_pc = false
	converged_t = false

	repeat until converged || curIt >= maxSimpleIterations {
		startTimer ( 'solve' )

		lastTotalInitRes = totalInitRes
		totalInitRes = 0.0

		startTimer ( 'UpdateProperties' )
		if ( useNonNewtonian ) {
			UpdatePropertiesNN@current ( )
		} else {
			UpdateProperties@current ( )
		}
		stopTimer ( 'UpdateProperties' )

		/// velocity step
		startTimer ( 'UpdateVelocities' )

		// setup stencils and rhs's, and solve resulting systems
		startTimer ( 'CompileStencil_u' )
		CompileStencil_u@current ( )
		stopTimer ( 'CompileStencil_u' )

		startTimer ( 'Solve_u' )
		Solve_u@current ( )
		stopTimer ( 'Solve_u' )

		startTimer ( 'CompileStencil_v' )
		CompileStencil_v@current ( )
		stopTimer ( 'CompileStencil_v' )

		startTimer ( 'Solve_v' )
		Solve_v@current ( )
		stopTimer ( 'Solve_v' )

		startTimer ( 'CompileStencil_w' )
		CompileStencil_w@current ( )
		stopTimer ( 'CompileStencil_w' )

		startTimer ( 'Solve_w' )
		Solve_w@current ( )
		stopTimer ( 'Solve_w' )

		stopTimer ( 'UpdateVelocities' )

		/// pressure correction step
		startTimer ( 'PressureCorrection' )

		// reset field
		loop over pc@current starting [-1, -1, -1] ending [-1, -1, -1] {
			pc[active]@current = 0.0
		}

		// setup stencil and rhs, and solve resulting system
		startTimer ( 'CompileStencil_pc' )
		CompileStencil_pc@current ( )
		stopTimer ( 'CompileStencil_pc' )

		startTimer ( 'Solve_pc' )
		Solve_pc@current ( )
		stopTimer ( 'Solve_pc' )

		// perform actual pressure correction
		loop over p@current {
			p@current += relax_4 * pc@current
		}
		communicate p@current
		apply bc to p@current

		loop over u@current {
			u[active]@current += du@current * ( pc@current@[-1, 0, 0] - pc@current )
		}
		communicate u[active]@current
		apply bc to u[active]@current

		loop over v@current {
			v[active]@current += dv@current * ( pc@current@[0, -1, 0] - pc@current )
		}
		communicate v[active]@current
		apply bc to v[active]@current

		loop over w@current {
			w[active]@current += dw@current * ( pc@current@[0, 0, -1] - pc@current )
		}
		communicate w[active]@current
		apply bc to w[active]@current

		stopTimer ( 'PressureCorrection' )

		/// temperature step
		startTimer ( 'UpdateTemperature' )

		startTimer ( 'CompileStencil_t' )
		CompileStencil_t@current ( )
		stopTimer ( 'CompileStencil_t' )

		startTimer ( 'Solve_t' )
		Solve_t@current ( )
		stopTimer ( 'Solve_t' )

		stopTimer ( 'UpdateTemperature' )

		// check convergence
		startTimer ( 'convergenceCheck' )

		if ( converged_u && converged_v && converged_w && converged_pc && converged_t ) {
			converged = true
		}

		if ( !converged && 0 == curIt % 100 && curIt > 0 ) {
			Val res_u : Real = NormResidual_u@current ( )
			Val res_v : Real = NormResidual_v@current ( )
			Val res_w : Real = NormResidual_w@current ( )
			Val res_pc : Real = NormResidual_pc@current ( )
			Val res_t : Real = NormResidual_t@current ( )

			//print ( curTime, curIt , res_u, res_v, res_w, res_pc, res_t)
			print ( curTime, curIt )
			printVal ( res_u )
			printVal ( res_v )
			printVal ( res_w )
			printVal ( res_pc )
			printVal ( res_t )
		}

		stopTimer ( 'convergenceCheck' )

		stopTimer ( 'solve' )

		curIt += 1
	}

	/*if ( curTime >= nextPrintTime ) {
		nextPrintTime += printInterval

		Var index : Integer = curTime / printInterval

		Var filename_rho : String
		buildString ( filename_rho, "rho_", index, ".csv" )
		Var filename_u : String
		buildString ( filename_u, "u_", index, ".csv" )
		Var filename_v : String
		buildString ( filename_v, "v_", index, ".csv" )
		Var filename_w : String
		buildString ( filename_w, "w_", index, ".csv" )
		Var filename_temp : String
		buildString ( filename_temp, "temp_", index, ".csv" )

		printField ( filename_rho, rho[active]@current, 2**( levels@current ( ) - 1 ) == i2 )
		printField ( filename_u, u[active]@current, 2**( levels@current ( ) - 1 ) == i2 )
		printField ( filename_v, v[active]@current, 2**( levels@current ( ) - 1 ) == i2 )
		printField ( filename_w, w[active]@current, 2**( levels@current ( ) - 1 ) == i2 )
		printField ( filename_temp, phi7[active]@current, 2**( levels@current ( ) - 1 ) == i2 )
	}*/

	// print some information about achieved residuals and required steps
	Val res_u : Real = NormResidual_u@current ( )
	Val res_v : Real = NormResidual_v@current ( )
	Val res_w : Real = NormResidual_w@current ( )
	Val res_pc : Real = NormResidual_pc@current ( )
	Val res_t : Real = NormResidual_t@current ( )

	//print ( curTime, curIt , res_u, res_v, res_w, res_pc, res_t)
	print ( curTime, curIt )
	printVal ( res_u )
	printVal ( res_v )
	printVal ( res_w )
	printVal ( res_pc )
	printVal ( res_t )
}

Function printVal ( toPrint : Real ) : Unit {
    if ( toPrint <= 1e-12 ) {
		print ( "EFFECTIVELY ZERO" )
    } else if ( toPrint <= 1e-11 ) {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(1)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    } else if ( toPrint <= 1e-10 ) {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(2)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    } else if ( toPrint <= 1e-9 ) {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(3)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    } else {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(4)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    }
}

/// init functions

Function InitFields@finest ( ) : Unit {
	// fields that are not initialized with 0

	loop over rho@current {
		rho[active]@current = rhocon
		rho[previous]@current = rhocon
	}

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate rho[previous]@current
	apply bc to rho[previous]@current

	loop over vis@current {
		vis@current = visl
	}

	communicate vis@current
	apply bc to vis@current

	loop over phi7@current {
		phi7[active]@current = th
		phi7[previous]@current = th
	}

	communicate phi7[active]@current
	apply bc to phi7[active]@current

	communicate phi7[previous]@current
	apply bc to phi7[previous]@current
}

/// utility functions

Function AdvanceFields@finest ( ) : Unit {
	loop over phi7@current starting [-1, -1, -1] ending [-1, -1, -1] {
		phi7[next]@current = phi7[active]@current
	}
	advance phi7@current

	loop over u@current starting [-1, -1, -1] ending [-1, -1, -1] {
		u[next]@current = u[active]@current
	}
	advance u@current

	loop over v@current starting [-1, -1, -1] ending [-1, -1, -1] {
		v[next]@current = v[active]@current
	}
	advance v@current

	loop over w@current starting [-1, -1, -1] ending [-1, -1, -1] {
		w[next]@current = w[active]@current
	}
	advance w@current

	loop over rho@current starting [-1, -1, -1] ending [-1, -1, -1] {
		rho[next]@current = rho[active]@current
	}
	advance rho@current
}

Function calc_diflow ( flow : Real, diff : Real ) : Real {
	Var tmp : Real = ( diff - 0.1 * fabs ( flow ) ) / diff
	return max ( 0.0, diff * ( tmp ** 5 ) )
}

/// general functions

Function UpdateProperties@finest ( ) : Unit {
	// previously props and Gamsor_flu and Gamsor_phi

	loop over vis@current {
		// Gangi et al. (Kohlrausch) Density
		rho[active]@current = ( a_den + b_den * ( phi7[active]@current - t_ph )
			+ c_den * ( phi7[active]@current - t_ph )**2
			+ d_den * ( phi7[active]@current - t_ph )**3
			+ e_den * ( phi7[active]@current - t_ph )**4 )

		// Zografos et al. Specific heat, thermal conductivity and viscosity
		Var cp : Real = ( -3755.9 + 67.953 * phi7[active]@current
			- 0.19149 * phi7[active]@current**2
			+ 1.7850e-4 * phi7[active]@current**3 )
		Var cond : Real = ( -0.63262 + 7.1959e-3 * phi7[active]@current
			- 1.144e-5 * phi7[active]@current**2
			+ 4.2365e-9 * phi7[active]@current**3 )
		vis@current = 3.8208e-2 / ( phi7[active]@current - 252.33 )

		gamma@current = cond / cp
	}

	communicate vis@current
	apply bc to vis@current

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate gamma@current
	apply bc to gamma@current
}

Function UpdatePropertiesNN@finest ( ) : Unit {
	// previously props and non_new and Gamsor_flu and Gamsor_phi

	loop over miu@current {
		// Gangi et al. (Kohlrausch) Density
		rho[active]@current = ( a_den + b_den * ( phi7[active]@current - t_ph )
			+ c_den * ( phi7[active]@current - t_ph )**2
			+ d_den * ( phi7[active]@current - t_ph )**3
			+ e_den * ( phi7[active]@current - t_ph )**4 )

		// Zografos et al. Specific heat, thermal conductivity and viscosity
		Var cp : Real = ( -3755.9 + 67.953 * phi7[active]@current
			- 0.19149 * phi7[active]@current**2
			+ 1.7850e-4 * phi7[active]@current**3 )
		Var cond : Real = ( -0.63262 + 7.1959e-3 * phi7[active]@current
			- 1.144e-5 * phi7[active]@current**2
			+ 4.2365e-9 * phi7[active]@current**3 )
		miu@current = 3.8208e-2 / ( phi7[active]@current - 252.33 )

		gamma@current = cond / cp
	}

	communicate miu@current
	apply bc to miu@current

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate gamma@current
	apply bc to gamma@current

	loop over vis@current {
		// TODO: add evalAtCellCenter, evalAtXFaceCenter, evalAtXYCorner, etc
		// du/dx and dv/dx and dw/dx
		Val dudx : Real = ( u@[1, 0, 0] - u@[0, 0, 0] ) / vf_cellWidth_x
		Val dvdx : Real = 0.5 * ( v@[1, 0, 0] - v@[0, 0, 0] + v@[1, 1, 0] - v@[0, 1, 0] ) / vf_cellWidth_x
		Val dwdx : Real = 0.5 * ( w@[1, 0, 0] - w@[0, 0, 0] + w@[1, 0, 1] - w@[0, 0, 1] ) / vf_cellWidth_x

		// du/dy and dv/dy and dw/dy
		Val dudy : Real = 0.5 * ( u@[0, 1, 0] - u@[0, 0, 0] + u@[1, 1, 0] - u@[1, 0, 0] ) / vf_cellWidth_y
		Val dvdy : Real = ( v@[0, 1, 0] - v@[0, 0, 0] ) / vf_cellWidth_y
		Val dwdy : Real = 0.5 * ( w@[0, 1, 0] - w@[0, 0, 0] + w@[0, 1, 1] - w@[0, 0, 1] ) / vf_cellWidth_y

		// du/dz and dv/dz and dw/dz
		Val dudz : Real = 0.5 * ( u@[0, 0, 1] - u@[0, 0, 0] + u@[1, 0, 1] - u@[1, 0, 0] ) / vf_cellWidth_z
		Val dvdz : Real = 0.5 * ( v@[0, 0, 1] - v@[0, 0, 0] + v@[0, 1, 1] - v@[0, 1, 0] ) / vf_cellWidth_z
		Val dwdz : Real = ( w@[0, 0, 1] - w@[0, 0, 0] ) / vf_cellWidth_z

		// compile values
		Val gamap : Real = 2.0 * ( dvdy**2 + dudx**2 + dwdz**2 ) + ( dvdx + dudy )**2 + ( dwdx + dudz )**2 + ( dvdz + dwdy )**2
		Var gama : Real = sqrt ( gamap )

		// j.non.newt.fluid mech. 15(1984)75-83
		//gama = max ( gama, 0.01 )
		//vis@current = rel + ( 1.0 - rel ) / ( 1.0 + sqrt ( lambda * gama ) )

		// Int. J. Heat & Mass Transfer 34(1991) 1083-1096 CMC/Power law
		//gama = max ( gama, 0.01 )
		//vis@current = miu@current * gama**( n_index - 1.0 )

		// Bingham: Bi-viscosity model O'Donovan & Tanner
		Val miu_yield : Real = 1.0e3 * miu@current
		if ( gama <= tau_y / miu_yield ) {
			vis@current = miu_yield
		} else {
			vis@current = ( tau_y + miu@current * ( gama - tau_y / miu_yield ) ) / gama
		}
	}

	communicate vis@current
	apply bc to vis@current
}

/// stencil compilation functions

Function CompileStencil_u@finest (  ) : Unit {
	loop over AuStencil@current {
		Val flow_e : Real = integrateOverXStaggeredEastFace ( u[active]@current * rho[active]@current )
		Val flow_w : Real = integrateOverXStaggeredWestFace ( u[active]@current * rho[active]@current )

		Val flow_n : Real = integrateOverXStaggeredNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s : Real = integrateOverXStaggeredSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t : Real = integrateOverXStaggeredTopFace ( w[active]@current * rho[active]@current )
		Val flow_b : Real = integrateOverXStaggeredBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverXStaggeredEastFace ( vis@current ) / vf_cellWidth_x@current
		Val diff_w : Real = integrateOverXStaggeredWestFace ( vis@current ) / vf_cellWidth_x@current@[-1,  0,  0]

		Val diff_n : Real = integrateOverXStaggeredNorthFace ( evalAtXStaggeredNorthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[ 0,  1,  0]
		Val diff_s : Real = integrateOverXStaggeredSouthFace ( evalAtXStaggeredSouthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current

		Val diff_t : Real = integrateOverXStaggeredTopFace ( evalAtXStaggeredTopFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[ 0,  0,  1]
		Val diff_b : Real = integrateOverXStaggeredBottomFace ( evalAtXStaggeredBottomFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current

		AuStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e, diff_e ) + max ( 0.0, -1.0 * flow_e ) )
		AuStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w, diff_w ) + max ( 0.0,        flow_w ) )

		AuStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n, diff_n ) + max ( 0.0, -1.0 * flow_n ) )
		AuStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s, diff_s ) + max ( 0.0,        flow_s ) )

		AuStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t, diff_t ) + max ( 0.0, -1.0 * flow_t ) )
		AuStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b, diff_b ) + max ( 0.0,        flow_b ) )

		Var smasa : Real = (
			( flow_e - flow_w + flow_n - flow_s + flow_t - flow_b ) / vf_xStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AuStencil@current:[ 0,  0,  0] = smasa
		AuStencil@current:[ 0,  0,  0] += evalAtWestFace ( rho[active]@current ) / dt
		AuStencil@current:[ 0,  0,  0] = ( AuStencil@current:[ 0,  0,  0] * vf_xStagCellVolume@current
			- AuStencil@current:[ 1,  0,  0] - AuStencil@current:[-1,  0,  0]
			- AuStencil@current:[ 0,  1,  0] - AuStencil@current:[ 0, -1,  0]
			- AuStencil@current:[ 0,  0,  1] - AuStencil@current:[ 0,  0, -1] ) / relax_1

		rhs_u@current = ( u[active]@current * smasa
			+ u[previous]@current * evalAtWestFace ( rho[previous]@current ) / dt )
		rhs_u@current = rhs_u@current * vf_xStagCellVolume@current + ( 1.0 - relax_1 ) * AuStencil@current:[ 0,  0,  0] * u[active]@current
		rhs_u@current += ( vf_cellWidth_y@current * vf_cellWidth_z@current ) * ( p@current@[-1,  0,  0] - p@current )
	}

	communicate AuStencil@current

	// restrict stencil
	StencilRestriction_u@current ( )

	// update du
	loop over du@current {
		du@current = ( vf_cellWidth_y@current * vf_cellWidth_z@current ) / ( AuStencil@current:[ 0,  0,  0] )
	}

	communicate du@current
	apply bc to du@current
}

Function CompileStencil_v@finest (  ) : Unit {
	loop over AvStencil@current {
		Val flow_e : Real = integrateOverYStaggeredEastFace ( u[active]@current * rho[active]@current )
		Val flow_w : Real = integrateOverYStaggeredWestFace ( u[active]@current * rho[active]@current )

		Val flow_n : Real = integrateOverYStaggeredNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s : Real = integrateOverYStaggeredSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t : Real = integrateOverYStaggeredTopFace ( w[active]@current * rho[active]@current )
		Val flow_b : Real = integrateOverYStaggeredBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverYStaggeredEastFace ( evalAtYStaggeredEastFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[ 1,  0,  0]
		Val diff_w : Real = integrateOverYStaggeredWestFace ( evalAtYStaggeredWestFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current

		Val diff_n : Real = integrateOverYStaggeredNorthFace ( vis@current ) / vf_cellWidth_y@current
		Val diff_s : Real = integrateOverYStaggeredSouthFace ( vis@current ) / vf_cellWidth_y@current@[ 0, -1,  0]

		Val diff_t : Real = integrateOverYStaggeredTopFace ( evalAtYStaggeredTopFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[ 0,  0,  1]
		Val diff_b : Real = integrateOverYStaggeredBottomFace ( evalAtYStaggeredBottomFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current

		AvStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e, diff_e ) + max ( 0.0, -1.0 * flow_e ) )
		AvStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w, diff_w ) + max ( 0.0,        flow_w ) )

		AvStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n, diff_n ) + max ( 0.0, -1.0 * flow_n ) )
		AvStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s, diff_s ) + max ( 0.0,        flow_s ) )

		AvStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t, diff_t ) + max ( 0.0, -1.0 * flow_t ) )
		AvStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b, diff_b ) + max ( 0.0,        flow_b ) )

		Var smasa : Real = (
			( flow_e - flow_w + flow_n - flow_s + flow_t - flow_b ) / vf_yStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AvStencil@current:[ 0,  0,  0] = smasa
		AvStencil@current:[ 0,  0,  0] += evalAtSouthFace ( rho[active]@current ) / dt
		AvStencil@current:[ 0,  0,  0] = ( AvStencil@current:[ 0,  0,  0] * vf_yStagCellVolume@current
			- AvStencil@current:[ 1,  0,  0] - AvStencil@current:[-1,  0,  0]
			- AvStencil@current:[ 0,  1,  0] - AvStencil@current:[ 0, -1,  0]
			- AvStencil@current:[ 0,  0,  1] - AvStencil@current:[ 0,  0, -1] ) / relax_2

		rhs_v@current = -9.81 * ( rho[active]@current - rhoref ) // incorporate gravity
		rhs_v@current += v[active]@current * smasa
			+ v[previous]@current * evalAtSouthFace ( rho[previous]@current ) / dt
		rhs_v@current = rhs_v@current * vf_yStagCellVolume@current + ( 1.0 - relax_2 ) * AvStencil@current:[ 0,  0,  0] * v[active]@current
		rhs_v@current += ( vf_cellWidth_x@current * vf_cellWidth_z@current ) * ( p@current@[ 0, -1,  0] - p@current )
	}

	communicate AvStencil@current

	// restrict stencil
	StencilRestriction_v@current ( )

	// update dv
	loop over dv@current {
		dv@current = ( vf_cellWidth_x@current * vf_cellWidth_z@current ) / ( AvStencil@current:[ 0,  0,  0] )
	}

	communicate dv@current
	apply bc to dv@current
}

Function CompileStencil_w@finest (  ) : Unit {
	loop over AwStencil@current {
		Val flow_e : Real = integrateOverZStaggeredEastFace ( u[active]@current * rho[active]@current )
		Val flow_w : Real = integrateOverZStaggeredWestFace ( u[active]@current * rho[active]@current )

		Val flow_n : Real = integrateOverZStaggeredNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s : Real = integrateOverZStaggeredSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t : Real = integrateOverZStaggeredTopFace ( w[active]@current * rho[active]@current )
		Val flow_b : Real = integrateOverZStaggeredBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverZStaggeredEastFace ( evalAtZStaggeredEastFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[ 1,  0,  0]
		Val diff_w : Real = integrateOverZStaggeredWestFace ( evalAtZStaggeredWestFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current

		Val diff_n : Real = integrateOverZStaggeredNorthFace ( evalAtZStaggeredNorthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[ 0,  1,  0]
		Val diff_s : Real = integrateOverZStaggeredSouthFace ( evalAtZStaggeredSouthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current

		Val diff_t : Real = integrateOverZStaggeredTopFace ( vis@current ) / vf_cellWidth_z@current
		Val diff_b : Real = integrateOverZStaggeredBottomFace ( vis@current ) / vf_cellWidth_z@current@[ 0,  0, -1]

		AwStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e, diff_e ) + max ( 0.0, -1.0 * flow_e ) )
		AwStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w, diff_w ) + max ( 0.0,        flow_w ) )

		AwStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n, diff_n ) + max ( 0.0, -1.0 * flow_n ) )
		AwStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s, diff_s ) + max ( 0.0,        flow_s ) )

		AwStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t, diff_t ) + max ( 0.0, -1.0 * flow_t ) )
		AwStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b, diff_b ) + max ( 0.0,        flow_b ) )

		Var smasa : Real = (
			( flow_e - flow_w + flow_n - flow_s + flow_t - flow_b ) / vf_zStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AwStencil@current:[ 0,  0,  0] = smasa
		AwStencil@current:[ 0,  0,  0] += evalAtBottomFace ( rho[active]@current ) / dt
		AwStencil@current:[ 0,  0,  0] = ( AwStencil@current:[ 0,  0,  0] * vf_zStagCellVolume@current
			- AwStencil@current:[ 1,  0,  0] - AwStencil@current:[-1,  0,  0]
			- AwStencil@current:[ 0,  1,  0] - AwStencil@current:[ 0, -1,  0]
			- AwStencil@current:[ 0,  0,  1] - AwStencil@current:[ 0,  0, -1] ) / relax_3

		rhs_w@current = w[active]@current * smasa
			+ w[previous]@current * evalAtBottomFace ( rho[previous]@current ) / dt
		rhs_w@current = rhs_w@current * vf_zStagCellVolume@current + ( 1.0 - relax_3 ) * AwStencil@current:[ 0,  0,  0] * w[active]@current
		rhs_w@current += vf_cellWidth_x@current * vf_cellWidth_y@current * ( p@current@[ 0,  0, -1] - p@current )
	}

	communicate AwStencil@current

	// restrict stencil
	StencilRestriction_w@current ( )

	// update dw
	loop over dw@current {
		dw@current = vf_cellWidth_x@current * vf_cellWidth_y@current / AwStencil@current:[ 0,  0,  0]
	}

	communicate dw@current
	apply bc to dw@current
}

Function CompileStencil_pc@finest (  ) : Unit {
	loop over ApcStencil@current {
		ApcStencil@current:[ 1,  0,  0] = -1.0 * integrateOverEastFace ( du@current * rho[active]@current )
		ApcStencil@current:[-1,  0,  0] = -1.0 * integrateOverWestFace ( du@current * rho[active]@current )
		ApcStencil@current:[ 0,  1,  0] = -1.0 * integrateOverNorthFace ( dv@current * rho[active]@current )
		ApcStencil@current:[ 0, -1,  0] = -1.0 * integrateOverSouthFace ( dv@current * rho[active]@current )
		ApcStencil@current:[ 0,  0,  1] = -1.0 * integrateOverTopFace ( dw@current * rho[active]@current )
		ApcStencil@current:[ 0,  0, -1] = -1.0 * integrateOverBottomFace ( dw@current * rho[active]@current )

		ApcStencil@current:[ 0,  0,  0] = -1.0 * (
			ApcStencil@current:[ 1,  0,  0] + ApcStencil@current:[-1,  0,  0] +
			ApcStencil@current:[ 0,  1,  0] + ApcStencil@current:[ 0, -1,  0] +
			ApcStencil@current:[ 0,  0,  1] + ApcStencil@current:[ 0,  0, -1] )

		rhs_pc@current = (
			integrateOverWestFace ( u[active]@current * rho[active]@current )
			- integrateOverEastFace ( u[active]@current * rho[active]@current )
			+ integrateOverSouthFace ( v[active]@current * rho[active]@current )
			- integrateOverNorthFace ( v[active]@current * rho[active]@current )
			+ integrateOverBottomFace ( w[active]@current * rho[active]@current )
			- integrateOverTopFace ( w[active]@current * rho[active]@current )
			+ vf_cellWidth_y@current * vf_cellWidth_z@current * vf_cellWidth_x@current * ( rho[previous]@current - rho[active]@current ) / dt )
	}

	// restrict stencil
	StencilRestriction_pc@current ( )
}

Function CompileStencil_t@finest (  ) : Unit {
	loop over AtStencil@current {
		Val flow_e : Real = integrateOverEastFace ( u[active]@current * rho[active]@current )
		Val flow_w : Real = integrateOverWestFace ( u[active]@current * rho[active]@current )

		Val flow_n : Real = integrateOverNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s : Real = integrateOverSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t : Real = integrateOverTopFace ( w[active]@current * rho[active]@current )
		Val flow_b : Real = integrateOverBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverEastFace ( evalAtEastFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[ 1,  0,  0]
		Val diff_w : Real = integrateOverWestFace ( evalAtWestFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current

		Val diff_n : Real = integrateOverNorthFace ( evalAtNorthFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[ 0,  1,  0]
		Val diff_s : Real = integrateOverSouthFace ( evalAtSouthFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current

		Val diff_t : Real = integrateOverTopFace ( evalAtTopFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[ 0,  0,  1]
		Val diff_b : Real = integrateOverBottomFace ( evalAtBottomFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current

		AtStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e, diff_e ) + max ( 0.0, -1.0 * flow_e ) )
		AtStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w, diff_w ) + max ( 0.0,        flow_w ) )

		AtStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n, diff_n ) + max ( 0.0, -1.0 * flow_n ) )
		AtStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s, diff_s ) + max ( 0.0,        flow_s ) )

		AtStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t, diff_t ) + max ( 0.0, -1.0 * flow_t ) )
		AtStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b, diff_b ) + max ( 0.0,        flow_b ) )

		Var smasa : Real = (
			( flow_e - flow_w + flow_n - flow_s + flow_t - flow_b ) / vf_cellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AtStencil@current:[ 0,  0,  0] = smasa + rho[active]@current / dt
		AtStencil@current:[ 0,  0,  0] = ( AtStencil@current:[ 0,  0,  0] * vf_cellVolume@current
			- AtStencil@current:[ 1,  0,  0] - AtStencil@current:[-1,  0,  0]
			- AtStencil@current:[ 0,  1,  0] - AtStencil@current:[ 0, -1,  0]
			- AtStencil@current:[ 0,  0,  1] - AtStencil@current:[ 0,  0, -1] ) / relax_7

		rhs_t@current = smasa * phi7[active]@current
			+ ( rho[active]@current / dt ) * phi7[previous]@current
		rhs_t@current = rhs_t@current * vf_cellVolume@current + ( 1.0 - relax_7 ) * AtStencil@current:[ 0,  0,  0] * phi7[active]@current
	}

	// restrict stencil
	StencilRestriction_t@current ( )
}

/// templates for (multigrid) solver components

FunctionTemplate SolveComponent < vCycle, normFunction, maxSteps, rhs, converged > ( ) : Unit {
	Var initRes : Real    = normFunction@current()
	Var curRes  : Real    = initRes
	Var prevRes : Real    = curRes
	Var numIt   : Integer = 0

	totalInitRes += initRes

	Var normRHS : Real = 0
	loop over rhs with reduction ( + : normRHS ) {
		normRHS += rhs ** 2
	}
	normRHS = sqrt ( normRHS )

	if ( curRes <= targetResPerComp * ( 1.0 + normRHS ) ) {
		converged = true
	}
	repeat until numIt > 0 && ( curRes <= targetResPerComp * ( 1.0 + normRHS ) || numIt >= maxSteps || ( numIt > 0 && prevRes - curRes < stagnationThreshold * targetResPerComp ) ) {
		vCycle@current ( )

		prevRes = curRes
		curRes = normFunction@current()
		numIt += 1
	}

	//print ( numIt, normRHS, initRes, curRes)
}

FunctionTemplate NormResidualComponent < solution, stencil, rhs > ( ) : Real {
	Variable totalRes : Real = 0
	loop over solution with reduction( + : totalRes ) {
		Var curRes : Real = rhs - stencil * solution
		totalRes += curRes ** 2
	}
	return sqrt ( totalRes )
}

FunctionTemplate SmoothComponent < solution, stencil, rhs, omega, requiresBcUpdate > ( ) : Unit {
	loop over solution where 0 == ((i0 + i1 + i2) % 2) {
		solution += ( ( 1.0 / diag ( stencil ) ) * omega ) * ( rhs - stencil * solution )
	}
	communicate solution

	loop over solution where 1 == ((i0 + i1 + i2) % 2) {
		solution += ( ( 1.0 / diag ( stencil ) ) * omega ) * ( rhs - stencil * solution )
	}
	communicate solution

	if ( requiresBcUpdate ) {
		apply bc to solution
	}
}

FunctionTemplate VCycleComponent < VCycle, Smooth, UpdateResidual, Restriction, SetSolution, Correction > ( ) : Unit {
	repeat 3 times {
		Smooth@current ( )
	}
	UpdateResidual@current ( )
	Restriction@current ( )
	SetSolution@coarser ( 0 )
	VCycle@coarser ( )
	Correction@current ( )
	repeat 3 times {
		Smooth@current ( )
	}
}

FunctionTemplate CGSComponent < solution, stencil, rhs, omega, requiresBcUpdate > ( ) : Unit {
	repeat 4 times {
		loop over solution where 0 == ((i0 + i1 + i2) % 2) {
			solution += ( ( 1.0 / diag ( stencil ) ) * omega ) * ( rhs - stencil * solution )
		}
		communicate solution

		loop over solution where 1 == ((i0 + i1 + i2) % 2) {
			solution += ( ( 1.0 / diag ( stencil ) ) * omega ) * ( rhs - stencil * solution )
		}
		communicate solution

		if ( requiresBcUpdate ) {
			apply bc to solution
		}
	}
}

FunctionTemplate UpdateResidualComponent < solution, stencil, rhs, residual > ( ) : Unit {
	loop over residual {
		residual = rhs - stencil * solution
	}
	communicate residual
}

FunctionTemplate RestrictionComponent < source, dest, restrictionStencil > ( ) : Unit {
	loop over dest {
		dest = restrictionStencil * source
	}
}

FunctionTemplate StencilRestrictionComponent < self, source, dest, restrictionStencil > ( ) : Unit {
	loop over dest {
		dest:[ 0,  0,  0] = restrictionStencil * source:[ 0,  0,  0]
		dest:[-1,  0,  0] = restrictionStencil * source:[-1,  0,  0]
		dest:[ 1,  0,  0] = restrictionStencil * source:[ 1,  0,  0]
		dest:[ 0, -1,  0] = restrictionStencil * source:[ 0, -1,  0]
		dest:[ 0,  1,  0] = restrictionStencil * source:[ 0,  1,  0]
		dest:[ 0,  0, -1] = restrictionStencil * source:[ 0,  0, -1]
		dest:[ 0,  0,  1] = restrictionStencil * source:[ 0,  0,  1]
	}

	communicate dest
	apply bc to dest

	@(all but (coarsest + 1)) {
		self@coarser ( )
	}
}

FunctionTemplate CorrectionComponent < source, dest, correctionStencil, requiresBcUpdate > ( ) : Unit {
	loop over dest {
		dest += correctionStencil * source
	}

	communicate dest
	if ( requiresBcUpdate ) {
		apply bc to dest
	}
}

FunctionTemplate SetFieldComponent < target > ( value : Real ) : Unit {
	loop over target starting [-1, -1, -1] ending [-1, -1, -1] {
		target = value
	}
}

// instantiations

Instantiate SolveComponent < VCycle_u, NormResidual_u, 100, rhs_u@current, converged_u > as Solve_u@finest
Instantiate NormResidualComponent < u[active]@current, AuStencil@current, rhs_u@current > as NormResidual_u@finest
Instantiate SmoothComponent < u[active]@current, AuStencil@current, rhs_u@current, 1.0, true > as Smooth_u@all
Instantiate VCycleComponent < VCycle_u, Smooth_u, UpdateResidual_u, Restriction_u, SetSolution_u, Correction_u > as VCycle_u@( ( coarsest + 1 ) to finest )
Instantiate CGSComponent < u[active]@current, AuStencil@current, rhs_u@current, 1.0, true > as VCycle_u@coarsest
Instantiate UpdateResidualComponent < u[active]@current, AuStencil@current, rhs_u@current, residual_u@current > as UpdateResidual_u@all
Instantiate RestrictionComponent < residual_u@current, rhs_u@coarser, RestrictionFaceX@current > as Restriction_u@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_u, AuStencil@current, AuStencil@coarser, RestrictionFaceX@current > as StencilRestriction_u@( ( coarsest + 1 ) to finest )
Instantiate CorrectionComponent < u[active]@coarser, u[active]@current, CorrectionFaceX@current, true > as Correction_u@( ( coarsest + 1 ) to finest )
Instantiate SetFieldComponent < u[active]@current > as SetSolution_u@all

Instantiate SolveComponent < VCycle_v, NormResidual_v, 100, rhs_v@current, converged_v > as Solve_v@finest
Instantiate NormResidualComponent < v[active]@current, AvStencil@current, rhs_v@current > as NormResidual_v@finest
Instantiate SmoothComponent < v[active]@current, AvStencil@current, rhs_v@current, 1.0, true > as Smooth_v@all
Instantiate VCycleComponent < VCycle_v, Smooth_v, UpdateResidual_v, Restriction_v, SetSolution_v, Correction_v > as VCycle_v@( ( coarsest + 1 ) to finest )
Instantiate CGSComponent < v[active]@current, AvStencil@current, rhs_v@current, 1.0, true > as VCycle_v@coarsest
Instantiate UpdateResidualComponent < v[active]@current, AvStencil@current, rhs_v@current, residual_v@current > as UpdateResidual_v@all
Instantiate RestrictionComponent < residual_v@current, rhs_v@coarser, RestrictionFaceY@current > as Restriction_v@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_v, AvStencil@current, AvStencil@coarser, RestrictionFaceY@current > as StencilRestriction_v@( ( coarsest + 1 ) to finest )
Instantiate CorrectionComponent < v[active]@coarser, v[active]@current, CorrectionFaceY@current, true > as Correction_v@( ( coarsest + 1 ) to finest )
Instantiate SetFieldComponent < v[active]@current > as SetSolution_v@all

Instantiate SolveComponent < VCycle_w, NormResidual_w, 100, rhs_w@current, converged_w > as Solve_w@finest
Instantiate NormResidualComponent < w[active]@current, AwStencil@current, rhs_w@current > as NormResidual_w@finest
Instantiate SmoothComponent < w[active]@current, AwStencil@current, rhs_w@current, 1.0, true > as Smooth_w@all
Instantiate VCycleComponent < VCycle_w, Smooth_w, UpdateResidual_w, Restriction_w, SetSolution_w, Correction_w > as VCycle_w@( ( coarsest + 1 ) to finest )
Instantiate CGSComponent < w[active]@current, AwStencil@current, rhs_w@current, 1.0, true > as VCycle_w@coarsest
Instantiate UpdateResidualComponent < w[active]@current, AwStencil@current, rhs_w@current, residual_w@current > as UpdateResidual_w@all
Instantiate RestrictionComponent < residual_w@current, rhs_w@coarser, RestrictionFaceZ@current > as Restriction_w@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_w, AwStencil@current, AwStencil@coarser, RestrictionFaceZ@current > as StencilRestriction_w@( ( coarsest + 1 ) to finest )
Instantiate CorrectionComponent < w[active]@coarser, w[active]@current, CorrectionFaceZ@current, true > as Correction_w@( ( coarsest + 1 ) to finest )
Instantiate SetFieldComponent < w[active]@current > as SetSolution_w@all

Instantiate SolveComponent < VCycle_pc, NormResidual_pc, 100, rhs_pc@current, converged_pc > as Solve_pc@finest
Instantiate NormResidualComponent < pc[active]@current, ApcStencil@current, rhs_pc@current > as NormResidual_pc@finest
Instantiate SmoothComponent < pc[active]@current, ApcStencil@current, rhs_pc@current, 0.8, true > as Smooth_pc@all
Instantiate VCycleComponent < VCycle_pc, Smooth_pc, UpdateResidual_pc, Restriction_pc, SetSolution_pc, Correction_pc > as VCycle_pc@( ( coarsest + 1 ) to finest )
Instantiate CGSComponent < pc[active]@current, ApcStencil@current, rhs_pc@current, 0.8, true > as VCycle_pc@coarsest
Instantiate UpdateResidualComponent < pc[active]@current, ApcStencil@current, rhs_pc@current, residual_pc@current > as UpdateResidual_pc@all
Instantiate RestrictionComponent < residual_pc@current, rhs_pc@coarser, RestrictionCell@current > as Restriction_pc@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_pc, ApcStencil@current, ApcStencil@coarser, RestrictionCell@current > as StencilRestriction_pc@( ( coarsest + 1 ) to finest )
Instantiate CorrectionComponent < pc[active]@coarser, pc[active]@current, CorrectionCell@current, true > as Correction_pc@( ( coarsest + 1 ) to finest )
Instantiate SetFieldComponent < pc[active]@current > as SetSolution_pc@all

Instantiate SolveComponent < VCycle_t, NormResidual_t, 100, rhs_t@current, converged_t > as Solve_t@finest
Instantiate NormResidualComponent < phi7[active]@current, AtStencil@current, rhs_t@current > as NormResidual_t@finest
Instantiate SmoothComponent < phi7[active]@current, AtStencil@current, rhs_t@current, 1.0, true > as Smooth_t@all
Instantiate VCycleComponent < VCycle_t, Smooth_t, UpdateResidual_t, Restriction_t, SetSolution_t, Correction_t > as VCycle_t@( ( coarsest + 1 ) to finest )
Instantiate CGSComponent < phi7[active]@current, AtStencil@current, rhs_t@current, 1.0, true > as VCycle_t@coarsest
Instantiate UpdateResidualComponent < phi7[active]@current, AtStencil@current, rhs_t@current, residual_t@current > as UpdateResidual_t@all
Instantiate RestrictionComponent < residual_t@current, rhs_t@coarser, RestrictionCell@current > as Restriction_t@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_t, AtStencil@current, AtStencil@coarser, RestrictionCell@current > as StencilRestriction_t@( ( coarsest + 1 ) to finest )
Instantiate CorrectionComponent < phi7[active]@coarser, phi7[active]@current, CorrectionCell@current, true > as Correction_t@( ( coarsest + 1 ) to finest )
Instantiate SetFieldComponent < phi7[active]@current > as SetSolution_t@all
