Domain global< [ 0, 0, 0 ] to [ 1, 1, 1 ] >

Layout NoComm< Real, Node >@all {
	ghostLayers = [ 0, 0, 0 ]
	duplicateLayers = [ 1, 1, 1 ]
}
Layout CommPartTempBlockable< Real, Node >@all {
	ghostLayers = [ 0, 0, 0 ]
	duplicateLayers = [ 1, 1, 1 ]
}
Layout BasicComm< Real, Node >@all {
	ghostLayers = [ 1, 1, 1 ] with communication
	duplicateLayers = [ 1, 1, 1 ] with communication
}
Layout CommFullTempBlockable< Real, Node >@all {
	ghostLayers = [ 1, 1, 1 ] with communication
	duplicateLayers = [ 1, 1, 1 ] with communication
}

Field Solution< global, BasicComm, 0.0 >@(coarsest to 0)
Field Solution< global, CommFullTempBlockable, 0.0 >@(1 to (finest - 1))
Field Solution< global, CommFullTempBlockable, ( vf_boundaryCoord_x@current * vf_boundaryCoord_x@current - 0.5 * vf_boundaryCoord_y@current * vf_boundaryCoord_y@current - 0.5 * vf_boundaryCoord_z@current * vf_boundaryCoord_z@current ) >@finest
Field Residual< global, BasicComm, 0.0 >@all
Field RHS< global, NoComm, None >@(coarsest to 0)
Field RHS< global, CommPartTempBlockable, None >@(1 to finest)
Field VecP< global, BasicComm, 0.0 >@coarsest
Field VecGradP< global, NoComm, None >@coarsest

Stencil Laplace@all {
	[ 0,  0,  0] => ( 6.0 )
	[ 1,  0,  0] => ( -1.0 )
	[-1,  0,  0] => ( -1.0 )
	[ 0,  1,  0] => ( -1.0 )
	[ 0, -1,  0] => ( -1.0 )
	[ 0,  0,  1] => ( -1.0 )
	[ 0,  0, -1] => ( -1.0 )
}
Stencil CorrectionStencil@all {
	[    0,     0,     0] => 0.0625
	[x % 2,     0,     0] => 0.0625
	[    0, y % 2,     0] => 0.0625
	[x % 2, y % 2,     0] => 0.0625
	[    0,     0, z % 2] => 0.0625
	[x % 2,     0, z % 2] => 0.0625
	[    0, y % 2, z % 2] => 0.0625
	[x % 2, y % 2, z % 2] => 0.0625
}
Stencil RestrictionStencil@all {
	[ 0,  0,  0] => 1.0
	[ 0,  0, -1] => 0.5
	[ 0,  0,  1] => 0.5
	[ 0, -1,  0] => 0.5
	[ 0,  1,  0] => 0.5
	[-1,  0,  0] => 0.5
	[ 1,  0,  0] => 0.5
	[ 0, -1,  1] => 0.25
	[ 0, -1, -1] => 0.25
	[ 0,  1,  1] => 0.25
	[ 0,  1, -1] => 0.25
	[-1,  0,  1] => 0.25
	[-1,  0, -1] => 0.25
	[ 1,  0,  1] => 0.25
	[ 1,  0, -1] => 0.25
	[-1, -1,  0] => 0.25
	[-1,  1,  0] => 0.25
	[ 1, -1,  0] => 0.25
	[ 1,  1,  0] => 0.25
	[-1, -1,  1] => 0.125
	[-1, -1, -1] => 0.125
	[-1,  1,  1] => 0.125
	[-1,  1, -1] => 0.125
	[ 1, -1,  1] => 0.125
	[ 1, -1, -1] => 0.125
	[ 1,  1,  1] => 0.125
	[ 1,  1, -1] => 0.125
}

Globals {
}

Function VCycle@coarsest ( ) : Unit {
	VCycle_0@current ( )
}
Function VCycle_0@coarsest ( ) : Unit {
	UpResidual@current ( )
	communicate Residual@current
	Variable res : Real = NormResidual_0@current ( )
	Variable initialRes : Real = res
	loop over VecP@current {
		VecP@current = Residual@current
	}
	Variable cgSteps : Integer
	repeat 512 times count cgSteps {
	communicate VecP@current
		loop over VecP@current {
			VecGradP@current = Laplace@current * VecP@current
		}
		Variable alphaDenom : Real = 0
		loop over VecP@current where x > 0 && y > 0 && z > 0 with reduction( + : alphaDenom ) {
			alphaDenom += VecP@current * VecGradP@current
		}
		Variable alpha : Real = res * res / alphaDenom
		loop over Solution@current {
			Solution[currentSlot]@current += alpha * VecP@current
			Residual@current -= alpha * VecGradP@current
		}
		Variable nextRes : Real = NormResidual_0@current ( )
		if ( nextRes <= 0.001 * initialRes ) {
			return
		}
		Variable beta : Real = (nextRes * nextRes) / (res * res)
		loop over VecP@current {
			VecP@current = Residual@current + beta * VecP@current
		}
		res = nextRes
	}
	print ( 'Maximum number of cgs iterations (', 512, ') was exceeded' )
}

Function VCycle@((coarsest + 1) to finest) ( ) : Unit {
	repeat 3 times {
		Smoother@current ( )
	}
	UpResidual@current ( )
	Restriction@current ( )
	SetSolution@coarser ( 0 )
		VCycle@coarser ( )
	Correction@current ( )
	repeat 3 times {
		Smoother@current ( )
	}
}

Function Smoother@((coarsest + 1) to finest) ( ) : Unit {
	communicate Solution@current where 1 == ((64 + x + y + z) % 2)
	loop over fragments {
	loop over Solution@current where 0 == ((x + y + z) % 2) {
		Solution[0]@current = Solution[0]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 1.0 ) * ( RHS@current - Laplace@current * Solution[0]@current ) )
	}
	}
	communicate Solution@current where 0 == ((64 + x + y + z) % 2)
	loop over fragments {
	loop over Solution@current where 1 == ((x + y + z) % 2) {
		Solution[0]@current = Solution[0]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 1.0 ) * ( RHS@current - Laplace@current * Solution[0]@current ) )
	}
	}
}

Function UpResidual@all (  ) : Unit {
	communicate Solution[active]@current
	loop over fragments {
	loop over Residual@current {
		Residual@current = RHS@current - (Laplace@current * Solution[active]@current)
	}
	}
}
Function NormResidual_0@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over fragments with reduction( + : res ) {
	loop over Residual@current where x > 0 && y > 0 && z > 0 with reduction( + : res ) {
		res += Residual@current * Residual@current
	}
	}
	return sqrt ( res )
}

Function Restriction@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Residual@current
	loop over fragments {
	loop over RHS@coarser {
		RHS@coarser = RestrictionStencil@current * Residual@current
	}
	}
}
Function Correction@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Solution[active]@coarser
	loop over fragments {
	loop over Solution@current {
		Solution[active]@current += CorrectionStencil@current * Solution[active]@coarser
	}
	}
}

Function SetSolution@all (value : Real) : Unit {
	loop over Solution@current {
		Solution[active]@current = value
	}
}
Function InitSolution ( ) : Unit {
	loop over Solution@finest {
		Solution[active]@finest = 0
	}
}
Function InitRHS@finest ( ) : Unit {
	loop over RHS@current {
		RHS@current = 0.0
	}
}

Function Solve ( ) : Unit {
	UpResidual@finest ( )
	Variable resStart_0 : Real = NormResidual_0@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
		if ( resStart_0 <= 1.0E-12 ) {
			print ( 'EFFECTIVELY ZERO' )
		} else if ( resStart_0 <= 1.0E-11 ) {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(1)' )
			print ( resStart_0 )
			native ( 'std::cout.precision(oldPrec)' )
		} else if ( resStart_0 <= 1.0E-10 ) {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(2)' )
			print ( resStart_0 )
			native ( 'std::cout.precision(oldPrec)' )
		} else if ( resStart_0 <= 1.0E-9 ) {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(3)' )
			print ( resStart_0 )
			native ( 'std::cout.precision(oldPrec)' )
		} else {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(4)' )
			print ( resStart_0 )
			native ( 'std::cout.precision(oldPrec)' )
		}
	Variable numIt : Integer = 0
	repeat until (res_0 < ( 1.0E-5 * resStart_0 ) || numIt >= 100) {
		numIt += 1
		startTimer ( 'cycle' )
		VCycle@finest (  )
		stopTimer ( 'cycle' )
		if (getTotalFromTimer ( 'cycle' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		UpResidual@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		if ( res_0 <= 1.0E-12 ) {
			print ( 'EFFECTIVELY ZERO' )
		} else if ( res_0 <= 1.0E-11 ) {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(1)' )
			print ( res_0 )
			native ( 'std::cout.precision(oldPrec)' )
		} else if ( res_0 <= 1.0E-10 ) {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(2)' )
			print ( res_0 )
			native ( 'std::cout.precision(oldPrec)' )
		} else if ( res_0 <= 1.0E-9 ) {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(3)' )
			print ( res_0 )
			native ( 'std::cout.precision(oldPrec)' )
		} else {
			native ( 'std::streamsize oldPrec = std::cout.precision()' )
			native ( 'std::cout.precision(4)' )
			print ( res_0 )
			native ( 'std::cout.precision(oldPrec)' )
		}
	}
	print ( numIt )
}

Function Application ( ) : Unit {
	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )
	InitRHS@finest ( )
	InitSolution ( )
	apply bc to Solution@0
	apply bc to Solution@1
	apply bc to Solution@2
	apply bc to Solution@3
	apply bc to Solution@4
	apply bc to Solution@5
	apply bc to Solution@6
	apply bc to VecP@coarsest
	Solve ( )
	destroyGlobals ( )
}

