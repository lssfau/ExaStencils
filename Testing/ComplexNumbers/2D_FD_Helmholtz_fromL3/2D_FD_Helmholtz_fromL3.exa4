// domain declarations

Domain global< [0.0, 0.0] to [1.0, 1.0] >

// field layout declarations

Layout defLayoutFor_ComplexReal_on_Node< Complex<Real>, Node >@(3) {
	duplicateLayers = [1, 1]
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node< Complex<Real>, Node >@(4) {
	duplicateLayers = [1, 1]
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node< Complex<Real>, Node >@(5) {
	duplicateLayers = [1, 1]
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node< Complex<Real>, Node >@(6) {
	duplicateLayers = [1, 1]
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node< Complex<Real>, Node >@(7) {
	duplicateLayers = [1, 1]
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node__1_1__1_1< Complex<Real>, Node >@(7) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [1, 1] with communication
}

Layout defLayoutFor_ComplexReal_on_Node__1_1__1_1< Complex<Real>, Node >@(3) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [1, 1] with communication
}

Layout defLayoutFor_ComplexReal_on_Node__1_1__1_1< Complex<Real>, Node >@(4) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [1, 1] with communication
}

Layout defLayoutFor_ComplexReal_on_Node__1_1__1_1< Complex<Real>, Node >@(5) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [1, 1] with communication
}

Layout defLayoutFor_ComplexReal_on_Node__1_1__1_1< Complex<Real>, Node >@(6) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [1, 1] with communication
}

Layout defLayoutFor_ComplexReal_on_Node__0_0__0_0< Complex<Real>, Node >@(4) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node__0_0__0_0< Complex<Real>, Node >@(5) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node__0_0__0_0< Complex<Real>, Node >@(6) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node__0_0__0_0< Complex<Real>, Node >@(7) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [0, 0]
}

Layout defLayoutFor_ComplexReal_on_Node__0_0__0_0< Complex<Real>, Node >@(3) {
	duplicateLayers = [1, 1] with communication
	ghostLayers = [0, 0]
}

// field declarations

Field Solution< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_Solution@7 (  ) >@7

Field u< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_u (  ) >@3

Field u< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_u (  ) >@4

Field u< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_u (  ) >@5

Field u< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_u (  ) >@6

Field u< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_u (  ) >@7

Field gen_error_u< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_gen_error_u (  ) >@3

Field gen_error_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_error_u (  ) >@4

Field gen_error_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_error_u (  ) >@5

Field gen_error_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_error_u (  ) >@6

Field gen_error_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_error_u (  ) >@7

Field f< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@3

Field f< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@4

Field f< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@5

Field f< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@6

Field f< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field gen_rhs_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@3

Field gen_rhs_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@4

Field gen_rhs_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@5

Field gen_rhs_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@6

Field gen_rhs_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field Residual< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field res< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_res (  ) >@3

Field res< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_res (  ) >@4

Field res< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_res (  ) >@5

Field res< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_res (  ) >@6

Field res< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_res (  ) >@7

Field gen_residual_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_residual_u (  ) >@3

Field gen_residual_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_residual_u (  ) >@4

Field gen_residual_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_residual_u (  ) >@5

Field gen_residual_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_residual_u (  ) >@6

Field gen_residual_u< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, applyBC_gen_residual_u (  ) >@7

Field p< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field ap< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field s< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field t< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field h< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field resHat< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

Field nu< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@3

Field p< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_p@3 (  ) >@3

Field h< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@3

Field s< global, defLayoutFor_ComplexReal_on_Node__1_1__1_1, applyBC_s@3 (  ) >@3

Field t< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@3

Field resHat< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@3

Field RHS< global, defLayoutFor_ComplexReal_on_Node__0_0__0_0, None >@7

// field combinations

// external field declarations

// stencil declarations

Stencil Restriction_u@3{
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.125
	[i0, i1] from [( 2.0 * i0 ), ( 2.0 * i1 )] with 0.25
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
}

Stencil Restriction_u@4{
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.125
	[i0, i1] from [( 2.0 * i0 ), ( 2.0 * i1 )] with 0.25
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
}

Stencil Restriction_u@5{
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.125
	[i0, i1] from [( 2.0 * i0 ), ( 2.0 * i1 )] with 0.25
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
}

Stencil Restriction_u@6{
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.125
	[i0, i1] from [( 2.0 * i0 ), ( 2.0 * i1 )] with 0.25
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
}

Stencil Restriction_u@7{
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) - 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.125
	[i0, i1] from [( 2.0 * i0 ), ( 2.0 * i1 )] with 0.25
	[i0, i1] from [( 2.0 * i0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) - 1.0 )] with 0.0625
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( 2.0 * i1 )] with 0.125
	[i0, i1] from [( ( 2.0 * i0 ) + 1.0 ), ( ( 2.0 * i1 ) + 1.0 )] with 0.0625
}

Stencil Prolongation_u@3{
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 + 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * i1 )] with 1
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 - 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
}

Stencil Prolongation_u@4{
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 + 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * i1 )] with 1
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 - 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
}

Stencil Prolongation_u@5{
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 + 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * i1 )] with 1
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 - 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
}

Stencil Prolongation_u@6{
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 + 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * i1 )] with 1
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 - 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
}

Stencil Prolongation_u@7{
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 + 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 + 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * i1 )] with 1
	[i0, i1] from [( 0.5 * i0 ), ( 0.5 * ( i1 - 1.0 ) )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 + 1.0 ) )] with 0.25
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * i1 )] with 0.5
	[i0, i1] from [( 0.5 * ( i0 - 1.0 ) ), ( 0.5 * ( i1 - 1.0 ) )] with 0.25
}

Stencil A@3{
	[i0, i1] from [i0, i1] with -6144.0
	[i0, i1] from [( i0 - 1.0 ), i1] with -64.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -64.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -64.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -64.0
}

Stencil A@4{
	[i0, i1] from [i0, i1] with -5376.0
	[i0, i1] from [( i0 - 1.0 ), i1] with -256.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -256.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -256.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -256.0
}

Stencil A@5{
	[i0, i1] from [i0, i1] with -2304.0
	[i0, i1] from [( i0 - 1.0 ), i1] with -1024.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -1024.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -1024.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -1024.0
}

Stencil A@6{
	[i0, i1] from [i0, i1] with 9984.0
	[i0, i1] from [( i0 - 1.0 ), i1] with -4096.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -4096.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -4096.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -4096.0
}

Stencil A@7{
	[i0, i1] from [i0, i1] with 59136.0
	[i0, i1] from [( i0 - 1.0 ), i1] with -16384.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -16384.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -16384.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -16384.0
}

Stencil M@3{
	[i0, i1] from [i0, i1] with ( 256.0 - ( 6400.0 * shift ) )
	[i0, i1] from [( i0 - 1.0 ), i1] with -64.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -64.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -64.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -64.0
}

Stencil M@4{
	[i0, i1] from [i0, i1] with ( 1024.0 - ( 6400.0 * shift ) )
	[i0, i1] from [( i0 - 1.0 ), i1] with -256.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -256.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -256.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -256.0
}

Stencil M@5{
	[i0, i1] from [i0, i1] with ( 4096.0 - ( 6400.0 * shift ) )
	[i0, i1] from [( i0 - 1.0 ), i1] with -1024.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -1024.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -1024.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -1024.0
}

Stencil M@6{
	[i0, i1] from [i0, i1] with ( 16384.0 - ( 6400.0 * shift ) )
	[i0, i1] from [( i0 - 1.0 ), i1] with -4096.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -4096.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -4096.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -4096.0
}

Stencil M@7{
	[i0, i1] from [i0, i1] with ( 65536.0 - ( 6400.0 * shift ) )
	[i0, i1] from [( i0 - 1.0 ), i1] with -16384.0
	[i0, i1] from [( i0 + 1.0 ), i1] with -16384.0
	[i0, i1] from [i0, ( i1 - 1.0 )] with -16384.0
	[i0, i1] from [i0, ( i1 + 1.0 )] with -16384.0
}

// stencil field declarations

// equations declarations

Equation PrecEq@3 {
	( M@3 * u@3 ) == f@3
}

Equation PrecEq@4 {
	( M@4 * u@4 ) == f@4
}

Equation PrecEq@5 {
	( M@5 * u@5 ) == f@5
}

Equation PrecEq@6 {
	( M@6 * u@6 ) == f@6
}

Equation PrecEq@7 {
	( M@7 * u@7 ) == f@7
}

Function Application {
	startTimer ( "setup" )
	initGlobals (  )
	initDomain (  )
	initFieldsWithZero (  )
	initGeometry (  )
	InitFields (  )
	apply bc to Solution@finest
	stopTimer ( "setup" )
	startTimer ( "solve" )
	Solve@finest (  )
	stopTimer ( "solve" )
	destroyGlobals (  )
}

Function applyBC_Solution@finest {
	loop over Solution only dup [-1, 0] on boundary {
		Solution@[0, 0] = ( Solution@[1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over Solution only dup [1, 0] on boundary {
		Solution@[0, 0] = ( Solution@[-1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over Solution only dup [0, 1] on boundary {
		Solution@[0, 0] = 0.0
	}
	loop over Solution only dup [0, -1] on boundary {
		Solution@[0, 0] = 0.0
	}
}

Function applyBC_u@all {
	loop over u only dup [-1, 0] on boundary {
		u@[0, 0] = ( u@[1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over u only dup [1, 0] on boundary {
		u@[0, 0] = ( u@[-1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over u only dup [0, 1] on boundary {
		u@[0, 0] = 0.0
	}
	loop over u only dup [0, -1] on boundary {
		u@[0, 0] = 0.0
	}
}

Function applyBC_res@all {
	loop over res only dup [-1, 0] on boundary {
		res@[0, 0] = ( res@[1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over res only dup [1, 0] on boundary {
		res@[0, 0] = ( res@[-1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over res only dup [0, 1] on boundary {
		res@[0, 0] = 0.0
	}
	loop over res only dup [0, -1] on boundary {
		res@[0, 0] = 0.0
	}
}

Function applyBC_gen_residual_u@all {
	loop over gen_residual_u only dup [-1, 0] on boundary {
		gen_residual_u@[0, 0] = ( gen_residual_u@[1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over gen_residual_u only dup [1, 0] on boundary {
		gen_residual_u@[0, 0] = ( gen_residual_u@[-1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over gen_residual_u only dup [0, 1] on boundary {
		gen_residual_u@[0, 0] = 0.0
	}
	loop over gen_residual_u only dup [0, -1] on boundary {
		gen_residual_u@[0, 0] = 0.0
	}
}

Function applyBC_gen_error_u@all {
	loop over gen_error_u only dup [-1, 0] on boundary {
		gen_error_u@[0, 0] = ( gen_error_u@[1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over gen_error_u only dup [1, 0] on boundary {
		gen_error_u@[0, 0] = ( gen_error_u@[-1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over gen_error_u only dup [0, 1] on boundary {
		gen_error_u@[0, 0] = 0.0
	}
	loop over gen_error_u only dup [0, -1] on boundary {
		gen_error_u@[0, 0] = 0.0
	}
}

Function applyBC_p@coarsest {
	loop over p only dup [-1, 0] on boundary {
		p@[0, 0] = ( p@[1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over p only dup [1, 0] on boundary {
		p@[0, 0] = ( p@[-1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over p only dup [0, 1] on boundary {
		p@[0, 0] = 0.0
	}
	loop over p only dup [0, -1] on boundary {
		p@[0, 0] = 0.0
	}
}

Function applyBC_s@coarsest {
	loop over s only dup [-1, 0] on boundary {
		s@[0, 0] = ( s@[1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over s only dup [1, 0] on boundary {
		s@[0, 0] = ( s@[-1, 0] / ( 1.0 - ( ( (0.0+1.0j) * k ) * vf_gridWidth_x ) ) )
	}
	loop over s only dup [0, 1] on boundary {
		s@[0, 0] = 0.0
	}
	loop over s only dup [0, -1] on boundary {
		s@[0, 0] = 0.0
	}
}

Globals {
	Expr k = 80.0
	Expr omegaRelax = 0.6
	Var shift : Complex<Real> = (1.0+0.5j)
}

Function NormResidual@7 : Complex<Real> {
	Var reductionVar_0 : Complex<Real> = 0.0
	/* Residual => 0, 0 <-> 0, 0 */
	loop over Residual@7 with reduction ( + : reductionVar_0 ) {
		reductionVar_0 += ( Residual@7 * Residual@7 )
	}
	return sqrt ( reductionVar_0 )
}

Function Solve@7 {
	PreconditionedBiCGStab@7 (  )
}

Function PreconditionedBiCGStab@7 {
	/* Residual => 0, 0 <-> 0, 0 */
	/* RHS => 0, 0 <-> 0, 0 */
	/* Solution => -1, -1 <-> 1, 1 */
	communicate all of Solution@7
	loop over Residual@7 {
		Residual@7 = ( RHS@7 - ( ( A@7 * Solution@7 ) ) )
	}
	Var curRes : Complex<Real> = NormResidual@7 (  )
	Var initRes : Complex<Real> = curRes
	if ( ( curRes == 0.0 ) ) {
		return
	}
	Var alpha : Complex<Real> = 1.0
	Var beta : Complex<Real> = 1.0
	Var rho : Complex<Real>
	Var rhoNew : Complex<Real> = 1.0
	Var omega : Complex<Real> = 1.0
	/* Residual => 0, 0 <-> 0, 0 */
	/* resHat => 0, 0 <-> 0, 0 */
	loop over resHat@7 {
		resHat@7 = Residual@7
	}
	/* ap => 0, 0 <-> 0, 0 */
	loop over ap@7 {
		ap@7 = 0.0
	}
	/* p => 0, 0 <-> 0, 0 */
	loop over p@7 {
		p@7 = 0.0
	}
	Var curStep : Integer = 0
	repeat 10000 times count curStep {
		rho = rhoNew
		Var reductionVar_1 : Complex<Real> = 0.0
		/* Residual => 0, 0 <-> 0, 0 */
		/* resHat => 0, 0 <-> 0, 0 */
		loop over resHat@7 with reduction ( + : reductionVar_1 ) {
			reductionVar_1 += ( resHat@7 * Residual@7 )
		}
		rhoNew = reductionVar_1
		beta = ( ( rhoNew / rho ) * ( alpha / omega ) )
		/* Residual => 0, 0 <-> 0, 0 */
		/* ap => 0, 0 <-> 0, 0 */
		/* p => 0, 0 <-> 0, 0 */
		loop over p@7 {
			p@7 = ( Residual@7 + ( beta * ( p@7 - ( omega * ap@7 ) ) ) )
		}
		/* u => 0, 0 <-> 0, 0 */
		loop over u@7 {
			u@7 = 0
		}
		apply bc to u@7
		/* p => 0, 0 <-> 0, 0 */
		/* f => 0, 0 <-> 0, 0 */
		loop over f@7 {
			f@7 = p@7
		}
		mgCycle@7 (  )
		/* u => -1, -1 <-> 1, 1 */
		/* ap => 0, 0 <-> 0, 0 */
		communicate all of u@7
		loop over ap@7 {
			ap@7 = ( ( A@7 * u@7 ) )
		}
		Var reductionVar_2 : Complex<Real> = 0.0
		/* resHat => 0, 0 <-> 0, 0 */
		/* ap => 0, 0 <-> 0, 0 */
		loop over resHat@7 with reduction ( + : reductionVar_2 ) {
			reductionVar_2 += ( resHat@7 * ap@7 )
		}
		alpha = ( rhoNew / reductionVar_2 )
		/* u => 0, 0 <-> 0, 0 */
		/* h => 0, 0 <-> 0, 0 */
		/* Solution => 0, 0 <-> 0, 0 */
		loop over h@7 {
			h@7 = ( Solution@7 + ( alpha * u@7 ) )
		}
		/* Residual => 0, 0 <-> 0, 0 */
		/* s => 0, 0 <-> 0, 0 */
		/* ap => 0, 0 <-> 0, 0 */
		loop over s@7 {
			s@7 = ( Residual@7 - ( alpha * ap@7 ) )
		}
		/* u => 0, 0 <-> 0, 0 */
		loop over u@7 {
			u@7 = 0
		}
		apply bc to u@7
		/* s => 0, 0 <-> 0, 0 */
		/* f => 0, 0 <-> 0, 0 */
		loop over f@7 {
			f@7 = s@7
		}
		mgCycle@7 (  )
		/* u => -1, -1 <-> 1, 1 */
		/* t => 0, 0 <-> 0, 0 */
		communicate all of u@7
		loop over t@7 {
			t@7 = ( ( A@7 * u@7 ) )
		}
		Var reductionVar_3 : Complex<Real> = 0.0
		Var reductionVar_4 : Complex<Real> = 0.0
		/* s => 0, 0 <-> 0, 0 */
		/* t => 0, 0 <-> 0, 0 */
		loop over t@7 with reduction ( + : reductionVar_3 ) {
			reductionVar_3 += ( t@7 * s@7 )
		}
		/* t => 0, 0 <-> 0, 0 */
		loop over t@7 with reduction ( + : reductionVar_4 ) {
			reductionVar_4 += ( t@7 * t@7 )
		}
		omega = ( reductionVar_3 / reductionVar_4 )
		/* u => 0, 0 <-> 0, 0 */
		/* h => 0, 0 <-> 0, 0 */
		/* Solution => 0, 0 <-> 0, 0 */
		loop over Solution@7 {
			Solution@7 = ( h@7 + ( omega * u@7 ) )
		}
		apply bc to Solution@7
		/* Residual => 0, 0 <-> 0, 0 */
		/* s => 0, 0 <-> 0, 0 */
		/* t => 0, 0 <-> 0, 0 */
		loop over Residual@7 {
			Residual@7 = ( s@7 - ( omega * t@7 ) )
		}
		curRes = NormResidual@7 (  )
		if ( ( fabs ( curRes ) < ( 1.0E-7 * fabs ( initRes ) ) ) ) {
			print ( "Residual after", curStep, "iterations is", fabs ( curRes ), "--- convergence factor is", ( fabs ( curRes ) / fabs ( initRes ) ) )
			return
		}
	}
	print ( "Maximum number of solver iterations (", 10000, ") was exceeded" )
	print ( "Residual after", curStep, "iterations is", fabs ( curRes ), "--- convergence factor is", ( fabs ( curRes ) / fabs ( initRes ) ) )
}

Function PreSmoother@5 {
	repeat 2 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@5
			loop over u@5@[0, 0] {
				solve locally relax 0.6 {
					u@5@[0, 0] => ( ( M@5@[0, 0] * u@5@[0, 0] ) ) == f@5@[0, 0]
				}
			}
			apply bc to u@5
		}
	}
}

Function PreSmoother@6 {
	repeat 2 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@6
			loop over u@6@[0, 0] {
				solve locally relax 0.6 {
					u@6@[0, 0] => ( ( M@6@[0, 0] * u@6@[0, 0] ) ) == f@6@[0, 0]
				}
			}
			apply bc to u@6
		}
	}
}

Function PreSmoother@3 {
	repeat 2 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@3
			loop over u@3@[0, 0] {
				solve locally relax 0.6 {
					u@3@[0, 0] => ( ( M@3@[0, 0] * u@3@[0, 0] ) ) == f@3@[0, 0]
				}
			}
			apply bc to u@3
		}
	}
}

Function PreSmoother@7 {
	repeat 2 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@7
			loop over u@7@[0, 0] {
				solve locally relax 0.6 {
					u@7@[0, 0] => ( ( M@7@[0, 0] * u@7@[0, 0] ) ) == f@7@[0, 0]
				}
			}
			apply bc to u@7
		}
	}
}

Function PreSmoother@4 {
	repeat 2 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@4
			loop over u@4@[0, 0] {
				solve locally relax 0.6 {
					u@4@[0, 0] => ( ( M@4@[0, 0] * u@4@[0, 0] ) ) == f@4@[0, 0]
				}
			}
			apply bc to u@4
		}
	}
}

Function PostSmoother@5 {
	repeat 1 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@5
			loop over u@5@[0, 0] {
				solve locally relax 0.6 {
					u@5@[0, 0] => ( ( M@5@[0, 0] * u@5@[0, 0] ) ) == f@5@[0, 0]
				}
			}
			apply bc to u@5
		}
	}
}

Function PostSmoother@6 {
	repeat 1 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@6
			loop over u@6@[0, 0] {
				solve locally relax 0.6 {
					u@6@[0, 0] => ( ( M@6@[0, 0] * u@6@[0, 0] ) ) == f@6@[0, 0]
				}
			}
			apply bc to u@6
		}
	}
}

Function PostSmoother@3 {
	repeat 1 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@3
			loop over u@3@[0, 0] {
				solve locally relax 0.6 {
					u@3@[0, 0] => ( ( M@3@[0, 0] * u@3@[0, 0] ) ) == f@3@[0, 0]
				}
			}
			apply bc to u@3
		}
	}
}

Function PostSmoother@7 {
	repeat 1 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@7
			loop over u@7@[0, 0] {
				solve locally relax 0.6 {
					u@7@[0, 0] => ( ( M@7@[0, 0] * u@7@[0, 0] ) ) == f@7@[0, 0]
				}
			}
			apply bc to u@7
		}
	}
}

Function PostSmoother@4 {
	repeat 1 times {
		color with {
			( ( i0 + i1 ) % 2 ),
			/* u => -1, -1 <-> 1, 1 */
			/* f => 0, 0 <-> 0, 0 */
			communicate all of u@4
			loop over u@4@[0, 0] {
				solve locally relax 0.6 {
					u@4@[0, 0] => ( ( M@4@[0, 0] * u@4@[0, 0] ) ) == f@4@[0, 0]
				}
			}
			apply bc to u@4
		}
	}
}

Function mgCycle@5 {
	PreSmoother@5 (  )
	/* u => -1, -1 <-> 1, 1 */
	/* f => 0, 0 <-> 0, 0 */
	/* res => 0, 0 <-> 0, 0 */
	communicate all of u@5
	loop over res@5 {
		res@5 = ( f@5 - ( ( M@5 * u@5 ) ) )
	}
	apply bc to res@5
	/* res => -1, -1 <-> 1, 1 */
	/* f => 0, 0 <-> 0, 0 */
	communicate all of res@5
	loop over f@4 {
		f@4 = ( ( Restriction_u@5 * res@5 ) )
	}
	/* u => 0, 0 <-> 0, 0 */
	loop over u@4 {
		u@4 = 0.0
	}
	apply bc to u@4
	mgCycle@4 (  )
	/* u => 0, 0 <-> 0, 0 */
	/* u => 0, 0 <-> 1, 1 */
	communicate all of u@4
	loop over u@5 {
		u@5 += ( ( Prolongation_u@4 * u@4 ) )
	}
	apply bc to u@5
	PostSmoother@5 (  )
}

Function mgCycle@6 {
	PreSmoother@6 (  )
	/* u => -1, -1 <-> 1, 1 */
	/* res => 0, 0 <-> 0, 0 */
	/* f => 0, 0 <-> 0, 0 */
	communicate all of u@6
	loop over res@6 {
		res@6 = ( f@6 - ( ( M@6 * u@6 ) ) )
	}
	apply bc to res@6
	/* f => 0, 0 <-> 0, 0 */
	/* res => -1, -1 <-> 1, 1 */
	communicate all of res@6
	loop over f@5 {
		f@5 = ( ( Restriction_u@6 * res@6 ) )
	}
	/* u => 0, 0 <-> 0, 0 */
	loop over u@5 {
		u@5 = 0.0
	}
	apply bc to u@5
	mgCycle@5 (  )
	/* u => 0, 0 <-> 1, 1 */
	/* u => 0, 0 <-> 0, 0 */
	communicate all of u@5
	loop over u@6 {
		u@6 += ( ( Prolongation_u@5 * u@5 ) )
	}
	apply bc to u@6
	PostSmoother@6 (  )
}

Function mgCycle@7 {
	PreSmoother@7 (  )
	/* u => -1, -1 <-> 1, 1 */
	/* res => 0, 0 <-> 0, 0 */
	/* f => 0, 0 <-> 0, 0 */
	communicate all of u@7
	loop over res@7 {
		res@7 = ( f@7 - ( ( M@7 * u@7 ) ) )
	}
	apply bc to res@7
	/* res => -1, -1 <-> 1, 1 */
	/* f => 0, 0 <-> 0, 0 */
	communicate all of res@7
	loop over f@6 {
		f@6 = ( ( Restriction_u@7 * res@7 ) )
	}
	/* u => 0, 0 <-> 0, 0 */
	loop over u@6 {
		u@6 = 0.0
	}
	apply bc to u@6
	mgCycle@6 (  )
	/* u => 0, 0 <-> 1, 1 */
	/* u => 0, 0 <-> 0, 0 */
	communicate all of u@6
	loop over u@7 {
		u@7 += ( ( Prolongation_u@6 * u@6 ) )
	}
	apply bc to u@7
	PostSmoother@7 (  )
}

Function mgCycle@4 {
	PreSmoother@4 (  )
	/* u => -1, -1 <-> 1, 1 */
	/* res => 0, 0 <-> 0, 0 */
	/* f => 0, 0 <-> 0, 0 */
	communicate all of u@4
	loop over res@4 {
		res@4 = ( f@4 - ( ( M@4 * u@4 ) ) )
	}
	apply bc to res@4
	/* res => -1, -1 <-> 1, 1 */
	/* f => 0, 0 <-> 0, 0 */
	communicate all of res@4
	loop over f@3 {
		f@3 = ( ( Restriction_u@4 * res@4 ) )
	}
	/* gen_error_u => 0, 0 <-> 0, 0 */
	loop over gen_error_u@3 {
		gen_error_u@3 = 0.0
	}
	apply bc to gen_error_u@3
	mgCycle@3 (  )
	/* u => 0, 0 <-> 0, 0 */
	/* gen_error_u => 0, 0 <-> 0, 0 */
	loop over u@3 {
		u@3 = gen_error_u@3
	}
	apply bc to u@3
	/* u => 0, 0 <-> 0, 0 */
	/* u => 0, 0 <-> 1, 1 */
	communicate all of u@3
	loop over u@4 {
		u@4 += ( ( Prolongation_u@3 * u@3 ) )
	}
	apply bc to u@4
	PostSmoother@4 (  )
}

Function mgCycle@3 {
	/* gen_error_u => -1, -1 <-> 1, 1 */
	/* f => 0, 0 <-> 0, 0 */
	/* gen_residual_u => 0, 0 <-> 0, 0 */
	communicate all of gen_error_u@3
	loop over gen_residual_u@3 {
		gen_residual_u@3 = ( f@3 - ( ( M@3 * gen_error_u@3 ) ) )
	}
	apply bc to gen_residual_u@3
	Var reductionVar_5 : Complex<Real> = 0.0
	/* gen_residual_u => 0, 0 <-> 0, 0 */
	loop over gen_residual_u@3 with reduction ( + : reductionVar_5 ) {
		reductionVar_5 += ( gen_residual_u@3 * gen_residual_u@3 )
	}
	Var curRes : Complex<Real> = sqrt ( reductionVar_5 )
	Var initRes : Complex<Real> = curRes
	if ( ( curRes == 0.0 ) ) {
		return
	}
	Var alpha : Complex<Real> = 1.0
	Var beta : Complex<Real> = 1.0
	Var rho : Complex<Real>
	Var rhoNew : Complex<Real> = 1.0
	Var omega : Complex<Real> = 1.0
	/* resHat => 0, 0 <-> 0, 0 */
	/* gen_residual_u => 0, 0 <-> 0, 0 */
	loop over resHat@3 {
		resHat@3 = gen_residual_u@3
	}
	/* nu => 0, 0 <-> 0, 0 */
	loop over nu@3 {
		nu@3 = 0.0
	}
	/* p => 0, 0 <-> 0, 0 */
	loop over p@3 {
		p@3 = 0.0
	}
	apply bc to p@3
	Var curStep : Integer = 0
	repeat 1000 times count curStep {
		rho = rhoNew
		Var reductionVar_6 : Complex<Real> = 0.0
		/* resHat => 0, 0 <-> 0, 0 */
		/* gen_residual_u => 0, 0 <-> 0, 0 */
		loop over resHat@3 with reduction ( + : reductionVar_6 ) {
			reductionVar_6 += ( resHat@3 * gen_residual_u@3 )
		}
		rhoNew = reductionVar_6
		beta = ( ( rhoNew / rho ) * ( alpha / omega ) )
		/* nu => 0, 0 <-> 0, 0 */
		/* p => 0, 0 <-> 0, 0 */
		/* gen_residual_u => 0, 0 <-> 0, 0 */
		loop over p@3 {
			p@3 = ( gen_residual_u@3 + ( beta * ( p@3 - ( omega * nu@3 ) ) ) )
		}
		apply bc to p@3
		/* nu => 0, 0 <-> 0, 0 */
		/* p => -1, -1 <-> 1, 1 */
		communicate all of p@3
		loop over nu@3 {
			nu@3 = ( ( M@3 * p@3 ) )
		}
		Var reductionVar_7 : Complex<Real> = 0.0
		/* nu => 0, 0 <-> 0, 0 */
		/* resHat => 0, 0 <-> 0, 0 */
		loop over resHat@3 with reduction ( + : reductionVar_7 ) {
			reductionVar_7 += ( resHat@3 * nu@3 )
		}
		alpha = ( rhoNew / reductionVar_7 )
		/* gen_error_u => 0, 0 <-> 0, 0 */
		/* p => 0, 0 <-> 0, 0 */
		/* h => 0, 0 <-> 0, 0 */
		loop over h@3 {
			h@3 = ( gen_error_u@3 + ( alpha * p@3 ) )
		}
		/* nu => 0, 0 <-> 0, 0 */
		/* gen_residual_u => 0, 0 <-> 0, 0 */
		/* s => 0, 0 <-> 0, 0 */
		loop over s@3 {
			s@3 = ( gen_residual_u@3 - ( alpha * nu@3 ) )
		}
		apply bc to s@3
		/* t => 0, 0 <-> 0, 0 */
		/* s => -1, -1 <-> 1, 1 */
		communicate all of s@3
		loop over t@3 {
			t@3 = ( ( M@3 * s@3 ) )
		}
		Var reductionVar_8 : Complex<Real> = 0.0
		Var reductionVar_9 : Complex<Real> = 0.0
		/* t => 0, 0 <-> 0, 0 */
		/* s => 0, 0 <-> 0, 0 */
		loop over t@3 with reduction ( + : reductionVar_8 ) {
			reductionVar_8 += ( t@3 * s@3 )
		}
		/* t => 0, 0 <-> 0, 0 */
		loop over t@3 with reduction ( + : reductionVar_9 ) {
			reductionVar_9 += ( t@3 * t@3 )
		}
		omega = ( reductionVar_8 / reductionVar_9 )
		/* gen_error_u => 0, 0 <-> 0, 0 */
		/* s => 0, 0 <-> 0, 0 */
		/* h => 0, 0 <-> 0, 0 */
		loop over gen_error_u@3 {
			gen_error_u@3 = ( h@3 + ( omega * s@3 ) )
		}
		apply bc to gen_error_u@3
		/* t => 0, 0 <-> 0, 0 */
		/* s => 0, 0 <-> 0, 0 */
		/* gen_residual_u => 0, 0 <-> 0, 0 */
		loop over gen_residual_u@3 {
			gen_residual_u@3 = ( s@3 - ( omega * t@3 ) )
		}
		apply bc to gen_residual_u@3
		Var reductionVar_10 : Complex<Real> = 0.0
		/* gen_residual_u => 0, 0 <-> 0, 0 */
		loop over gen_residual_u@3 with reduction ( + : reductionVar_10 ) {
			reductionVar_10 += ( gen_residual_u@3 * gen_residual_u@3 )
		}
		curRes = sqrt ( reductionVar_10 )
		if ( ( fabs ( curRes ) < ( 1.0E-6 * fabs ( initRes ) ) ) ) {
			return
		}
	}
}

Function InitFields {
	/* Solution => 0, 0 <-> 0, 0 */
	loop over Solution@7 {
		Solution@7 = 0.0
	}
	apply bc to Solution@7
	/* RHS => 0, 0 <-> 0, 0 */
	loop over RHS@7 {
		RHS@7 = ( max ( 0, ( (-( fabs ( ( vf_nodePosition_0@7@[0, 0] - 0.5 ) ) - 0.0078125 )) / ( 0.0078125 ** 2 ) ) ) * max ( 0, ( (-( fabs ( ( vf_nodePosition_1@7@[0, 0] - 0.5 ) ) - 0.0078125 )) / ( 0.0078125 ** 2 ) ) ) )
	}
}

