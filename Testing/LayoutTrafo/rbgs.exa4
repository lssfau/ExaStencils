LayoutTransformations {
  transform Solution@finest, RHS@(4 to finest)  with [x, y, z] => [x/2, y, z, (x+y+z)%2]
  concat @(0 to 3) Solution, RHS, Residual into Merged
  rename Residual@all to Toll
  transform Merged@(coarsest + 1)  with [x, y, z, i] => [y, z, x, i]
}

Domain global< [0.0, 0.0, 0.0] to [1.0, 1.0, 1.0] >

Layout NoComm< Real, Node >@all {
	ghostLayers = [0, 0, 0]
	duplicateLayers = [1, 1, 1]
}

Layout CommPartTempBlockable< Real, Node >@all {
	ghostLayers = [0, 0, 0]
	duplicateLayers = [1, 1, 1]
}

Layout BasicComm< Real, Node >@all {
	ghostLayers = [1, 1, 1] with communication
	duplicateLayers = [1, 1, 1] with communication
}

Layout CommFullTempBlockable< Real, Node >@all {
	ghostLayers = [1, 1, 1] with communication
	duplicateLayers = [1, 1, 1] with communication
}

Field Solution< global, BasicComm, 0.0 >@(coarsest to 0)

Field Solution< global, CommFullTempBlockable, 0.0 >@(1 to (finest - 1))

Field Solution< global, CommFullTempBlockable, ( ( ( vf_boundaryCoord_x@current * vf_boundaryCoord_x@current ) - ( ( 0.5 * vf_boundaryCoord_y@current ) * vf_boundaryCoord_y@current ) ) - ( ( 0.5 * vf_boundaryCoord_z@current ) * vf_boundaryCoord_z@current ) ) >@finest

Field Residual< global, BasicComm, 0.0 >@all

Field RHS< global, NoComm, None >@(coarsest to 0)

Field RHS< global, CommPartTempBlockable, None >@(1 to finest)

Field VecP< global, BasicComm, 0.0 >@coarsest

Field VecGradP< global, NoComm, None >@coarsest

Stencil Laplace@all{
	[0, 0, 0] => 6.0
	[1, 0, 0] => -1.0
	[-1, 0, 0] => -1.0
	[0, 1, 0] => -1.0
	[0, -1, 0] => -1.0
	[0, 0, 1] => -1.0
	[0, 0, -1] => -1.0
}

Stencil CorrectionStencil from default prolongation on Node with "linear"

Stencil RestrictionStencil from default restriction on Node with "linear"



Function VCycle@coarsest {
	VCycle_0@current (  )
}

Function VCycle_0@coarsest {
	UpResidual@current (  )
	communicate Residual@current
	Var res : Real = NormResidual_0@current (  )
	Var initialRes : Real = res
	loop over VecP@current {
		VecP@current = Residual@current
	}
	Var cgSteps : Integer
	repeat 512 times count cgSteps {
		communicate VecP@current
		loop over VecP@current {
			VecGradP@current = ( Laplace@current * VecP@current )
		}
		Var alphaDenom : Real = 0
		loop over VecP@current where ( ( ( i0 > 0 ) && ( i1 > 0 ) ) && ( i2 > 0 ) ) with reduction ( + : alphaDenom ) {
			alphaDenom += ( VecP@current * VecGradP@current )
		}
		Var alpha : Real = ( ( res * res ) / alphaDenom )
		loop over Solution@current {
			Solution[active]@current += ( alpha * VecP@current )
			Residual@current -= ( alpha * VecGradP@current )
		}
		Var nextRes : Real = NormResidual_0@current (  )
		if ( ( nextRes <= ( 0.001 * initialRes ) ) ) {
			return
		}
		Var beta : Real = ( ( nextRes * nextRes ) / ( res * res ) )
		loop over VecP@current {
			VecP@current = ( Residual@current + ( beta * VecP@current ) )
		}
		res = nextRes
	}
	print ( "Maximum number of cgs iterations (", 512, ") was exceeded" )
}

Function VCycle@((coarsest + 1) to finest) {
	repeat 3 times {
		Smoother@current (  )
	}
	UpResidual@current (  )
	Restriction@current (  )
	SetSolution@coarser ( 0 )
	VCycle@coarser (  )
	Correction@current (  )
	repeat 3 times {
		Smoother@current (  )
	}
}

Function Smoother@((coarsest + 1) to finest) {
	communicate Solution@current where ( 1 == ( ( ( ( 64 + i0 ) + i1 ) + i2 ) % 2 ) )
	loop over Solution@current where ( 0 == ( ( ( i0 + i1 ) + i2 ) % 2 ) ) {
		Solution[0]@current = ( Solution[0]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 1.0 ) * ( RHS@current - ( Laplace@current * Solution[0]@current ) ) ) )
	}
	communicate Solution@current where ( 0 == ( ( ( ( 64 + i0 ) + i1 ) + i2 ) % 2 ) )
	loop over Solution@current where ( 1 == ( ( ( i0 + i1 ) + i2 ) % 2 ) ) {
		Solution[0]@current = ( Solution[0]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 1.0 ) * ( RHS@current - ( Laplace@current * Solution[0]@current ) ) ) )
	}
}

Function UpResidual@all {
	communicate Solution[active]@current
	loop over Residual@current {
		Residual@current = ( RHS@current - ( Laplace@current * Solution[active]@current ) )
	}
}

Function NormResidual_0@(finest, coarsest) : Real {
	Var res : Real = 0
	loop over Residual@current where ( ( ( i0 > 0 ) && ( i1 > 0 ) ) && ( i2 > 0 ) ) with reduction ( + : res ) {
		res += ( Residual@current * Residual@current )
	}
	return sqrt ( res )
}

Function Restriction@((coarsest + 1) to finest) {
	communicate ghost of Residual@current
	loop over RHS@coarser {
		RHS@coarser = ( ( 4.0 * RestrictionStencil@current ) * Residual@current )
	}
}

Function Correction@((coarsest + 1) to finest) {
	communicate ghost of Solution[active]@coarser
	loop over Solution@current {
		Solution[active]@current += ( CorrectionStencil@current * Solution[active]@coarser )
	}
}

Function SetSolution@all ( value : Real ) {
	loop over Solution@current {
		Solution[active]@current = value
	}
}

Function InitSolution {
	loop over Solution@finest {
		Solution[active]@finest = 0
	}
}

Function InitRHS@finest {
	loop over RHS@current {
		RHS@current = 0.0
	}
}

Function Solve {
	UpResidual@finest (  )
	Var resStart_0 : Real = NormResidual_0@finest (  )
	Var res_0 : Real = resStart_0
	Var resOld_0 : Real = 0
	print ( "Starting residual at 0", resStart_0 )
	startTimer ( "timeToSolve" )
	Var numIt : Integer = 0
	repeat until ( ( res_0 < ( 1.0E-5 * resStart_0 ) ) || ( numIt >= 100 ) ) {
		numIt += 1
		startTimer ( "cycle" )
		VCycle@finest (  )
		stopTimer ( "cycle" )
		if ( ( getTotalFromTimer ( "cycle" ) > 1200000 ) ) {
			print ( "Aborting solve after", getTotalFromTimer ( "cycle" ), "ms which exceeds the limit of", 1200000, "ms" )
			return
		}
		startTimer ( "convergenceChecking" )
		UpResidual@finest (  )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		print ( "Residual at 0:", res_0, "Residual reduction:", ( resStart_0 / res_0 ), "Convergence factor:", ( res_0 / resOld_0 ) )
		stopTimer ( "convergenceChecking" )
	}
	stopTimer ( "timeToSolve" )
	print ( "Total time to solve in", numIt, "steps :", getTotalFromTimer ( "timeToSolve" ) )
	print ( "Mean time per vCycle: ", getMeanFromTimer ( "cycle" ) )
}

Function Application {
	startTimer ( "setup" )
	initGlobals (  )
	initDomain (  )
	initFieldsWithZero (  )
	stopTimer ( "setup" )
	print ( "Total time to setup: ", getTotalFromTimer ( "setup" ) )
	InitRHS@finest (  )
	InitSolution (  )
	apply bc to Solution@0
	apply bc to Solution@1
	apply bc to Solution@2
	apply bc to Solution@3
	apply bc to Solution@4
	apply bc to Solution@5
	apply bc to Solution@6
	apply bc to Solution@7
	apply bc to VecP@coarsest
	Solve (  )
	destroyGlobals (  )
}
