Concept:
- Find a way to express dependencies between different trafos (must occur after x and must occur before y, etc) and ideally implement an according scheduler/ optimizer
- Use nodes by reference or apply deep copy? -> automatically apply duplicate for subclasses of node; all other objects (esp fields, stencils and other knowledge objects) should be copied by reference

Framework:
- Lib/ Inc Blocks in HW Knowledge
- reserve C keywords in lexer
- Extend Settings parser to support floating point numbers

- add possibility to specify trafos, that don't exchange nodes, i.e. read-only or only node-internal modification; goal is not having to return a result (for more readability and deep matches)
- add delete node functionality

- check uniform usage over 'override' keyword
- check 'var' usage
- check ';' usage

- think about adding the functionality to check files before writing against existing versions to reduce compile time afterwards

L3:

L4:
- leveled variables
- add Value/Val to l4 => extend DataType and/or VariableDeclarationStatement

IR:
- add one distinct communicator per (sub)domain

ISL:
- L4 constraints to ISL mapping
- long term: reduce optimization runtime

Bugs:
- Setting position dependent bc's for equvalent points on different fragments might lead to diverging results (this only occures with comm strat 26, as the values in question are overwritten with comm strat 6):
	int x0 = 0;
	Vec3 pos0 = (Vec3(((((0*3)+5.000000e-01)+x0)*3.333333e-01)+0.000000e+00,((0+5.000000e-01)+0),0));
	int x1 = 1;
	Vec3 pos1 = (Vec3(((((0*3)+5.000000e-01)+x1)*3.333333e-01)+0.000000e+00,((0+5.000000e-01)+0),0));

	Vec3 posBegin0 = pos0-Vec3(1.666667e-01,5.000000e-01,0);
	Vec3 posEnd0 = pos0+Vec3(1.666667e-01,5.000000e-01,0);
	Vec3 posBegin1 = pos1-Vec3(1.666667e-01,5.000000e-01,0);
	Vec3 posEnd1 = pos1+Vec3(1.666667e-01,5.000000e-01,0);

	double xPos0 = ((((18-2)/1.600000e+01)*(posEnd0[0]-posBegin0[0]))+posBegin0[0]);
	double yPos0 = ((((17-1)/1.600000e+01)*(posEnd0[1]-posBegin0[1]))+posBegin0[1]);
	double xPos1 = ((((2-2)/1.600000e+01)*(posEnd1[0]-posBegin1[0]))+posBegin1[0]);
	double yPos1 = ((((17-1)/1.600000e+01)*(posEnd1[1]-posBegin1[1]))+posBegin1[1]);

	double v0 = (sin((M_PI*xPos0))*sinh((M_PI*yPos0)));
	double v1 = (sin((M_PI*xPos1))*sinh((M_PI*yPos1)));
