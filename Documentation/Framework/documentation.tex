\documentclass{article}
\usepackage{listings}
\usepackage{relsize}
\usepackage[xcolor=dvipsnames]{xcolor}

\newcommand{\hlA}[1]{\textcolor{orange}{#1}}
\newcommand{\hlB}[1]{\textcolor{WildStrawberry!80!black}{#1}}
\newcommand{\hlC}[1]{\textcolor{Cerulean}{#1}}

\def\colorFG{black}

\def\lstScalaCommentStyle{\itshape\color{gray!90!\colorFG}}
\usepackage{listings}
\lstset{
basicstyle=\tt\relsize{-1},
showstringspaces=false,
breaklines=true,
keywordstyle=\color{MidnightBlue!70!\colorFG},
commentstyle=\lstScalaCommentStyle,
stringstyle=\color{gray!70!\colorFG},
captionpos=b,
xleftmargin=1.25em,
keepspaces=true,
numberstyle=\tiny\color{gray}
}

\lstdefinelanguage{scala}{%
keywords={[2]% Scala keywords
  abstract,case,catch,class,def,do,else,extends,
  false,final,finally,for,forSome,if,implicit,import,lazy,
  match,new,null,object,override,package,private,protected,
  return,sealed,super,this,throw,trait,true,try,type,
  val,var,while,with,yield
},
keywordstyle={[2]\color{blue!70!\colorFG}},
keywords={[3]% Scala datatypes
  Some, List, Any, None, _, Option, 
  Boolean, String, Function, PartialFunction, Int
},
keywordstyle={[3]\color{blue!70!\colorFG}},
keywords={[4]% Framework keywords
  Strategy, Transformation, apply, Output, StateManager, 
  Annotatable, Annotation, AnnotationManager, annotate, removeAnnotation,
  Node,
  Collector, enter, leave, reset,
},
keywordstyle={[4]\color{blue!70!\colorFG}\bfseries},
keywords={[5]% Framework datatypes
  Constant, Variable, FunctionStatement
},
keywordstyle={[5]\color{purple!70!\colorFG}},
sensitive,
morestring=[b]",
morestring=[d]',
comment=[l]//,
morecomment=[s]{/*}{*/},
commentstyle=\lstScalaCommentStyle,
}



\begin{document}





\section{General Concepts}

\begin{itemize}
 \item Specialized data structures for each DSL level
 \begin{enumerate}
  \item[L1] DSL level 1
  \item[L2] DSL level 2
  \item[L3] DSL level 3
  \item[L4] DSL level 4
  \item[IR] Intermediate representation: for optimizations, hardware specialization, \ldots
  \item[PP] optional: Prettyprinting: Further transformations may be needed for prettyprinting in a specific language
 \end{enumerate}

 \item Collaboration between different groups and users via data structures in program state
 \item SPL / domain knowledge to be accessible compiler-wide (like a library)
 
  \item A central instance keeps track of program state changes: \hlA{StateManager}
 \item Prettyprinting implemented via internal methods
 \item Nodes in program state may be annotated
 \item Clear sectioning of functionality into namespaces, e.\,g.,
 \begin{itemize}
   \item \lstinline[language=scala]{exastencils.core}: Log functionality, \lstinline[language=scala]{StateManager}, compiler settings
   \item \lstinline[language=scala]{exastencils.core.collectors}
   \item \lstinline[language=scala]{exastencils.datastructures}: Annotations, Program state duplication, \lstinline[language=scala]{trait Strategy}, \lstinline[language=scala]{trait Transformation}
   \item \lstinline[language=scala]{exastencils.datastructures.(l1, l2, l3, l4, ir)}
   \item \lstinline[language=scala]{exastencils.parsers}
   \item \lstinline[language=scala]{exastencils.prettyprinting}
 \end{itemize}
\end{itemize}



\section{Transformations}
\begin{itemize}
 \item Carry an identifier
 \item Are grouped together in Strategies
 \item Are atomic -- either applied completely or not at all
 \item Are applied to program state in depth search order
 \item May be applied to a part of the program state
 \item May contain more than one \lstinline[language=scala]{case} statement
\end{itemize}


\begin{lstlisting}[language=scala]
class Transformation (
  name : String,
  function : Function[Node, Transformation.Output[_]],
  recursive : Boolean = true,
  applyAtNode : Option[Node] = None
)

class Output [T <% Node Or List[Node]] (
  val inner : T
)

class TransformationResult (
  val successful : Boolean,
  val matches : Int,
  val replacements : Int
)
\end{lstlisting}

\begin{lstlisting}[language=scala]
class Transformation (
  name : String,
  function : Function[Node, Transformation.Output[_]],
  recursive : Boolean = true,
  applyAtNode : Option[Node] = None
)
\end{lstlisting}

\begin{itemize}
 \item \lstinline[language=scala]{function} denotes the pattern to look for and to replace with
 \item Different return values possible:
 \begin{itemize}
  \item Object for replacement (may be the same instance as in the pattern)
  \item \lstinline[language=scala]{List[_]}: replaces one node with multiple nodes (if applicable)
  \item \lstinline[language=scala]{None}: remove node (if applicable)
 \end{itemize}
\end{itemize}





\section{Strategies}
\begin{itemize}
 \item Carry an identifier
 \item Are applied in transactions
 \item Are applied by the StateManager
 \item A standard strategy that linearly executes all transformations is provided
 \item Custom strategies possible
\end{itemize}

\begin{lstlisting}[language=scala, escapechar=\%, breaklines=false]
var s = Strategy("example standard strategy")

// replace constant '1' under a certain node with '3'
s += Transformation("t1",
     { case x : Constant if(x.Value == 1)
       => Constant(3)
     }, someProgramStateNode)

// rename all variables to 'j'
s += Transformation("t2",
     { case x : Variable
       => Variable("j", x.Type)
     })

// duplicate all methods
s += Transformation("t3",
     { case x : FunctionStatement
       => List(x, FunctionStatement(
         x.returntype, x.name + "_", x.parameters, x.body))
     })
s.apply
\end{lstlisting}


\begin{lstlisting}[language=scala]
class ExampleStrategy extends Strategy("example") {
  override def apply = {
  
    // acquire token
    val token = StateManager.transaction(this)
    
    // define and apply transformation
    val t1 = Transformation("t1",
      { case x : Constant if(x.value == 1)
        => Constant(3) })
    val result = StateManager.apply(token, t1)
    
    // end the transaction
    if(result.matches > 10) {
      StateManager.abort(token)
    } else {
      StateManager.commit(token)
    }
  }
}
\end{lstlisting}




\section{Transactions}
\begin{itemize}
 \item Before application, a snapshot of the program state is made
 \item May be committed or aborted
 \item Can not run concurrently
\end{itemize}

\section{Collectors}
\begin{itemize}
 \item May be supplied to gather further information during program state traversal
 \item Enable context-sensitive transformations
\end{itemize}


\section{Annotations}
\begin{itemize}
 \item Allow adding information to object instances
 \item Optionally carry a value
 \item May be removed from an object again
 \item Every node in the program state \lstinline[language=scala]{extends Annotatable}
 \item \lstinline[language=scala]{Annotatable} may also be added to custom classes
 \item Annotations may be added, removed and checked for existence
% \item Optional: New valid annotation names to be registered at \lstinline[language=scala]{AnnotationManager} prior to first use
\end{itemize}


\begin{lstlisting}[language=scala, breaklines=false]
var s = Strategy("example standard strategy")

// mark all nodes as visited
s += Transformation("mark",
     { case x => x.annotate("visited"); Some(x)
     })

// remove marker
s += Transformation("unmark",
     { case x => x.removeAnnotation("visited"); Some(x)
     })

s.apply
\end{lstlisting}



\section{Collectors}

\begin{itemize}
 \item Are notified for each node visited and left during a transformation
 \item Report only on the program state (i.\,e., whatever \lstinline[language=scala]{extends Node})
 \item Allow for checks \`a la ``this node is an indirect subnode of X''
 \item A stack-based default Collector is provided by the framework
 \item Custom Collectors need to extend a trait consisting of only 3 methods (\lstinline[language=scala]{enter()}, \lstinline[language=scala]{leave()}, \lstinline[language=scala]{reset()})
 \item Collectors are (de)registered via \lstinline[language=scala]{StateManager}
 \item Most useful in custom strategies
\end{itemize}


\end{document}