Domain global< [ 0, 0 ] to [ 1, 1 ] >

Layout NoComm< Real, Node >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 1, 1 ]
}
Layout CommPartTempBlockable< Real, Node >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 1, 1 ]
}
Layout BasicComm< Real, Node >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 1, 1 ] with communication
}
Layout CommFullTempBlockable< Real, Node >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 1, 1 ] with communication
}

Field Solution< global, BasicComm, 0.0 >[2]@(coarsest to 0)
Field Solution< global, CommFullTempBlockable, 0.0 >[2]@(1 to finest)
Field Residual< global, BasicComm, 0.0 >@all
Field RHS< global, NoComm, None >@(coarsest to 0)
Field RHS< global, CommPartTempBlockable, None >@(1 to finest)
Field VecP< global, BasicComm, 0.0 >@coarsest
Field VecGradP< global, NoComm, None >@coarsest

Stencil Laplace@all {
	[ 0,  0] => 4.0
	[ 1,  0] => -1.0
	[-1,  0] => -1.0
	[ 0,  1] => -1.0
	[ 0, -1] => -1.0
}
Stencil CorrectionStencil@all {
	[    0,     0] => 0.25
	[x % 2,     0] => 0.25
	[    0, y % 2] => 0.25
	[x % 2, y % 2] => 0.25
}
Stencil RestrictionStencil@all {
	[ 0,  0] => 1.0
	[ 0, -1] => 0.5
	[ 0,  1] => 0.5
	[-1,  0] => 0.5
	[ 1,  0] => 0.5
	[-1, -1] => 0.25
	[-1,  1] => 0.25
	[ 1, -1] => 0.25
	[ 1,  1] => 0.25
}

Globals {
}

Function VCycle@coarsest ( ) : Unit {
	VCycle_0@current ( )
}
Function VCycle_0@coarsest ( ) : Unit {
	UpResidual@current ( )
	communicate  Residual@current
	Variable res : Real = NormResidual_0@current ( )
	Variable initialRes : Real = res
	loop over VecP@current {
		VecP@current = Residual@current
	}
	Variable cgSteps : Integer
	repeat 512 times count cgSteps {
	communicate  VecP@current
		loop over VecP@current {
			VecGradP@current = Laplace@current * VecP@current
		}
		Variable alphaDenom : Real = 0
		loop over VecP@current where x > 0 && y > 0 with reduction( + : alphaDenom ) {
			alphaDenom += VecP@current * VecGradP@current
		}
		Variable alpha : Real = res * res / alphaDenom
		loop over Solution@current {
			Solution[currentSlot]@current += alpha * VecP@current
			Residual@current -= alpha * VecGradP@current
		}
		Variable nextRes : Real = NormResidual_0@current ( )
		if ( nextRes <= 0.001 * initialRes ) {
			return
		}
		Variable beta : Real = (nextRes * nextRes) / (res * res)
		loop over VecP@current {
			VecP@current = Residual@current + beta * VecP@current
		}
		res = nextRes
	}
}

Function VCycle@((coarsest + 1) to finest) ( ) : Unit {
	repeat 3 times {
		Smoother@current ( )
	}
	UpResidual@current ( )
	Restriction@current ( )
	SetSolution@coarser ( 0 )
	repeat 1 times {
		VCycle@coarser ( )
	}
	Correction@current ( )
	repeat 3 times {
		Smoother@current ( )
	}
}

Function Smoother@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Solution[active]@current
	loop over fragments {
	loop over Solution@current {
		Solution[nextSlot]@current = Solution[active]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 0.8 ) * ( RHS@current - Laplace@current * Solution[active]@current ) )
	}
	advance Solution@current
	}
}

Function UpResidual@all (  ) : Unit {
	communicate  Solution[active]@current
	loop over fragments {
	loop over Residual@current {
		Residual@current = RHS@current - (Laplace@current * Solution[active]@current)
	}
	}
}
Function NormResidual_0@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over fragments with reduction( + : res ) {
	loop over Residual@current where x > 0 && y > 0 with reduction( + : res ) {
		res += Residual@current * Residual@current
	}
	}
	return sqrt ( res )
}

Function Restriction@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Residual@current
	loop over fragments {
	loop over RHS@coarser {
		RHS@coarser = RestrictionStencil@current * Residual@current
	}
	}
}
Function Correction@((coarsest + 1) to finest) ( ) : Unit {
	loop over fragments {
	loop over Solution@current {
		Solution[active]@current += CorrectionStencil@current * Solution[active]@coarser
	}
	}
}

Function SetSolution@all (value : Real) : Unit {
	loop over Solution@current {
		Solution[active]@current = value
	}
}
Function InitSolution ( ) : Unit {
	loop over Solution@finest sequentially {
		Solution[active]@finest = native('((double)std::rand()/RAND_MAX)')
	}
}
Function InitRHS ( ) : Unit {
	loop over RHS@finest {
		RHS@finest = 0.0
	}
}

Function Solve ( ) : Unit {
	UpResidual@finest ( )
	Variable resStart_0 : Real = NormResidual_0@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( '"Starting residual at 0"', resStart_0 )
	Variable totalTime : Real = 0
	Variable timeToSolve : Real = 0
	startTimer ( timeToSolveWatch )
	Variable numIt : Integer = 0
	repeat until res_0 < ( 1.0e-10 * resStart_0 ) {
		numIt += 1
		startTimer ( stopWatch )
		VCycle@finest (  )
		UpResidual@finest ( )
		stopTimer ( stopWatch, totalTime )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		print ( '"Residual at 0:"', res_0, '"Residual reduction:"', ( resStart_0 / res_0 ), '"Convergence factor:"', ( res_0 / resOld_0 ) )
	}
	stopTimer ( timeToSolveWatch, timeToSolve )
	print ( '"Total time to solve in"', numIt, '"steps :"', timeToSolve )
	print ( '"Mean time per vCycle: "', totalTime / numIt )
}

Function Application ( ) : Unit {
	Variable setupTime : Real = 0
	startTimer ( setupWatch )
	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )
	stopTimer ( setupWatch, setupTime )
	print ( '"Total time to setup: "', setupTime )
	InitRHS ( )
	InitSolution ( )
	apply bc to Solution[0]@0
	apply bc to Solution[1]@0
	apply bc to Solution[0]@1
	apply bc to Solution[1]@1
	apply bc to Solution[0]@2
	apply bc to Solution[1]@2
	apply bc to Solution[0]@3
	apply bc to Solution[1]@3
	apply bc to Solution[0]@4
	apply bc to Solution[1]@4
	apply bc to Solution[0]@5
	apply bc to Solution[1]@5
	apply bc to Solution[0]@6
	apply bc to Solution[1]@6
	apply bc to VecP@coarsest
	Solve ( )
	destroyGlobals ( )
}

