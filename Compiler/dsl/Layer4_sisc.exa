Domain global< [ 0, 0 ] to [ 1, 1 ] >

Layout NoComm< Real, Node >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 1, 1 ]
}
Layout CommPartTempBlockable< Real, Node >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 1, 1 ]
}
Layout BasicComm< Real, Node >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 1, 1 ] with communication
}
Layout CommFullTempBlockable< Real, Node >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 1, 1 ] with communication
}
Layout NoCommSF< Array[Real][5], Node >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 1, 1 ]
}

Field Solution< global, BasicComm, 0.0 >[2]@(coarsest to 0)
Field Solution< global, CommFullTempBlockable, 0.0 >[2]@(1 to (finest - 1))
Field Solution< global, CommFullTempBlockable, log ( 1.0 + xPos + yPos ) >[2]@finest
Field Residual< global, BasicComm, 0.0 >@all
Field RHS< global, NoComm, None >@(coarsest to 0)
Field RHS< global, CommPartTempBlockable, None >@(1 to finest)
Field VecP< global, BasicComm, 0.0 >@coarsest
Field VecGradP< global, NoComm, None >@coarsest

Field LaplaceCoeff< global, NoCommSF, None >@all
StencilField Laplace< LaplaceCoeff => LaplaceStencil >@all

Stencil LaplaceStencil@all {
	[ 0,  0] => ( 2.0 / ( hx@current * hx@current ) + 2.0 / ( hy@current * hy@current ) )
	[ 1,  0] => ( -1.0 / ( hx@current * hx@current ) )
	[-1,  0] => ( -1.0 / ( hx@current * hx@current ) )
	[ 0,  1] => ( -1.0 / ( hy@current * hy@current ) )
	[ 0, -1] => ( -1.0 / ( hy@current * hy@current ) )
}
Stencil CorrectionStencil@all {
	[    0,     0] => 0.25
	[x % 2,     0] => 0.25
	[    0, y % 2] => 0.25
	[x % 2, y % 2] => 0.25
}
Stencil RestrictionStencil@all {
	[ 0,  0] => ( 1.0 / 4.0 )
	[ 0, -1] => ( 1.0 / 8.0 )
	[ 0,  1] => ( 1.0 / 8.0 )
	[-1,  0] => ( 1.0 / 8.0 )
	[ 1,  0] => ( 1.0 / 8.0 )
	[-1, -1] => ( 1.0 / 16.0 )
	[-1,  1] => ( 1.0 / 16.0 )
	[ 1, -1] => ( 1.0 / 16.0 )
	[ 1,  1] => ( 1.0 / 16.0 )
}

Globals {
}

Function VCycle@coarsest ( ) : Unit {
	VCycle_0@current ( )
}
Function VCycle_0@coarsest ( ) : Unit {
	UpResidual@current ( )
	communicate  Residual@current
	Variable res : Real = NormResidual_0@current ( )
	Variable initialRes : Real = res
	loop over VecP@current {
		VecP@current = Residual@current
	}
	Variable cgSteps : Integer
	repeat 512 times count cgSteps {
	communicate  VecP@current
		loop over VecP@current {
			VecGradP@current = Laplace@current * VecP@current
		}
		Variable alphaDenom : Real = 0
		loop over VecP@current where x > 0 && y > 0 with reduction( + : alphaDenom ) {
			alphaDenom += VecP@current * VecGradP@current
		}
		Variable alpha : Real = res * res / alphaDenom
		loop over Solution@current {
			Solution[currentSlot]@current += alpha * VecP@current
			Residual@current -= alpha * VecGradP@current
		}
		Variable nextRes : Real = NormResidual_0@current ( )
		if ( nextRes <= 0.001 * initialRes ) {
			return
		}
		Variable beta : Real = (nextRes * nextRes) / (res * res)
		loop over VecP@current {
			VecP@current = Residual@current + beta * VecP@current
		}
		res = nextRes
	}
}

Function VCycle@((coarsest + 1) to finest) ( ) : Unit {
	repeat 3 times {
		Smoother@current ( )
	}
	UpResidual@current ( )
	Restriction@current ( )
	SetSolution@coarser ( 0 )
	repeat 1 times {
		VCycle@coarser ( )
	}
	Correction@current ( )
	repeat 3 times {
		Smoother@current ( )
	}
}

Function Smoother@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Solution[active]@current
	loop over fragments {
	loop over Solution@current {
		Solution[nextSlot]@current = Solution[active]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 0.8 ) * ( RHS@current - Laplace@current * Solution[active]@current ) )
	}
	advance Solution@current
	}
}

Function UpResidual@all (  ) : Unit {
	communicate  Solution[active]@current
	loop over fragments {
	loop over Residual@current {
		Residual@current = RHS@current - (Laplace@current * Solution[active]@current)
	}
	}
}
Function NormResidual_0@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over fragments with reduction( + : res ) {
	loop over Residual@current where x > 0 && y > 0 with reduction( + : res ) {
		res += Residual@current * Residual@current
	}
	}
	return sqrt ( res )
}

Function NormError_0@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over fragments with reduction( + : err ) {
	loop over Solution@current where x > 0 && y > 0 with reduction( + : err ) {
		Variable curErr : Real = Solution[active]@current - log ( 1.0 + xPos + yPos )
		err += curErr * curErr
	}
	}
	return ( sqrt ( err ) )
}

Function Restriction@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Residual@current
	loop over fragments {
	loop over RHS@coarser {
		RHS@coarser = RestrictionStencil@current * Residual@current
	}
	}
}
Function Correction@((coarsest + 1) to finest) ( ) : Unit {
	loop over fragments {
	loop over Solution@current {
		Solution[active]@current += CorrectionStencil@current * Solution[active]@coarser
	}
	}
}

Function SetSolution@all (value : Real) : Unit {
	loop over Solution@current {
		Solution[active]@current = value
	}
}
Function InitSolution ( ) : Unit {
	loop over Solution@finest {
		Solution[active]@finest = 0
	}
}
Function InitRHS ( ) : Unit {
	loop over RHS@finest {
		RHS@finest = 0.0
	}
}
Function InitLaplace@all ( ) : Unit {
	loop over LaplaceCoeff@current {
		Laplace@current:[ 0,  0] = ( ( 1.0 + xPos + 0.5 * hx@current + yPos + 1.0 + xPos - 0.5 * hx@current + yPos ) / ( hx@current * hx@current ) + ( 1.0 + xPos + yPos + 0.5 * hy@current + 1.0 + xPos + yPos - 0.5 * hy@current ) / ( hy@current * hy@current ) )
		Laplace@current:[ 1,  0] = ( -1.0 * ( 1.0 + xPos + 0.5 * hx@current + yPos ) / ( hx@current * hx@current ) )
		Laplace@current:[-1,  0] = ( -1.0 * ( 1.0 + xPos - 0.5 * hx@current + yPos ) / ( hx@current * hx@current ) )
		Laplace@current:[ 0,  1] = ( -1.0 * ( 1.0 + xPos + yPos + 0.5 * hy@current ) / ( hy@current * hy@current ) )
		Laplace@current:[ 0, -1] = ( -1.0 * ( 1.0 + xPos + yPos - 0.5 * hy@current ) / ( hy@current * hy@current ) )
	}
}

Function Solve ( ) : Unit {
	UpResidual@finest ( )
	Variable resStart_0 : Real = NormResidual_0@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( '"Starting residual at 0"', resStart_0 )
	Variable totalTime : Real = 0
	Variable timeToSolve : Real = 0
	startTimer ( timeToSolveWatch )
	Variable numIt : Integer = 0
	repeat until res_0 < ( 1.0e-10 * resStart_0 ) {
		numIt += 1
		startTimer ( stopWatch )
		VCycle@finest (  )
		UpResidual@finest ( )
		stopTimer ( stopWatch, totalTime )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		print ( '"Residual at 0:"', res_0, '"Residual reduction:"', ( resStart_0 / res_0 ), '"Convergence factor:"', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_0@finest ( )
		print ( '"Error at 0:"', curError_0 )
	}
	stopTimer ( timeToSolveWatch, timeToSolve )
	print ( '"Total time to solve in"', numIt, '"steps :"', timeToSolve )
	print ( '"Mean time per vCycle: "', totalTime / numIt )
}

Function Application ( ) : Unit {
	Variable setupTime : Real = 0
	startTimer ( setupWatch )
	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )
	stopTimer ( setupWatch, setupTime )
	print ( '"Total time to setup: "', setupTime )
	InitLaplace@6 ( )
	InitLaplace@5 ( )
	InitLaplace@4 ( )
	InitLaplace@3 ( )
	InitLaplace@2 ( )
	InitLaplace@1 ( )
	InitLaplace@0 ( )
	InitRHS ( )
	InitSolution ( )
	apply bc to Solution[0]@0
	apply bc to Solution[1]@0
	apply bc to Solution[0]@1
	apply bc to Solution[1]@1
	apply bc to Solution[0]@2
	apply bc to Solution[1]@2
	apply bc to Solution[0]@3
	apply bc to Solution[1]@3
	apply bc to Solution[0]@4
	apply bc to Solution[1]@4
	apply bc to Solution[0]@5
	apply bc to Solution[1]@5
	apply bc to Solution[0]@6
	apply bc to Solution[1]@6
	apply bc to VecP@coarsest
	Solve ( )
	destroyGlobals ( )
}

