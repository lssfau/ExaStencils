Domain global< [ 0, 0, 0 ] to [ 1, 1, 1 ] >

Layout FullTempBlockable< Real, Node >@all {
	ghostLayers = [ 5, 5, 5 ]
	duplicateLayers = [ 1, 1, 1 ]
}
Layout NoTempBlockable< Real, Node >@all {
	ghostLayers = [ 1, 1, 1 ]
	duplicateLayers = [ 1, 1, 1 ]
}
Layout PartTempBlockable< Real, Node >@all {
	ghostLayers = [ 4, 4, 4 ]
	duplicateLayers = [ 1, 1, 1 ]
}
Layout NoComm< Real, Node >@all {
	ghostLayers = [ 0, 0, 0 ]
	duplicateLayers = [ 1, 1, 1 ]
}
Layout PartTempBlockableSF< Array[Real][7], Node >@all {
	ghostLayers = [ 4, 4, 4 ]
	duplicateLayers = [ 1, 1, 1 ]
}

//Field SolutionT< global, FullTempBlockable, 0.0 >[2]@finest
//Field Solution< global, NoTempBlockable, 0.0 >[2]@finest
Field SolutionT< global, FullTempBlockable, ( 1.0 - exp ( -1.0 * kappa * ( (geometricCoordinate_x() - geometricCoordinate_x() ** 2) * (geometricCoordinate_y() - geometricCoordinate_y() ** 2) * (geometricCoordinate_z() - geometricCoordinate_z() ** 2) ) ) ) >[2]@finest
Field RHST< global, PartTempBlockable, None >@finest
//Field RHS< global, NoComm, None >@finest

Stencil Laplace@finest {
	[ 0,  0,  0] => 6.0
	[ 1,  0,  0] => -1.0
	[-1,  0,  0] => -1.0
	[ 0,  1,  0] => -1.0
	[ 0, -1,  0] => -1.0
	[ 0,  0,  1] => -1.0
	[ 0,  0, -1] => -1.0
}

//Field LaplaceCoeff< global, PartTempBlockableSF, None >@all
//StencilField Laplace< LaplaceCoeff => LaplaceStencil >@all
//
//Function getCoefficient ( x : Real, y : Real, z : Real ) : Real {
//	return exp ( kappa * ( (x - x ** 2) * (y - y ** 2) * (z - z ** 2) ) )
//}
//Stencil LaplaceStencil@all {
//	[ 0,  0,  0] => ( ( getCoefficient ( geometricCoordinate_x() + 0.5 * gridWidth_x@current(), geometricCoordinate_y(), geometricCoordinate_z() ) + getCoefficient ( geometricCoordinate_x() - 0.5 * gridWidth_x@current(), geometricCoordinate_y(), geometricCoordinate_z() ) ) / ( gridWidth_x@current() * gridWidth_x@current() ) + ( getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y() + 0.5 * gridWidth_y@current(), geometricCoordinate_z() ) + getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y() - 0.5 * gridWidth_y@current(), geometricCoordinate_z() ) ) / ( gridWidth_y@current() * gridWidth_y@current() ) + ( getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y(), geometricCoordinate_z() + 0.5 * gridWidth_z@current() ) + getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y(), geometricCoordinate_z() - 0.5 * gridWidth_z@current() ) ) / ( gridWidth_z@current() * gridWidth_z@current() ) )
//	[ 1,  0,  0] => ( -1.0 * getCoefficient ( geometricCoordinate_x() + 0.5 * gridWidth_x@current(), geometricCoordinate_y(), geometricCoordinate_z() ) / ( gridWidth_x@current() * gridWidth_x@current() ) )
//	[-1,  0,  0] => ( -1.0 * getCoefficient ( geometricCoordinate_x() - 0.5 * gridWidth_x@current(), geometricCoordinate_y(), geometricCoordinate_z() ) / ( gridWidth_x@current() * gridWidth_x@current() ) )
//	[ 0,  1,  0] => ( -1.0 * getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y() + 0.5 * gridWidth_y@current(), geometricCoordinate_z() ) / ( gridWidth_y@current() * gridWidth_y@current() ) )
//	[ 0, -1,  0] => ( -1.0 * getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y() - 0.5 * gridWidth_y@current(), geometricCoordinate_z() ) / ( gridWidth_y@current() * gridWidth_y@current() ) )
//	[ 0,  0,  1] => ( -1.0 * getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y(), geometricCoordinate_z() + 0.5 * gridWidth_z@current() ) / ( gridWidth_z@current() * gridWidth_z@current() ) )
//	[ 0,  0, -1] => ( -1.0 * getCoefficient ( geometricCoordinate_x(), geometricCoordinate_y(), geometricCoordinate_z() - 0.5 * gridWidth_z@current() ) / ( gridWidth_z@current() * gridWidth_z@current() ) )
//}

Globals {
}

Function SmootherT() : Unit {
	loop over fragments {
		repeat 2 times with contraction {
			loop over SolutionT@finest {
				SolutionT[nextSlot]@finest = SolutionT[active]@finest + (0.8 / diag(Laplace@finest) * (RHST@finest - Laplace@finest * SolutionT[active]@finest))
			}
			advance SolutionT@finest
		}
	}
}
//Function Smoother() : Unit {
//	loop over fragments {
//		loop over Solution@finest {
//			Solution[nextSlot]@finest = Solution[active]@finest + (0.8 / diag(Laplace@finest) * (RHS@finest - Laplace@finest * Solution[active]@finest))
//		}
//		advance Solution@finest
//	}
//}

Function InitFields ( ) : Unit {
	loop over SolutionT@finest sequentially {
		SolutionT[active]@finest = native('((double)std::rand()/RAND_MAX)')
	}
//	loop over Solution@finest sequentially {
//		Solution[active]@finest = native('((double)std::rand()/RAND_MAX)')
//	}
	loop over RHST@finest sequentially {
		RHST@finest = 0
	}
//	loop over RHS@finest sequentially {
//		RHS@finest = 0
//	}
}

Function LUPs() : Real {
	Variable dimSize : Integer = 511
	return(dimSize * dimSize * dimSize)
}

Function BenchmarkT() : Unit {
	print('"Cache warmup"')
	repeat 1 times {
		SmootherT()
	}
	print('"Starting benchmark (temporal blocking)"')
	startTimer(benchTTimer)
	repeat 6 times {
		SmootherT()
	}
	stopTimer(benchTTimer)
	Variable time : Real = getTotalFromTimer(benchTTimer)
	print('"Runtime: "', time)
	print('"MLUPs: "', (LUPs() * 12) / time / 1e3)
}

//Function Benchmark() : Unit {
//	print('"Cache warmup"')
//	repeat 1 times {
//		Smoother()
//	}
//	print('"Starting benchmark (normal)"')
//	startTimer(benchTimer)
//	repeat 10 times {
//		Smoother()
//	}
//	stopTimer(benchTimer)
//	Variable time : Real = getTotalFromTimer(benchTimer)
//	print('"Runtime: "', time)
//	print('"MLUPs: "', (LUPs() * 10) / time / 1e3)
//}

Function Application() : Unit {
	startTimer(setupWatch)
	initGlobals()
	initDomain()
	InitFields()
	stopTimer(setupWatch)
	print('"Total time to setup: "', getTotalFromTimer(setupWatch))
//	Benchmark()
	BenchmarkT()
	destroyGlobals()
}
