
// Discrete Poisson's Equation
Function poisson_stencil() : Unit
{
  S := [
    [[ 0, -1], -1.0],
    [[-1,  0], -1.0],
    [[ 0,  0],  4.0],
    [[ 1,  0], -1.0]
  ]
  
  list_append(S, [[ 0,  1], -1.0])
  
  return(S)
}

myL := poisson_stencil()


// Full weighting
myR := [
  [[-1, -1], 0.0625],
  [[ 0, -1], 0.125],
  [[ 1, -1], 0.0625],
  
  [[-1,  0], 0.125],
  [[ 0,  0], 0.25],
  [[ 1,  0], 0.125],
  
  [[-1,  1], 0.0625],
  [[ 0,  1], 0.125],
  [[ 1,  1], 0.0625]
]

myF := field(0)
myU := field(0)
myWork := field(0)
myDest := field(0)

Function jacobi(dest : Field, L : Stencil, f : Field, u : Field, omega : Real, work : Field) : Unit
{
    D_inv := diag_inv(L)
    
    //dest = u + omega * D_inv * (f - L*u)
    apply(work, L, u)
    work = f - work
    apply(dest, D_inv, work)
    dest = u + omega * dest
}

Function restrict(u_c : Field, R : Stencil, u : Field, work : Field) : Unit
{
    apply(work, R, u)
    //inject(aux, u_c)
}

Function smoother(L : Stencil, f : Field, u : Field) : Unit
{
    jacobi(L, f, u, dest)
    u = dest
}

Instantiate Function jacobi with (myDest, myL, myF, myU, myWork) as smoother @(1 to finest)
Instantiate Function restrict with (myF, myR, myU, myWork) as restrict @(1 to finest)