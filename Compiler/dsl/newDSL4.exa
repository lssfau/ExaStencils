Domain global< [-1, -1, -1] to [1, 1, 1] >

// FIXME: ghostlayers, padding, etc have to be left/right and have to be indices instead of ints
Field Solution< [1, 1, 1], Real >@all ( ghostlayers = 1, slots = 1, bcDir = true )
Field Solution2< [1, 1, 1], Real >@((coarsest + 1) to finest) ( ghostlayers = 1, slots = 1, bcDir = true )
Field Residual< [1, 1, 1], Real >@all ( ghostlayers = 1 )
Field RHS< [0, 0, 0], Real >@all ( communicates = false )
Field VecP< [1, 1, 1], Real >@coarsest ( ghostlayers = 1 )
Field VecGradP< [0, 0, 0], Real >@coarsest ( communicates = false )

Stencil Lapl@all {
	[ 0,  0,  0] => 6
	[ 1,  0,  0] => -1
	[-1,  0,  0] => -1
	[ 0,  1,  0] => -1
	[ 0, -1,  0] => -1
	[ 0,  0,  1] => -1
	[ 0,  0, -1] => -1
}

Stencil CorrectionStencil@all {
	[    0,     0,     0] => 0.0625
	[x % 2,     0,     0] => 0.0625
	[    0, y % 2,     0] => 0.0625
	[x % 2, y % 2,     0] => 0.0625
	[    0,     0, z % 2] => 0.0625
	[x % 2,     0, z % 2] => 0.0625
	[    0, y % 2, z % 2] => 0.0625
	[x % 2, y % 2, z % 2] => 0.0625
}

Stencil RestrictionStencil@all {
	[ 0,  0,  0] => 1.0

	[ 0,  0, -1] => 0.5
	[ 0,  0,  1] => 0.5
	[ 0, -1,  0] => 0.5
	[ 0,  1,  0] => 0.5
	[-1,  0,  0] => 0.5
	[ 1,  0,  0] => 0.5

	[ 0, -1,  1] => 0.25
	[ 0, -1, -1] => 0.25
	[ 0,  1,  1] => 0.25
	[ 0,  1, -1] => 0.25
	[-1,  0,  1] => 0.25
	[-1,  0, -1] => 0.25
	[ 1,  0,  1] => 0.25
	[ 1,  0, -1] => 0.25
	[-1, -1,  0] => 0.25
	[-1,  1,  0] => 0.25
	[ 1, -1,  0] => 0.25
	[ 1,  1,  0] => 0.25

	[-1, -1,  1] => 0.125
	[-1, -1, -1] => 0.125
	[-1,  1,  1] => 0.125
	[-1,  1, -1] => 0.125
	[ 1, -1,  1] => 0.125
	[ 1, -1, -1] => 0.125
	[ 1,  1,  1] => 0.125
	[ 1,  1, -1] => 0.125
}

Set inner [1, 1, 1] - [1, 1, 1] steps [1, 1, 1]
Set innerForFieldsWithoutGhostLayers [0, 0, 0] - [0, 0, 0] steps [1, 1, 1] // this concept might need some improvement
Set domain [0, 0, 0] - [0, 0, 0] steps [1, 1, 1]

def VCycle@coarsest ( ) : Unit {
	UpResidual@(current) ( )
	communicate Residual@(current)

	var res : Real = L2Residual@(current) ( )
	var initialRes : Real = res

	loop over inner on VecP@(current) {
		VecP@(current) = Residual@(current)
	}

	repeat up 512 {
		communicate VecP@(current)

		loop over inner on VecP@(current) {
			VecGradP@(current) = Lapl@(current) * VecP@(current)
		}

		var alphaDenom : Real = 0
		loop over inner on VecP@(current) with reduction( + : alphaDenom ) {
			alphaDenom += VecP@(current) * VecGradP@(current)
		}

		var alpha : Real = res * res / alphaDenom

		loop over inner on Solution@(current) {
			Solution@(current) += alpha * VecP@(current)
			Residual@(current) -= alpha * VecGradP@(current)
		}

		var nextRes : Real = L2Residual@(current) ( )

		if ( nextRes <= 0.001 * initialRes ) {
			return ( )
		}

		var beta : Real = (nextRes * nextRes) / (res * res)

		loop over inner on VecP@(current) {
			VecP@(current) = Residual@(current) + beta * VecP@(current)
		}

		res = nextRes
	}
}

def VCycle@((coarsest + 1) to finest) ( ) : Unit {
	repeat up 2 {
		Jacobi@(current) ( )
	}
	UpResidual@(current) ( )
	Restrict@(current) ( )
	set@(coarser) ( 0 )
	VCycle@(coarser) ( )
	interpolatecorr@(current) ( )
	repeat up 1 {
		Jacobi@(current) ( )
	}
}

def Jacobi@((coarsest + 1) to finest) ( ) : Unit {
	communicate Solution@(current)
	loop over inner on Solution@(current) {
		Solution2@(current) = Solution@(current) + ( ( ( 1.0 / diag ( Lapl@(current) ) ) * 0.8 ) * ( RHS@(current) - Lapl@(current) * Solution@(current) ) )
	}
	communicate Solution2@(current)
	loop over inner on Solution@(current) {
		Solution@(current) = Solution2@(current) + ( ( ( 1.0 / diag ( Lapl@(current) ) ) * 0.8 ) * ( RHS@(current) - Lapl@(current) * Solution2@(current) ) )
	}
}

def GaussSeidel@((coarsest + 1) to finest) ( ) : Unit {
	communicate Solution@(current)
	loop over inner on Solution@(current) {
		Solution@(current) = Solution@(current) + ( ( ( 1.0 / diag ( Lapl@(current) ) ) * 1.0 ) * ( RHS@(current) - Lapl@(current) * Solution@(current) ) )
	}
}

def UpResidual@all ( ) : Unit {
	communicate Solution@(current)
	loop over inner on Residual@(current) {
		Residual@(current) = RHS@(current) - (Lapl@(current) * Solution@(current))
	}
}

def Restrict @((coarsest + 1) to finest) ( ) : Unit { 
	communicate Residual@(current)
	loop over innerForFieldsWithoutGhostLayers on RHS@(coarser) {
		RHS@(coarser) = ToCoarser ( RestrictionStencil@(current) * Residual@(current) )
    }
}

def interpolatecorr@((coarsest + 1) to finest) ( ) : Unit { 
	communicate Solution@(current)
	loop over inner on Solution@(current) {
		Solution@(current) += ToFiner ( CorrectionStencil@(current) * Solution@(coarser) )
	}
}

def set@all (value : Real) : Unit {
	loop over domain on Solution@(current) {
		Solution@(current) = value
	}
}

def L2Residual@(coarsest and finest) ( ) : Real {
	communicate Residual@(current)
	var res : Real = 0
	loop over inner on Residual@(current) with reduction( + : res ) {
		// FIXME: this counts duplicated values multiple times
		res += Residual@(current) * Residual@(current)
	}
	return ( sqrt ( res ) )
}

def Application ( ) : Unit {
	UpResidual@finest ( )
	var res0 : Real = L2Residual@finest (  )
	var res : Real = res0
	var resold : Real = 0
	print ( '"startingres"', res0 )
	var totalTime : Real = 0
	repeat up 10 {
		resold = res
		startTimer ( stopWatch )
		VCycle@finest (  )
		UpResidual@finest ( )
		stopTimer ( stopWatch, totalTime )
		res = L2Residual@finest (  )
		print ( '"Residual:"', res, '"Residual reduction:"', ( res0 / res ), '"Convergence factor:"', ( res / resold ) )
	}
	print ( '"Mean time per vCycle: "', totalTime / 10 )
}