def cpu VCycle ( lev:Int  ) : Unit 
{ 
 if coarsestlevel { 
repeat up ncoarse 
  GaussSeidel ( lev) 
  next  
} else 
{ 
  repeat up nprae 
  GaussSeidel( lev) 
  next  
  Residual ( lev ) 
  Restrict ( ( lev+1 ) 
             f[ ( lev+1 ) ] 
             Res[lev]) 
  set( ( lev+1 ) 
      solution[ ( lev + 1 ) ] 
       0) 
  VCycle ( lev+1 ) 
  interpolatecorr( lev 
                    solution[lev] 
                    solution[ (lev+1) ] ) 
    repeat up npost 
    GaussSeidel ( lev ) 
  next  
} 
} 

def cpu Residual ( lev:Int ) : Unit  
{ 
loop innerpoints level lev order lex block 1 1  
  Res = f [ lev ] - (Lapl [ lev ] * solution [ lev ] )  
next 
}  

def cpu L2Residual ( lev:Int ) : Double 
{ 
    Reduction loop innerpoints level lev order lex block 1 1 
        s += (f [ lev ]  - Lapl [ lev ] * solution [ lev ]) * (f [ lev ]  - Lapl [ lev ] * solution [ lev ]) 
    next  
}  
def cpu GaussSeidel ( lev:Int ) : Unit  
{ 
    loop innerpoints level lev order rb block 1 1 
      solution = solution [ lev ] + ( ( ( inverse( diag(Lapl [ lev ] ) ) ) * omega ) * ( f [ lev ] - Lapl [ lev ] * solution [ lev ] ) ) 
    next  
}  

def cpu Restrict ( lev:Int 
               coarse:Array 
               fine:Array) : Unit  
{ 
    loop innerpoints level coarse order lex block 1 1  
      coarse =  RestrictionStencil * fine | ToCoarse  
    next  
}  

def cpu interpolatecorr( lev:Int 
                     uf:Array  
                     uc:Array ) : Unit 
{ 
    loop innerpoints level uf order lex block 1 1  
    uf += RestrictionStencil * uc | ToFine  
    next  
}  

def cpu set ( lev:Int 
          arr:Array  
          value:Int) : Unit  
{ 
  loop allpoints level arr order lex block 1 1  
      arr = value    
next  
}  

def cpu setrandom(arr:Array  
               v:Int) : Unit 
{ 
  loop innerpoints level arr order lex block 1 1  
      arr = random(v)    
  next  
} 

def cpu Application ( ) : Unit 
{  
 decl res0 : Double = L2Residual ( 0 ) 
 decl res : Double = res0 
 decl resold : Double = 0 
 print ( 'startingres' res0 ) 
 repeat up 10 
 resold = res 
VCycle ( 0 ) 
res = L2Residual ( 0 ) 
print ( 'Residual:' res 'residual reduction:' (res0/res) 'convergence factor:' (res/resold) ) 
  next  
}  
