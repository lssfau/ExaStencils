// FIXME: ghostlayers, padding, etc have to be left/right and have to be indices instead of ints
Field Solution< [1, 1, 1], Real >@(0 to 4) ( ghostlayers = 1, slots = 1, bcDir = true )
Field Residual< [1, 1, 1], Real >@(0 to 4) ( ghostlayers = 1 )
Field RHS< [0, 0, 0], Real >@(0 to 4)
Field VecP< [1, 1, 1], Real >@0 ( ghostlayers = 1 )
Field VecGradP< [0, 0, 0], Real >@0

Stencil Lapl@(0 to 4) {
	[ 0,  0,  0] => 6
	[ 1,  0,  0] => -1
	[-1,  0,  0] => -1
	[ 0,  1,  0] => -1
	[ 0, -1,  0] => -1
	[ 0,  0,  1] => -1
	[ 0,  0, -1] => -1
}

Stencil CorrectionStencil@(0 to 4) {
	[    0,     0,     0] => 0.0625
	[x % 2,     0,     0] => 0.0625
	[    0, y % 2,     0] => 0.0625
	[x % 2, y % 2,     0] => 0.0625
	[    0,     0, z % 2] => 0.0625
	[x % 2,     0, z % 2] => 0.0625
	[    0, y % 2, z % 2] => 0.0625
	[x % 2, y % 2, z % 2] => 0.0625
}

Stencil RestrictionStencil@(0 to 4) {
	[ 0,  0,  0] => 1.0

	[ 0,  0, -1] => 0.5
	[ 0,  0,  1] => 0.5
	[ 0, -1,  0] => 0.5
	[ 0,  1,  0] => 0.5
	[-1,  0,  0] => 0.5
	[ 1,  0,  0] => 0.5

	[ 0, -1,  1] => 0.25
	[ 0, -1, -1] => 0.25
	[ 0,  1,  1] => 0.25
	[ 0,  1, -1] => 0.25
	[-1,  0,  1] => 0.25
	[-1,  0, -1] => 0.25
	[ 1,  0,  1] => 0.25
	[ 1,  0, -1] => 0.25
	[-1, -1,  0] => 0.25
	[-1,  1,  0] => 0.25
	[ 1, -1,  0] => 0.25
	[ 1,  1,  0] => 0.25

	[-1, -1,  1] => 0.125
	[-1, -1, -1] => 0.125
	[-1,  1,  1] => 0.125
	[-1,  1, -1] => 0.125
	[ 1, -1,  1] => 0.125
	[ 1, -1, -1] => 0.125
	[ 1,  1,  1] => 0.125
	[ 1,  1, -1] => 0.125
}

Set inner [1, 1, 1] - [1, 1, 1] steps [1, 1, 1]
Set innerForFieldsWithoutGhostLayers [0, 0, 0] - [0, 0, 0] steps [1, 1, 1] // this concept might need some improvement
Set domain [0, 0, 0] - [0, 0, 0] steps [1, 1, 1]

def VCycle@0 ( ) : Unit {
	UpResidual@(current) ( )
	exchresidualData@(current) ( 0 )

	var res : Real = L2Residual@(current) ( )
	var initialRes : Real = res

	loop over inner on VecP@(current) {
		VecP@(current) = Residual@(current)
	}

	repeat up 512 {
		exchvecpData@(current) ( 0 )

		loop over inner on VecP@(current) {
			VecGradP@(current) = Lapl@(current) * VecP@(current)
		}

		var alphaDenom : Real = 0
		loop over inner on VecP@(current) with reduction( + : alphaDenom ) {
			alphaDenom += VecP@(current) * VecGradP@(current)
		}

		var alpha : Real = res * res / alphaDenom

		loop over inner on Solution@(current) {
			Solution@(current) += alpha * VecP@(current)
			Residual@(current) -= alpha * VecGradP@(current)
		}

		var nextRes : Real = L2Residual@(current) ( )

		if ( nextRes <= 0.001 * initialRes ) {
			return ( )
		}

		var beta : Real = (nextRes * nextRes) / (res * res)

		loop over inner on VecP@(current) {
			VecP@(current) = Residual@(current) + beta * VecP@(current)
		}

		res = nextRes
	}
}

def VCycle@(1 to 4) ( ) : Unit {
	repeat up 3 {
		GaussSeidel@(current) ( )
	}
	UpResidual@(current) ( )
	Restrict@(current) ( )
	set@(coarser) ( 0 )
	VCycle@(coarser) ( )
	interpolatecorr@(current) ( )
	repeat up 3 {
		GaussSeidel@(current) ( )
	}
}

def GaussSeidel@(1 to 4) ( ) : Unit { 
	exchsolutionData@(current) ( 0 )
	loop over inner on Solution@(current) {
		Solution@(current) = Solution@(current) + ( ( ( 1.0 / diag ( Lapl@(current) ) ) * 1.0 ) * ( RHS@(current) - Lapl@(current) * Solution@(current) ) )
	}
}

def UpResidual@(0 to 4) ( ) : Unit {
	exchsolutionData@(current) ( 0 )
	loop over inner on Residual@(current) {
		Residual@(current) = RHS@(current) - (Lapl@(current) * Solution@(current))
	}
}

def Restrict @(1 to 4) ( ) : Unit { 
	exchresidualData@(current) ( 0 )
	loop over innerForFieldsWithoutGhostLayers on RHS@(coarser) {
		RHS@(coarser) = ToCoarser ( RestrictionStencil@(current) * Residual@(current) )
    }
}

def interpolatecorr@(1 to 4) ( ) : Unit { 
	exchsolutionData@(current) ( 0 )  
	loop over inner on Solution@(current) {
		Solution@(current) += ToFiner ( CorrectionStencil@(current) * Solution@(coarser) )
	}
}

def set@(0 to 4) (value : Real) : Unit {
	loop over domain on Solution@(current) {
		Solution@(current) = value
	}
}

def L2Residual@(0, 4) ( ) : Real {
	exchresidualData@(current) ( 0 )
	var res : Real = 0
	loop over inner on Residual@(current) with reduction( + : res ) {
		// FIXME: this counts duplicated values multiple times
		res += Residual@(current) * Residual@(current)
	}
	return ( sqrt ( res ) )
}

def Application ( ) : Unit {
	UpResidual@4 ( )
	var res0 : Real = L2Residual@4 (  )
	var res : Real = res0
	var resold : Real = 0
	print ( '"startingres"', res0 )
	repeat up 10 {
		resold = res
		VCycle@4 (  )
		UpResidual@4 ( )
		res = L2Residual@4 (  )
		print ( '"Residual:"', res, '"Residual reduction:"', ( res0 / res ), '"Convergence factor:"', ( res / resold ) )
	}
}