// layer 4 code

Domain global< [ 0, 0, 0 ] to [ 0.05, 0.05, 0.05 ] >

Layout DefCellLayout < Real , Cell > @all {
	duplicateLayers	= [ 0, 0, 0 ]
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceXLayout < Real , Face_x > @all {
	duplicateLayers	= [ 1, 0, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceYLayout < Real , Face_y > @all {
	duplicateLayers	= [ 0, 1, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceZLayout < Real , Face_z > @all {
	duplicateLayers	= [ 0, 0, 1 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Field rho < global, DefCellLayout, Neumann >[2] @finest
Field p < global, DefCellLayout, Neumann > @finest

// auxilary fields

Field vis < global, DefCellLayout, Neumann > @finest
Field miu < global, DefCellLayout, Neumann > @finest

Field gamma < global, DefCellLayout, Neumann > @finest

// temporary flow fields
// TODO: remove after removing offset hack in setup coefficient routines - also remove layouts
Field floweu < global, DefFaceXLayout, None > @finest
Field flownu < global, DefFaceXLayout, None > @finest
Field flowtu < global, DefFaceXLayout, None > @finest

Field flowev < global, DefFaceYLayout, None > @finest
Field flownv < global, DefFaceYLayout, None > @finest
Field flowtv < global, DefFaceYLayout, None > @finest

Field flowew < global, DefFaceZLayout, None > @finest
Field flownw < global, DefFaceZLayout, None > @finest
Field flowtw < global, DefFaceZLayout, None > @finest

Field flowet < global, DefCellLayout, None > @finest
Field flownt < global, DefCellLayout, None > @finest
Field flowtt < global, DefCellLayout, None > @finest

Globals {
	// global states
	Var curTime : Real          = 0.0

	Var totalInitRes : Real     = 0.0
	Var lastTotalInitRes : Real = 0.0

	Var converged_u : Boolean	= false
	Var converged_v : Boolean	= false
	Var converged_w : Boolean	= false
	Var converged_pc : Boolean	= false
	Var converged_t : Boolean	= false

	// printing
	Var nextPrintTime : Real	= maxTime + dt // don't print
	Val printInterval : Real	= 100// * dt

	// solver constants
	Val dt : Real 		        = 0.5
	Val maxTime : Real          = 10.0

	Var relax_1 : Real          = 0.5
	Var relax_2 : Real          = 0.5
	Var relax_3 : Real          = 0.5
	Var relax_4 : Real          = 0.5
	Var relax_7 : Real          = 0.5

	// exit criteria
	Var targetResPerComp : Real		= 1.0e-6
	Var stagnationThreshold : Real	= 1.0e-2
	Val maxSimpleIterations : Int	= 1000000

	// density constants
	Val rhoref : Real           = 0.0
	Val rhocon : Real           = 999.7 // overwritten by updateProperties
	Val visl : Real             = 1.0e-5 // overwritten by updateProperties

	// temperature constants
	Val th : Real               = 283.15
	Val tc : Real               = 273.15
	Val t_ph : Real             = 273.15
	Val temp_ref : Real         = 270.592
	Val delta_temp : Real       = 0.2

	// temperatures solidus & liquidus
	Val t_sol : Real            = t_ph + delta_temp
	Val t_liq : Real            = t_ph - delta_temp

	// phase change enthalpy
	Val hls : Real              = 3.35e5

	// phase properties
	Val miu_liq : Real          = 0.001197941294207
	Val cp_liq : Real           = 4202.1178518932
	Val rho_liq : Real          = 1000.12926014462
	Val cond_liq : Real         = 0.7207161
	Val rho_sol : Real          = 1000.10152281425
	Val cp_sol : Real           = 4202.85969356982
	Val cond_sol : Real         = 0.7204897

	// density contants Gangi et al. (Kohlrausch)
	Val a_den : Real            = 999.840281
	Val b_den : Real            = 0.0673268
	Val c_den : Real            = -0.00894484
	Val d_den : Real            = 8.7846287e-5
	Val e_den : Real            = -6.6213979e-7

	// non-Newtonian parameters
	Val useNonNewtonian : Bool	= false
	Val n_index : Real			= 0.6 // 0.95
}

/// specialized boundary handling functions
Function applyBC_t@finest ( ) : Unit {
	loop over phi7@current only ghost [-1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * th - phi7[active]@current@[ 1,  0,  0]
	}
	loop over phi7@current only ghost [ 1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * tc - phi7[active]@current@[-1,  0,  0]
	}
	loop over phi7@current only ghost [ 0, -1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  1,  0]
	}
	loop over phi7@current only ghost [ 0,  1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0, -1,  0]
	}
	loop over phi7@current only ghost [ 0,  0, -1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0,  1]
	}
	loop over phi7@current only ghost [ 0,  0,  1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0, -1]
	}
}
Function applyBC_t@(coarsest to (finest - 1)) ( ) : Unit {
	loop over phi7@current only ghost [-1,  0,  0] on boundary {
		phi7[active]@current = 0.0 - phi7[active]@current@[ 1,  0,  0]
	}
	loop over phi7@current only ghost [ 1,  0,  0] on boundary {
		phi7[active]@current = 0.0 - phi7[active]@current@[-1,  0,  0]
	}
	loop over phi7@current only ghost [ 0, -1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  1,  0]
	}
	loop over phi7@current only ghost [ 0,  1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0, -1,  0]
	}
	loop over phi7@current only ghost [ 0,  0, -1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0,  1]
	}
	loop over phi7@current only ghost [ 0,  0,  1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0, -1]
	}
}

Function applyBC_res_t@all ( ) : Unit {
	loop over residual_t@current only ghost [-1,  0,  0] on boundary {
		residual_t@current = 0.0 - residual_t@current@[ 1,  0,  0]
	}
	loop over residual_t@current only ghost [ 1,  0,  0] on boundary {
		residual_t@current = 0.0 - residual_t@current@[-1,  0,  0]
	}
	loop over residual_t@current only ghost [ 0, -1,  0] on boundary {
		residual_t@current = residual_t@current@[ 0,  1,  0]
	}
	loop over residual_t@current only ghost [ 0,  1,  0] on boundary {
		residual_t@current = residual_t@current@[ 0, -1,  0]
	}
	loop over residual_t@current only ghost [ 0,  0, -1] on boundary {
		residual_t@current = residual_t@current@[ 0,  0,  1]
	}
	loop over residual_t@current only ghost [ 0,  0,  1] on boundary {
		residual_t@current = residual_t@current@[ 0,  0, -1]
	}
}

/// main functions

Function Application ( ) : Unit {
	startTimer ( 'setup' )

	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )

	initGeometry ( )
	InitFields@finest ( )

	stopTimer ( 'setup' )

	TimeLoop ( )

	//printAllTimers ( )
	destroyGlobals ( )
}

Function TimeLoop ( ) : Unit {
	repeat until curTime >= maxTime {
		startTimer ( 'timeStep' )

		if ( 0.0 == curTime ) {
			// initialize 'negative' timestep
			if ( useNonNewtonian ) {
				UpdatePropertiesNN@finest ( )
			} else {
				UpdateProperties@finest ( )
			}
		}

		AdvanceFields@finest ( )

		Solve@finest ( )
		curTime += dt

		stopTimer ( 'timeStep' )
	}
}

Function Solve@finest ( ) : Unit {
	Var converged : Bool = false
	Var curIt : Int      = 0

	converged_u = false
	converged_v = false
	converged_w = false
	converged_pc = false
	converged_t = false

	repeat until converged || curIt >= maxSimpleIterations {
		startTimer ( 'solve' )

		lastTotalInitRes = totalInitRes
		totalInitRes = 0.0

		startTimer ( 'UpdateProperties' )
		if ( useNonNewtonian ) {
			UpdatePropertiesNN@current ( )
		} else {
			UpdateProperties@current ( )
		}
		stopTimer ( 'UpdateProperties' )

		/// velocity step
		startTimer ( 'UpdateVelocities' )

		// setup stencils and rhs's, and solve resulting systems
		startTimer ( 'CompileStencil_u' )
		CompileStencil_u@current ( )
		stopTimer ( 'CompileStencil_u' )

		startTimer ( 'Solve_u' )
		Solve_u@current ( )
		stopTimer ( 'Solve_u' )

		startTimer ( 'CompileStencil_v' )
		CompileStencil_v@current ( )
		stopTimer ( 'CompileStencil_v' )

		startTimer ( 'Solve_v' )
		Solve_v@current ( )
		stopTimer ( 'Solve_v' )

		startTimer ( 'CompileStencil_w' )
		CompileStencil_w@current ( )
		stopTimer ( 'CompileStencil_w' )

		startTimer ( 'Solve_w' )
		Solve_w@current ( )
		stopTimer ( 'Solve_w' )

		stopTimer ( 'UpdateVelocities' )

		/// pressure correction step
		startTimer ( 'PressureCorrection' )

		// reset field
		loop over pc@current starting [-1, -1, -1] ending [-1, -1, -1] {
			pc[active]@current = 0.0
		}

		// setup stencil and rhs, and solve resulting system
		startTimer ( 'CompileStencil_pc' )
		CompileStencil_pc@current ( )
		stopTimer ( 'CompileStencil_pc' )

		startTimer ( 'Solve_pc' )
		Solve_pc@current ( )
		stopTimer ( 'Solve_pc' )

		// perform actual pressure correction
		loop over p@current {
			p@current += relax_4 * pc@current
		}
		communicate p@current
		apply bc to p@current

		loop over u@current {
			u[active]@current += du@current * ( pc@current@[-1, 0, 0] - pc@current )
		}
		communicate u[active]@current
		apply bc to u[active]@current

		loop over v@current {
			v[active]@current += dv@current * ( pc@current@[0, -1, 0] - pc@current )
		}
		communicate v[active]@current
		apply bc to v[active]@current

		loop over w@current {
			w[active]@current += dw@current * ( pc@current@[0, 0, -1] - pc@current )
		}
		communicate w[active]@current
		apply bc to w[active]@current

		stopTimer ( 'PressureCorrection' )

		/// temperature step
		startTimer ( 'UpdateTemperature' )

		startTimer ( 'CompileStencil_t' )
		CompileStencil_t@current ( )
		stopTimer ( 'CompileStencil_t' )

		startTimer ( 'Solve_t' )
		Solve_t@current ( )
		stopTimer ( 'Solve_t' )

		stopTimer ( 'UpdateTemperature' )

		// check convergence
		startTimer ( 'convergenceCheck' )

		if ( converged_u && converged_v && converged_w && converged_pc && converged_t ) {
			converged = true
		}

		if ( !converged && 0 == curIt % 100 && curIt > 0 ) {
			Val res_u : Real = NormResidual_u@current ( )
			Val res_v : Real = NormResidual_v@current ( )
			Val res_w : Real = NormResidual_w@current ( )
			Val res_pc : Real = NormResidual_pc@current ( )
			Val res_t : Real = NormResidual_t@current ( )

			//print ( curTime, curIt , res_u, res_v, res_w, res_pc, res_t)
			print ( curTime, curIt )
			printVal ( res_u )
			printVal ( res_v )
			printVal ( res_w )
			printVal ( res_pc )
			printVal ( res_t )
		}

		stopTimer ( 'convergenceCheck' )

		stopTimer ( 'solve' )

		curIt += 1
	}

	if ( curTime >= nextPrintTime ) {
		nextPrintTime += printInterval

		Var index : Integer = curTime / printInterval

		Var filename_rho : String
		buildString ( filename_rho, "rho_", index, ".csv" )
		Var filename_u : String
		buildString ( filename_u, "u_", index, ".csv" )
		Var filename_v : String
		buildString ( filename_v, "v_", index, ".csv" )
		Var filename_w : String
		buildString ( filename_w, "w_", index, ".csv" )
		Var filename_temp : String
		buildString ( filename_temp, "temp_", index, ".csv" )

		printField ( filename_rho, rho[active]@current, 2**( levels@current ( ) - 1 ) == z )
		printField ( filename_u, u[active]@current, 2**( levels@current ( ) - 1 ) == z )
		printField ( filename_v, v[active]@current, 2**( levels@current ( ) - 1 ) == z )
		printField ( filename_w, w[active]@current, 2**( levels@current ( ) - 1 ) == z )
		printField ( filename_temp, phi7[active]@current, 2**( levels@current ( ) - 1 ) == z )
	}

	// print some information about achieved residuals and required steps
	Val res_u : Real = NormResidual_u@current ( )
	Val res_v : Real = NormResidual_v@current ( )
	Val res_w : Real = NormResidual_w@current ( )
	Val res_pc : Real = NormResidual_pc@current ( )
	Val res_t : Real = NormResidual_t@current ( )

	//print ( curTime, curIt , res_u, res_v, res_w, res_pc, res_t)
	print ( curTime, curIt )
	printVal ( res_u )
	printVal ( res_v )
	printVal ( res_w )
	printVal ( res_pc )
	printVal ( res_t )
}

Function printVal ( toPrint : Real ) : Unit {
    if ( toPrint <= 1e-12 ) {
		print ( "EFFECTIVELY ZERO" )
    } else if ( toPrint <= 1e-11 ) {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(1)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    } else if ( toPrint <= 1e-10 ) {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(2)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    } else if ( toPrint <= 1e-9 ) {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(3)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    } else {
		native ( 'std::streamsize oldPrec = std::cout.precision()' )
		native ( 'std::cout.precision(4)' )
		print ( toPrint )
		native ( 'std::cout.precision(oldPrec)' )
    }
}

/// init functions

Function InitFields@finest ( ) : Unit {
	// fields that are not initialized with 0

	loop over rho@current {
		rho[active]@current = rhocon
		rho[previous]@current = rhocon
	}

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate rho[previous]@current
	apply bc to rho[previous]@current

	loop over vis@current {
		vis@current = visl
	}

	communicate vis@current
	apply bc to vis@current

	loop over phi7@current {
		phi7[active]@current = th
		phi7[previous]@current = th
	}

	communicate phi7[active]@current
	apply bc to phi7[active]@current

	communicate phi7[previous]@current
	apply bc to phi7[previous]@current
}

/// utility functions

Function calc_diflow ( flow : Real, diff : Real ) : Real {
	Var tmp : Real = ( diff - 0.1 * fabs ( flow ) ) / diff
	return max ( 0.0, diff * ( tmp ** 5 ) )
}

/// general functions

Function UpdateProperties@finest ( ) : Unit {
	// previously props and Gamsor_flu and Gamsor_phi

	loop over vis@current {
		// Gangi et al. (Kohlrausch) Density
		rho[active]@current = ( a_den + b_den * ( phi7[active]@current - t_ph )
			+ c_den * ( phi7[active]@current - t_ph )**2
			+ d_den * ( phi7[active]@current - t_ph )**3
			+ e_den * ( phi7[active]@current - t_ph )**4 )

		// Zografos et al. Specific heat, thermal conductivity and viscosity
		Var cp : Real = ( -3755.9 + 67.953 * phi7[active]@current
			- 0.19149 * phi7[active]@current**2
			+ 1.7850e-4 * phi7[active]@current**3 )
		Var cond : Real = ( -0.63262 + 7.1959e-3 * phi7[active]@current
			- 1.144e-5 * phi7[active]@current**2
			+ 4.2365e-9 * phi7[active]@current**3 )
		vis@current = 3.8208e-2 / ( phi7[active]@current - 252.33 )

		gamma@current = cond / cp
	}

	communicate vis@current
	apply bc to vis@current

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate gamma@current
	apply bc to gamma@current
}

Function UpdatePropertiesNN@finest ( ) : Unit {
	// previously props and non_new and Gamsor_flu and Gamsor_phi

	loop over miu@current {
		// Gangi et al. (Kohlrausch) Density
		rho[active]@current = ( a_den + b_den * ( phi7[active]@current - t_ph )
			+ c_den * ( phi7[active]@current - t_ph )**2
			+ d_den * ( phi7[active]@current - t_ph )**3
			+ e_den * ( phi7[active]@current - t_ph )**4 )

		// Zografos et al. Specific heat, thermal conductivity and viscosity
		Var cp : Real = ( -3755.9 + 67.953 * phi7[active]@current
			- 0.19149 * phi7[active]@current**2
			+ 1.7850e-4 * phi7[active]@current**3 )
		Var cond : Real = ( -0.63262 + 7.1959e-3 * phi7[active]@current
			- 1.144e-5 * phi7[active]@current**2
			+ 4.2365e-9 * phi7[active]@current**3 )
		miu@current = 3.8208e-2 / ( phi7[active]@current - 252.33 )

		gamma@current = cond / cp
	}

	communicate miu@current
	apply bc to miu@current

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate gamma@current
	apply bc to gamma@current

	loop over vis@current {
		// TODO: add evalAtCellCenter, evalAtXFaceCenter, evalAtXYCorner, etc
		// du/dx and dv/dx and dw/dx
		Val dudx : Real = ( evalAtEastFace ( u[active]@current ) - evalAtWestFace ( u[active]@current ) ) / vf_cellWidth_x@current

		Val dvdx : Real = 0.5 * ( evalAtEastFace ( v[active]@current ) - evalAtWestFace ( v[active]@current )
			+ evalAtEastFace ( v[active]@current@[0, 1, 0] ) - evalAtWestFace ( v[active]@current@[0, 1, 0] ) ) / vf_cellWidth_x@current

		Val dwdx : Real = 0.5 * ( evalAtEastFace ( w[active]@current ) - evalAtWestFace ( w[active]@current )
			+ evalAtEastFace ( w[active]@current@[0, 0, 1] ) - evalAtWestFace ( w[active]@current@[0, 0, 1] ) ) / vf_cellWidth_x@current

		// du/dy and dv/dy and dw/dy
		Val dudy : Real = 0.5 * ( evalAtNorthFace ( u[active]@current ) - evalAtSouthFace ( u[active]@current )
			+ evalAtNorthFace ( u[active]@current@[1, 0, 0] ) - evalAtSouthFace ( u[active]@current@[1, 0, 0] ) ) / vf_cellWidth_y@current

		Val dvdy : Real = ( evalAtNorthFace ( v[active]@current ) - evalAtSouthFace ( v[active]@current ) ) / vf_cellWidth_y@current

		Val dwdy : Real = 0.5 * ( evalAtNorthFace ( w[active]@current ) - evalAtSouthFace ( w[active]@current )
			+ evalAtNorthFace ( w[active]@current@[0, 0, 1] ) - evalAtSouthFace ( w[active]@current@[0, 0, 1] ) ) / vf_cellWidth_y@current

		// du/dz and dv/dz and dw/dz
		Val dudz : Real = 0.5 * ( evalAtTopFace ( u[active]@current ) - evalAtBottomFace ( u[active]@current )
			+ evalAtTopFace ( u[active]@current@[1, 0, 0] ) - evalAtBottomFace ( u[active]@current@[1, 0, 0] ) ) / vf_cellWidth_z@current

		Val dvdz : Real = 0.5 * ( evalAtTopFace ( v[active]@current ) - evalAtBottomFace ( v[active]@current )
			+ evalAtTopFace ( v[active]@current@[0, 1, 0] ) - evalAtBottomFace ( v[active]@current@[0, 1, 0] ) ) / vf_cellWidth_z@current

		Val dwdz : Real = ( evalAtTopFace ( w[active]@current ) - evalAtBottomFace ( w[active]@current ) ) / vf_cellWidth_z@current

		// compile values
		Val gamap : Real = 2.0 * ( dvdy**2 + dudx**2 + dwdz**2 ) + ( dvdx + dudy )**2 + ( dwdx + dudz )**2 + ( dvdz + dwdy )**2
		Var gama : Real = sqrt ( gamap )

		// j.non.newt.fluid mech. 15(1984)75-83
		//gama = max ( gama, 0.01 )
		//vis@current = rel + ( 1.0 - rel ) / ( 1.0 + sqrt ( lambda * gama ) )

		// Int. J. Heat & Mass Transfer 34(1991) 1083-1096 CMC/Power law
		gama = max ( gama, 0.01 )
		vis@current = miu@current * gama**( n_index - 1.0 )
	}

	communicate vis@current
	apply bc to vis@current
}

/// stencil compilation functions

Function CompileStencil_u@finest (  ) : Unit {
	loop over u@current starting [-1, -1, -1] {
		floweu@current = integrateOverXStaggeredEastFace ( u[active]@current * rho[active]@current )
		flownu@current = integrateOverXStaggeredNorthFace ( v[active]@current * rho[active]@current )
		flowtu@current = integrateOverXStaggeredTopFace ( w[active]@current * rho[active]@current )
	}

	loop over AuStencil@current starting [-1, -1, -1] {
		// FIXME: integrateLFace ( evalLFace (FA) )
		// TODO: check virtual field offsets

		Val diffeu : Real = integrateOverXStaggeredEastFace ( vis@current ) / vf_cellWidth_x@current
		AuStencil@current:[1, 0, 0] = -1.0 * ( calc_diflow ( floweu@current, diffeu ) + max ( 0.0, -1.0 * floweu@current ) )

		Val diffnu : Real = integrateOverXStaggeredNorthFace ( evalAtXStaggeredNorthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[0, 1, 0]
		AuStencil@current:[0, 1, 0] = -1.0 * ( calc_diflow ( flownu@current, diffnu ) + max ( 0.0, -1.0 * flownu@current ) )

		Val difftu : Real = integrateOverXStaggeredTopFace ( evalAtXStaggeredTopFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[0, 0, 1]
		AuStencil@current:[0, 0, 1] = -1.0 * ( calc_diflow ( flowtu@current, difftu ) + max ( 0.0, -1.0 * flowtu@current ) )
	}

	// compile second half of the stencils
	loop over AuStencil@current {
		// subtract because off-center stencil coefficients are negated
		AuStencil@current:[-1,  0,  0] = AuStencil@current@[-1,  0,  0]:[ 1,  0,  0] - floweu@current@[-1,  0,  0]
		AuStencil@current:[ 0, -1,  0] = AuStencil@current@[ 0, -1,  0]:[ 0,  1,  0] - flownu@current@[ 0, -1,  0]
		AuStencil@current:[ 0,  0, -1] = AuStencil@current@[ 0,  0, -1]:[ 0,  0,  1] - flowtu@current@[ 0,  0, -1]
	}

	// handle boundary conditions
	apply bc to AuStencil@current

	loop over rhs_u@current {
		Var smasa : Real = (
			( floweu@current - floweu@current@[-1, 0, 0] + flownu@current - flownu@current@[0, -1, 0] + flowtu@current - flowtu@current@[0, 0, -1] ) / vf_xStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AuStencil@current:[0, 0, 0] = smasa
		AuStencil@current:[0, 0, 0] += evalAtWestFace ( rho[active]@current ) / dt
		AuStencil@current:[0, 0, 0] = ( AuStencil@current:[0, 0, 0] * vf_xStagCellVolume@current
			- AuStencil@current:[1, 0, 0] - AuStencil@current:[-1, 0, 0]
			- AuStencil@current:[0, 1, 0] - AuStencil@current:[0, -1, 0]
			- AuStencil@current:[0, 0, 1] - AuStencil@current:[0, 0, -1] ) / relax_1

		rhs_u@current = ( u[active]@current * smasa
			+ u[previous]@current * evalAtWestFace ( rho[previous]@current ) / dt )
		rhs_u@current = rhs_u@current * vf_xStagCellVolume@current + ( 1.0 - relax_1 ) * AuStencil@current:[0, 0, 0] * u[active]@current
		rhs_u@current += ( vf_cellWidth_y@current * vf_cellWidth_z@current ) * ( p@current@[-1, 0, 0] - p@current )
	}

	communicate AuStencil@current

	// restrict stencil
	StencilRestriction_u@current ( )

	// update du
	loop over du@current {
		du@current = ( vf_cellWidth_y@current * vf_cellWidth_z@current ) / ( AuStencil@current:[0, 0, 0] )
	}

	communicate du@current
	apply bc to du@current
}

Function CompileStencil_v@finest (  ) : Unit {
	loop over v@current starting [-1, -1, -1] {
		flowev@current = integrateOverYStaggeredEastFace ( u[active]@current * rho[active]@current )
		flownv@current = integrateOverYStaggeredNorthFace ( v[active]@current * rho[active]@current )
		flowtv@current = integrateOverYStaggeredTopFace ( w[active]@current * rho[active]@current )
	}

	loop over AvStencil@current starting [-1, -1, -1] {
		Val diffev : Real = integrateOverYStaggeredEastFace ( evalAtYStaggeredEastFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[1, 0, 0]
		AvStencil@current:[1, 0, 0] = -1.0 * ( calc_diflow ( flowev@current, diffev ) + max ( 0.0, -1.0 * flowev@current ) )

		Val diffnv : Real = integrateOverYStaggeredNorthFace ( vis@current ) / vf_cellWidth_y@current
		AvStencil@current:[0, 1, 0] = -1.0 * ( calc_diflow ( flownv@current, diffnv ) + max ( 0.0, -1.0 * flownv@current ) )

		Val difftv : Real = integrateOverYStaggeredTopFace ( evalAtYStaggeredTopFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[0, 0, 1]
		AvStencil@current:[0, 0, 1] = -1.0 * ( calc_diflow ( flowtv@current, difftv ) + max ( 0.0, -1.0 * flowtv@current ) )
	}

	// compile second half of the stencils
	loop over AvStencil@current ending [-1, -1, -1] {
		AvStencil@current:[-1,  0,  0] = AvStencil@current@[-1,  0,  0]:[ 1,  0,  0] - flowev@current@[-1,  0,  0]
		AvStencil@current:[ 0, -1,  0] = AvStencil@current@[ 0, -1,  0]:[ 0,  1,  0] - flownv@current@[ 0, -1,  0]
		AvStencil@current:[ 0,  0, -1] = AvStencil@current@[ 0,  0, -1]:[ 0,  0,  1] - flowtv@current@[ 0,  0, -1]
	}

	// handle boundary conditions
	apply bc to AvStencil@current

	loop over rhs_v@current {
		Var smasa : Real = (
			( flowev@current - flowev@current@[-1, 0, 0] + flownv@current - flownv@current@[0, -1, 0] + flowtv@current - flowtv@current@[0, 0, -1] ) / vf_yStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AvStencil@current:[0, 0, 0] = smasa
		AvStencil@current:[0, 0, 0] += evalAtSouthFace ( rho[active]@current ) / dt
		AvStencil@current:[0, 0, 0] = ( AvStencil@current:[0, 0, 0] * vf_yStagCellVolume@current
			- AvStencil@current:[1, 0, 0] - AvStencil@current:[-1, 0, 0]
			- AvStencil@current:[0, 1, 0] - AvStencil@current:[0, -1, 0]
			- AvStencil@current:[0, 0, 1] - AvStencil@current:[0, 0, -1] ) / relax_2

		rhs_v@current = -9.81 * ( rho[active]@current - rhoref ) // incorporate gravity
		rhs_v@current += v[active]@current * smasa
			+ v[previous]@current * evalAtSouthFace ( rho[previous]@current ) / dt
		rhs_v@current = rhs_v@current * vf_yStagCellVolume@current + ( 1.0 - relax_2 ) * AvStencil@current:[0, 0, 0] * v[active]@current
		rhs_v@current += ( vf_cellWidth_x@current * vf_cellWidth_z@current ) * ( p@current@[0, -1, 0] - p@current )
	}

	communicate AvStencil@current

	// restrict stencil
	StencilRestriction_v@current ( )

	// update dv
	loop over dv@current {
		dv@current = ( vf_cellWidth_x@current * vf_cellWidth_z@current ) / ( AvStencil@current:[0, 0, 0] )
	}

	communicate dv@current
	apply bc to dv@current
}

Function CompileStencil_w@finest (  ) : Unit {
	loop over w@current starting [-1, -1, -1] {
		flowew@current = integrateOverZStaggeredEastFace ( u[active]@current * rho[active]@current )
		flownw@current = integrateOverZStaggeredNorthFace ( v[active]@current * rho[active]@current )
		flowtw@current = integrateOverZStaggeredTopFace ( w[active]@current * rho[active]@current )
	}

	loop over AwStencil@current starting [-1, -1, -1] {
		Val diffew : Real = integrateOverZStaggeredEastFace ( evalAtZStaggeredEastFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[1, 0, 0]
		AwStencil@current:[1, 0, 0] = -1.0 * ( calc_diflow ( flowew@current, diffew ) + max ( 0.0, -1.0 * flowew@current ) )

		Val diffnw : Real = integrateOverZStaggeredNorthFace ( evalAtZStaggeredNorthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[0, 1, 0]
		AwStencil@current:[0, 1, 0] = -1.0 * ( calc_diflow ( flownw@current, diffnw ) + max ( 0.0, -1.0 * flownw@current ) )

		Val difftw : Real = integrateOverZStaggeredTopFace ( vis@current ) / vf_cellWidth_z@current
		AwStencil@current:[0, 0, 1] = -1.0 * ( calc_diflow ( flowtw@current, difftw ) + max ( 0.0, -1.0 * flowtw@current ) )
	}

	// compile second half of the stencils
	loop over AwStencil@current ending [-1, -1, -1] {
		AwStencil@current:[-1,  0,  0] = AwStencil@current@[-1,  0,  0]:[ 1,  0,  0] - flowew@current@[-1,  0,  0]
		AwStencil@current:[ 0, -1,  0] = AwStencil@current@[ 0, -1,  0]:[ 0,  1,  0] - flownw@current@[ 0, -1,  0]
		AwStencil@current:[ 0,  0, -1] = AwStencil@current@[ 0,  0, -1]:[ 0,  0,  1] - flowtw@current@[ 0,  0, -1]
	}

	// handle boundary conditions
	apply bc to AwStencil@current

	loop over rhs_w@current {
		Var smasa : Real = (
			( flowew@current - flowew@current@[-1, 0, 0] + flownw@current - flownw@current@[0, -1, 0] + flowtw@current - flowtw@current@[0, 0, -1] ) / vf_zStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AwStencil@current:[0, 0, 0] = smasa
		AwStencil@current:[0, 0, 0] += evalAtBottomFace ( rho[active]@current ) / dt
		AwStencil@current:[0, 0, 0] = ( AwStencil@current:[0, 0, 0] * vf_zStagCellVolume@current
			- AwStencil@current:[1, 0, 0] - AwStencil@current:[-1, 0, 0]
			- AwStencil@current:[0, 1, 0] - AwStencil@current:[0, -1, 0]
			- AwStencil@current:[0, 0, 1] - AwStencil@current:[0, 0, -1] ) / relax_3

		rhs_w@current = w[active]@current * smasa
			+ w[previous]@current * evalAtBottomFace ( rho[previous]@current ) / dt
		rhs_w@current = rhs_w@current * vf_zStagCellVolume@current + ( 1.0 - relax_3 ) * AwStencil@current:[0, 0, 0] * w[active]@current
		rhs_w@current += vf_cellWidth_x@current * vf_cellWidth_y@current * ( p@current@[0, 0, -1] - p@current )
	}

	communicate AwStencil@current

	// restrict stencil
	StencilRestriction_w@current ( )

	// update dw
	loop over dw@current {
		dw@current = vf_cellWidth_x@current * vf_cellWidth_y@current / AwStencil@current:[0, 0, 0]
	}

	communicate dw@current
	apply bc to dw@current
}

Function CompileStencil_pc@finest (  ) : Unit {
	// compile first half of the stencils
	loop over ApcStencil@current starting [-1, -1, -1] {
		ApcStencil@current:[ 1,  0,  0] = -1.0 * integrateOverEastFace ( du@current * rho[active]@current )
		ApcStencil@current:[ 0,  1,  0] = -1.0 * integrateOverNorthFace ( dv@current * rho[active]@current )
		ApcStencil@current:[ 0,  0,  1] = -1.0 * integrateOverTopFace ( dw@current * rho[active]@current )
	}

	// compile second half of the stencils
	loop over ApcStencil@current ending [-1, -1, -1] {
		ApcStencil@current:[-1,  0,  0] = ApcStencil@current@[-1,  0,  0]:[ 1,  0,  0]
		ApcStencil@current:[ 0, -1,  0] = ApcStencil@current@[ 0, -1,  0]:[ 0,  1,  0]
		ApcStencil@current:[ 0,  0, -1] = ApcStencil@current@[ 0,  0, -1]:[ 0,  0,  1]
	}

	// handle boundary conditions
	apply bc to ApcStencil@current

	loop over ApcStencil@current {
		ApcStencil@current:[ 0,  0,  0] = -1.0 * (
			ApcStencil@current:[ 1,  0,  0] + ApcStencil@current:[-1,  0,  0] +
			ApcStencil@current:[ 0,  1,  0] + ApcStencil@current:[ 0, -1,  0] +
			ApcStencil@current:[ 0,  0,  1] + ApcStencil@current:[ 0,  0, -1] )
	}

	loop over rhs_pc@current {
		rhs_pc@current = (
			integrateOverWestFace ( u[active]@current * rho[active]@current )
			- integrateOverEastFace ( u[active]@current * rho[active]@current )
			+ integrateOverSouthFace ( v[active]@current * rho[active]@current )
			- integrateOverNorthFace ( v[active]@current * rho[active]@current )
			+ integrateOverBottomFace ( w[active]@current * rho[active]@current )
			- integrateOverTopFace ( w[active]@current * rho[active]@current )
			+ vf_cellWidth_y@current * vf_cellWidth_z@current * vf_cellWidth_x@current * ( rho[previous]@current - rho[active]@current ) / dt )
	}

	// restrict stencil
	StencilRestriction_pc@current ( )
}

Function CompileStencil_t@finest (  ) : Unit {
	loop over rho@current starting [-1, -1, -1] {
		flowet@current = integrateOverEastFace ( u[active]@current * rho[active]@current )
		flownt@current = integrateOverNorthFace ( v[active]@current * rho[active]@current )
		flowtt@current = integrateOverTopFace ( w[active]@current * rho[active]@current )
	}

	loop over AtStencil@current starting [-1, -1, -1] {
		Val diffet : Real = integrateOverEastFace ( evalAtEastFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[1, 0, 0]
		AtStencil@current:[1, 0, 0] = -1.0 * ( calc_diflow ( flowet@current, diffet ) + max ( 0.0, -1.0 * flowet@current ) )

		Val diffnt : Real = integrateOverNorthFace ( evalAtNorthFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[0, 1, 0]
		AtStencil@current:[0, 1, 0] = -1.0 * ( calc_diflow ( flownt@current, diffnt ) + max ( 0.0, -1.0 * flownt@current ) )

		Val difftt : Real = integrateOverTopFace ( evalAtTopFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[0, 0, 1]
		AtStencil@current:[0, 0, 1] = -1.0 * ( calc_diflow ( flowtt@current, difftt ) + max ( 0.0, -1.0 * flowtt@current ) )
	}

	// compile second half of the stencils
	loop over AtStencil@current ending [-1, -1, -1] {
		AtStencil@current:[-1,  0,  0] = AtStencil@current@[-1,  0,  0]:[ 1,  0,  0] - flowet@current@[-1,  0,  0]
		AtStencil@current:[ 0, -1,  0] = AtStencil@current@[ 0, -1,  0]:[ 0,  1,  0] - flownt@current@[ 0, -1,  0]
		AtStencil@current:[ 0,  0, -1] = AtStencil@current@[ 0,  0, -1]:[ 0,  0,  1] - flowtt@current@[ 0,  0, -1]
	}

	// handle boundary conditions
	apply bc to AtStencil@current

	loop over rhs_t@current {
		Var smasa : Real = (
			( flowet@current - flowet@current@[-1, 0, 0] + flownt@current - flownt@current@[0, -1, 0] + flowtt@current - flowtt@current@[0, 0, -1] ) / vf_cellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AtStencil@current:[0, 0, 0] = smasa + rho[active]@current / dt
		AtStencil@current:[0, 0, 0] = ( AtStencil@current:[0, 0, 0] * vf_cellVolume@current
			- AtStencil@current:[1, 0, 0] - AtStencil@current:[-1, 0, 0]
			- AtStencil@current:[0, 1, 0] - AtStencil@current:[0, -1, 0]
			- AtStencil@current:[0, 0, 1] - AtStencil@current:[0, 0, -1] ) / relax_7

		rhs_t@current = smasa * phi7[active]@current
			+ ( rho[active]@current / dt ) * phi7[previous]@current
		rhs_t@current = rhs_t@current * vf_cellVolume@current + ( 1.0 - relax_7 ) * AtStencil@current:[0, 0, 0] * phi7[active]@current
	}

	// restrict stencil
	StencilRestriction_t@current ( )
}

/// templates for (multigrid) solver components

FunctionTemplate SolveComponent < vCycle, normFunction, maxSteps, rhs, converged > ( ) : Unit {
	Var initRes : Real    = normFunction@current()
	Var curRes  : Real    = initRes
	Var prevRes : Real    = curRes
	Var numIt   : Integer = 0

	totalInitRes += initRes

	Var normRHS : Real = 0
	loop over rhs with reduction ( + : normRHS ) {
		normRHS += rhs ** 2
	}
	normRHS = sqrt ( normRHS )

	if ( curRes <= targetResPerComp * ( 1.0 + normRHS ) ) {
		converged = true
	}
	repeat until numIt > 0 && ( curRes <= targetResPerComp * ( 1.0 + normRHS ) || numIt >= maxSteps || ( numIt > 0 && prevRes - curRes < stagnationThreshold * targetResPerComp ) ) {
		vCycle@current ( )

		prevRes = curRes
		curRes = normFunction@current()
		numIt += 1
	}

	//print ( numIt, normRHS, initRes, curRes)
}

FunctionTemplate StencilRestrictionComponent < self, source, dest, restrictionStencil > ( ) : Unit {
	loop over dest {
		dest:[ 0,  0,  0] = restrictionStencil * source:[ 0,  0,  0]
		dest:[-1,  0,  0] = restrictionStencil * source:[-1,  0,  0]
		dest:[ 1,  0,  0] = restrictionStencil * source:[ 1,  0,  0]
		dest:[ 0, -1,  0] = restrictionStencil * source:[ 0, -1,  0]
		dest:[ 0,  1,  0] = restrictionStencil * source:[ 0,  1,  0]
		dest:[ 0,  0, -1] = restrictionStencil * source:[ 0,  0, -1]
		dest:[ 0,  0,  1] = restrictionStencil * source:[ 0,  0,  1]
	}

	communicate dest
	apply bc to dest

	if ( levels@current ( ) - 1 > levels@coarsest ( ) ) {
		self@coarser ( )
	}
}

// instantiations

Instantiate SolveComponent < VCycle_u, NormResidual_u, 100, rhs_u@current, converged_u > as Solve_u@finest
Instantiate StencilRestrictionComponent < StencilRestriction_u, AuStencil@current, AuStencil@coarser, RestrictionFaceX@current > as StencilRestriction_u@( ( coarsest + 1 ) to finest )

Instantiate SolveComponent < VCycle_v, NormResidual_v, 100, rhs_v@current, converged_v > as Solve_v@finest
Instantiate StencilRestrictionComponent < StencilRestriction_v, AvStencil@current, AvStencil@coarser, RestrictionFaceY@current > as StencilRestriction_v@( ( coarsest + 1 ) to finest )

Instantiate SolveComponent < VCycle_w, NormResidual_w, 100, rhs_w@current, converged_w > as Solve_w@finest
Instantiate StencilRestrictionComponent < StencilRestriction_w, AwStencil@current, AwStencil@coarser, RestrictionFaceZ@current > as StencilRestriction_w@( ( coarsest + 1 ) to finest )

Instantiate SolveComponent < VCycle_pc, NormResidual_pc, 100, rhs_pc@current, converged_pc > as Solve_pc@finest
Instantiate StencilRestrictionComponent < StencilRestriction_pc, ApcStencil@current, ApcStencil@coarser, RestrictionCell@current > as StencilRestriction_pc@( ( coarsest + 1 ) to finest )

Instantiate SolveComponent < VCycle_t, NormResidual_t, 100, rhs_t@current, converged_t > as Solve_t@finest
Instantiate StencilRestrictionComponent < StencilRestriction_t, AtStencil@current, AtStencil@coarser, RestrictionCell@current > as StencilRestriction_t@( ( coarsest + 1 ) to finest )
