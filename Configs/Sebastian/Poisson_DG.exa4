Domain global< [ 0, 0 ] to [ 1, 1 ] >

Layout NoComm< Real, Cell >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 0, 0 ]
}
Layout BasicComm< Real, Cell >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 0, 0 ] with communication
}
Layout NoCommSF< Array<Real><9>, Cell >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 0, 0 ]
}
Layout NodePosData< Real, Node >@all {
	ghostLayers = [ 1, 1 ]
	duplicateLayers = [ 1, 1 ]
}

Field Solution< global, BasicComm, applyBC_Sol@current ( ) >@all
Field Residual< global, BasicComm, None >@all
Field RHS< global, NoComm, None >@all

Field Solution_L< global, BasicComm, applyBC_Sol_L@current ( ) >@all
Field Solution_U< global, BasicComm, applyBC_Sol_U@current ( ) >@all
Field Residual_L< global, BasicComm, None >@all
Field Residual_U< global, BasicComm, None >@all
Field RHS_L< global, NoComm, None >@all
Field RHS_U< global, NoComm, None >@all

Field Solution_DG_L< global, BasicComm, applyBC_Sol_DG_L@current ( ) >@all
Field Solution_DG_U< global, BasicComm, applyBC_Sol_DG_U@current ( ) >@all
Field Residual_DG_L< global, BasicComm, None >@all
Field Residual_DG_U< global, BasicComm, None >@all
Field RHS_DG_L< global, NoComm, None >@all
Field RHS_DG_U< global, NoComm, None >@all

Field NodePos_x< global, NodePosData, None >@all
Field NodePos_y< global, NodePosData, None >@all
Field CellCen_x< global, BasicComm, None >@all
Field CellCen_y< global, BasicComm, None >@all
Field CellVol< global, BasicComm, None >@all

Field CellCen_L_x< global, BasicComm, None >@all
Field CellCen_U_x< global, BasicComm, None >@all
Field CellCen_L_y< global, BasicComm, None >@all
Field CellCen_U_y< global, BasicComm, None >@all
Field CellVol_L< global, BasicComm, None >@all
Field CellVol_U< global, BasicComm, None >@all

Field LaplaceCoeff< global, NoCommSF, None >@all
StencilField Laplace< LaplaceCoeff => LaplaceStencil >@all

Field LaplaceCoeff_L_L< global, NoCommSF, None >@all
StencilField Laplace_L_L< LaplaceCoeff_L_L => LaplaceStencil_L_L >@all
Field LaplaceCoeff_L_U< global, NoCommSF, None >@all
StencilField Laplace_L_U< LaplaceCoeff_L_U => LaplaceStencil_L_U >@all
Field LaplaceCoeff_U_U< global, NoCommSF, None >@all
StencilField Laplace_U_U< LaplaceCoeff_U_U => LaplaceStencil_U_U >@all
Field LaplaceCoeff_U_L< global, NoCommSF, None >@all
StencilField Laplace_U_L< LaplaceCoeff_U_L => LaplaceStencil_U_L >@all

Field Laplace_DGCoeff_L_L< global, NoCommSF, None >@all
StencilField Laplace_DG_L_L< Laplace_DGCoeff_L_L => Laplace_DGStencil_L_L >@all
Field Laplace_DGCoeff_L_U< global, NoCommSF, None >@all
StencilField Laplace_DG_L_U< Laplace_DGCoeff_L_U => Laplace_DGStencil_L_U >@all
Field Laplace_DGCoeff_U_U< global, NoCommSF, None >@all
StencilField Laplace_DG_U_U< Laplace_DGCoeff_U_U => Laplace_DGStencil_U_U >@all
Field Laplace_DGCoeff_U_L< global, NoCommSF, None >@all
StencilField Laplace_DG_U_L< Laplace_DGCoeff_U_L => Laplace_DGStencil_U_L >@all

Stencil LaplaceStencil@all {
	[ 0,  0] => 0.0
	[ 1,  0] => 0.0
	[-1,  0] => 0.0
	[ 0,  1] => 0.0
	[ 0, -1] => 0.0
	[ 1,  1] => 0.0
	[ 1, -1] => 0.0
	[-1,  1] => 0.0
	[-1, -1] => 0.0
}
Stencil ProlongateValue@all {
	[ 0, 0] => 1.0
}
Stencil RestrictIntegral@all {
	[ 0,  0] => 1.0
	[ 0,  1] => 1.0
	[ 1,  0] => 1.0
	[ 1,  1] => 1.0
}
Stencil RestrictValue@all {
	[ 0,  0] => 0.25
	[ 0,  1] => 0.25
	[ 1,  0] => 0.25
	[ 1,  1] => 0.25
}

Stencil LaplaceStencil_L_L@all {
	[ 0,  0] => 0.0
}

Stencil LaplaceStencil_L_U@all {
	[ 0,  0] => 0.0
	[-1,  0] => 0.0
	[ 0, -1] => 0.0
}

Stencil LaplaceStencil_U_U@all {
	[ 0,  0] => 0.0
}

Stencil LaplaceStencil_U_L@all {
	[ 0,  0] => 0.0
	[ 1,  0] => 0.0
	[ 0,  1] => 0.0
}


Stencil Laplace_DGStencil_L_L@all {
	[ 0,  0] => 0.0
}

Stencil Laplace_DGStencil_L_U@all {
	[ 0,  0] => 0.0
	[-1,  0] => 0.0
	[ 0, -1] => 0.0
}

Stencil Laplace_DGStencil_U_U@all {
	[ 0,  0] => 0.0
}

Stencil Laplace_DGStencil_U_L@all {
	[ 0,  0] => 0.0
	[ 1,  0] => 0.0
	[ 0,  1] => 0.0
}


Function applyBC_Sol@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Solution@current only ghost [-1,  0] on boundary {
		Val p0_x : Real = CellCen_x@current@[0, 0]
		Val p0_y : Real = CellCen_y@current@[0, 0]
		Val p1_x : Real = CellCen_x@current@[1, 0]
		Val p1_y : Real = CellCen_y@current@[1, 0]
		Val n0_x : Real = NodePos_x@current@[1, 0]
		Val n0_y : Real = NodePos_y@current@[1, 0]
		Val n1_x : Real = NodePos_x@current@[1, 1]
		Val n1_y : Real = NodePos_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[1, 0]
	}
	loop over Solution@current only ghost [ 1,  0] on boundary {
		Val p0_x : Real = CellCen_x@current@[0, 0]
		Val p0_y : Real = CellCen_y@current@[0, 0]
		Val p1_x : Real = CellCen_x@current@[-1, 0]
		Val p1_y : Real = CellCen_y@current@[-1, 0]
		Val n0_x : Real = NodePos_x@current@[0, 0]
		Val n0_y : Real = NodePos_y@current@[0, 0]
		Val n1_x : Real = NodePos_x@current@[0, 1]
		Val n1_y : Real = NodePos_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[-1, 0]
	}
	loop over Solution@current only ghost [ 0,  1] on boundary {
		Val p0_x : Real = CellCen_x@current@[0, 0]
		Val p0_y : Real = CellCen_y@current@[0, 0]
		Val p1_x : Real = CellCen_x@current@[0, -1]
		Val p1_y : Real = CellCen_y@current@[0, -1]
		Val n0_x : Real = NodePos_x@current@[0, 0]
		Val n0_y : Real = NodePos_y@current@[0, 0]
		Val n1_x : Real = NodePos_x@current@[1, 0]
		Val n1_y : Real = NodePos_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[0, -1]
	}
	loop over Solution@current only ghost [ 0, -1] on boundary {
		Val p0_x : Real = CellCen_x@current@[0, 0]
		Val p0_y : Real = CellCen_y@current@[0, 0]
		Val p1_x : Real = CellCen_x@current@[0, 1]
		Val p1_y : Real = CellCen_y@current@[0, 1]
		Val n0_x : Real = NodePos_x@current@[0, 1]
		Val n0_y : Real = NodePos_y@current@[0, 1]
		Val n1_x : Real = NodePos_x@current@[1, 1]
		Val n1_y : Real = NodePos_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[0, 1]
	}
	
	/*loop over Solution@current only ghost [-1, -1] on boundary {
		Val p0_x : Real = CellCen_x@current@[0, 0]
		Val p0_y : Real = CellCen_y@current@[0, 0]
		Val p1_x : Real = CellCen_x@current@[1, 1]
		Val p1_y : Real = CellCen_y@current@[1, 1]

		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Val n0_x : Real = NodePos_x@current@[1, 1]
		Val n0_y : Real = NodePos_y@current@[1, 1]
		Val n1_x : Real = NodePos_x@current@[2, 1]
		Val n1_y : Real = NodePos_y@current@[2, 1]
		Val n2_x : Real = NodePos_x@current@[1, 2]
		Val n2_y : Real = NodePos_y@current@[1, 2]

		Var f_1_x : Real = n1_x - n0_x // nx
		Var f_1_y : Real = n1_y - n0_y
		Var f_2_x : Real = n2_x - n0_x // nx
		Var f_2_y : Real = n2_y - n0_y

		Var alpha_1 : Real = 1.0 / ( -f_1_x * e_y + e_x * f_1_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta_1 : Real = 1.0 / ( -f_1_x * e_y + e_x * f_1_y ) * ( -f_1_y * ( p0_x - n0_x ) + f_1_x * ( p0_y - n0_y ) )
		Var alpha_2 : Real = 1.0 / ( -f_2_x * e_y + e_x * f_2_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta_2 : Real = 1.0 / ( -f_2_x * e_y + e_x * f_2_y ) * ( -f_2_y * ( p0_x - n0_x ) + f_2_x * ( p0_y - n0_y ) )
		
		if ( 0.0 <= alpha_1 && alpha_1 <= 1.0 ) {
			Var boundary_x : Real = n0_x + alpha_1 * f_1_x
			Var boundary_y : Real = n0_y + alpha_1 * f_1_y

			Var w_i : Real = 1.0 / ( 1.0 - beta_1 )
			Var w_1 : Real = -beta_1 / ( 1.0 - beta_1 )

			Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[0, 1]
		} else if ( 0.0 <= alpha_2 && alpha_2 <= 1.0 ) {
			Var boundary_x : Real = n0_x + alpha_2 * f_2_x
			Var boundary_y : Real = n0_y + alpha_2 * f_2_y

			Var w_i : Real = 1.0 / ( 1.0 - beta_2 )
			Var w_1 : Real = -beta_2 / ( 1.0 - beta_2 )

			Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[1, 1]
		} else {
			print ( 'intersection is very wrong at', x, y, 'with alphas', alpha_1, alpha_2, 'and betas', beta_1, beta_2)
		}
	}*/
}


Function applyBC_Sol_L@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	/*loop over Solution_L@current only ghost [-1,  0] on boundary {
		Solution_L@current = Solution_L@current@[ 1,  0]
	}*/
	loop over Solution_L@current only ghost [ 1,  0] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[0, 0] + NodePos_x@current@[0, 1] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[0, 0] + NodePos_y@current@[0, 1] )
		//Solution_L@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_U@current@[-1,  0]

		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[-1, 0]
		Val p1_y : Real = CellCen_U_y@current@[-1, 0]
		Val n0_x : Real = NodePos_x@current@[0, 0]
		Val n0_y : Real = NodePos_y@current@[0, 0]
		Val n1_x : Real = NodePos_x@current@[0, 1]
		Val n1_y : Real = NodePos_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_L@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_U@current@[-1, 0]
	}
	loop over Solution_L@current only ghost [ 0,  1] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[0, 0] + NodePos_x@current@[1, 0] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[0, 0] + NodePos_y@current@[1, 0] )
		//Solution_L@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_U@current@[ 0, -1]

		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[0, -1]
		Val p1_y : Real = CellCen_U_y@current@[0, -1]
		Val n0_x : Real = NodePos_x@current@[0, 0]
		Val n0_y : Real = NodePos_y@current@[0, 0]
		Val n1_x : Real = NodePos_x@current@[1, 0]
		Val n1_y : Real = NodePos_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_L@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_U@current@[0, -1]
	}
	/*loop over Solution_L@current only ghost [ 0, -1] on boundary {
		Solution_L@current = Solution_L@current@[ 0,  1]
	}*/
}
Function applyBC_Sol_U@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Solution_U@current only ghost [-1,  0] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[1, 0] + NodePos_x@current@[1, 1] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[1, 0] + NodePos_y@current@[1, 1] )
		//Solution_U@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_L@current@[ 1,  0]

		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[1, 0]
		Val p1_y : Real = CellCen_L_y@current@[1, 0]
		Val n0_x : Real = NodePos_x@current@[1, 0]
		Val n0_y : Real = NodePos_y@current@[1, 0]
		Val n1_x : Real = NodePos_x@current@[1, 1]
		Val n1_y : Real = NodePos_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_U@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_L@current@[1, 0]
	}
	/*loop over Solution_U@current only ghost [ 1,  0] on boundary {
		Solution_U@current = Solution_U@current@[-1,  0]
	}*/
	/*loop over Solution_U@current only ghost [ 0,  1] on boundary {
		Solution_U@current = Solution_U@current@[ 0, -1]
	}*/
	loop over Solution_U@current only ghost [ 0, -1] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[0, 1] + NodePos_x@current@[1, 1] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[0, 1] + NodePos_y@current@[1, 1] )
		//Solution_U@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_L@current@[ 0,  1]

		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[0, 1]
		Val p1_y : Real = CellCen_L_y@current@[0, 1]
		Val n0_x : Real = NodePos_x@current@[0, 1]
		Val n0_y : Real = NodePos_y@current@[0, 1]
		Val n1_x : Real = NodePos_x@current@[1, 1]
		Val n1_y : Real = NodePos_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_U@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_L@current@[0, 1]
	}
}

Function applyBC_Sol_DG_L@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	/*loop over Solution_DG_L@current only ghost [-1,  0] on boundary {
		Solution_DG_L@current = Solution_DG_L@current@[ 1,  0]
	}*/
	loop over Solution_DG_L@current only ghost [ 1,  0] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[0, 0] + NodePos_x@current@[0, 1] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[0, 0] + NodePos_y@current@[0, 1] )
		//Solution_DG_L@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_DG_U@current@[-1,  0]

		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[-1, 0]
		Val p1_y : Real = CellCen_U_y@current@[-1, 0]
		Val n0_x : Real = NodePos_x@current@[0, 0]
		Val n0_y : Real = NodePos_y@current@[0, 0]
		Val n1_x : Real = NodePos_x@current@[0, 1]
		Val n1_y : Real = NodePos_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_DG_L@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_DG_U@current@[-1, 0]
	}
	loop over Solution_DG_L@current only ghost [ 0,  1] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[0, 0] + NodePos_x@current@[1, 0] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[0, 0] + NodePos_y@current@[1, 0] )
		//Solution_DG_L@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_DG_U@current@[ 0, -1]

		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[0, -1]
		Val p1_y : Real = CellCen_U_y@current@[0, -1]
		Val n0_x : Real = NodePos_x@current@[0, 0]
		Val n0_y : Real = NodePos_y@current@[0, 0]
		Val n1_x : Real = NodePos_x@current@[1, 0]
		Val n1_y : Real = NodePos_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_DG_L@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_DG_U@current@[0, -1]
	}
	/*loop over Solution_DG_L@current only ghost [ 0, -1] on boundary {
		Solution_DG_L@current = Solution_DG_L@current@[ 0,  1]
	}*/
}
Function applyBC_Sol_DG_U@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Solution_DG_U@current only ghost [-1,  0] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[1, 0] + NodePos_x@current@[1, 1] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[1, 0] + NodePos_y@current@[1, 1] )
		//Solution_DG_U@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_DG_L@current@[ 1,  0]

		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[1, 0]
		Val p1_y : Real = CellCen_L_y@current@[1, 0]
		Val n0_x : Real = NodePos_x@current@[1, 0]
		Val n0_y : Real = NodePos_y@current@[1, 0]
		Val n1_x : Real = NodePos_x@current@[1, 1]
		Val n1_y : Real = NodePos_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_DG_U@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_DG_L@current@[1, 0]
	}
	/*loop over Solution_DG_U@current only ghost [ 1,  0] on boundary {
		Solution_DG_U@current = Solution_DG_U@current@[-1,  0]
	}*/
	/*loop over Solution_DG_U@current only ghost [ 0,  1] on boundary {
		Solution_DG_U@current = Solution_DG_U@current@[ 0, -1]
	}*/
	loop over Solution_DG_U@current only ghost [ 0, -1] on boundary {
		//Val boundary_x : Real = 0.5 * ( NodePos_x@current@[0, 1] + NodePos_x@current@[1, 1] )
		//Val boundary_y : Real = 0.5 * ( NodePos_y@current@[0, 1] + NodePos_y@current@[1, 1] )
		//Solution_DG_U@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_DG_L@current@[ 0,  1]

		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[0, 1]
		Val p1_y : Real = CellCen_L_y@current@[0, 1]
		Val n0_x : Real = NodePos_x@current@[0, 1]
		Val n0_y : Real = NodePos_y@current@[0, 1]
		Val n1_x : Real = NodePos_x@current@[1, 1]
		Val n1_y : Real = NodePos_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_DG_U@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_DG_L@current@[0, 1]
	}
}

Globals {
	Var factor : Real = 1.0
	Var omegaQuad : Real = 1.0
	Var omegaTri : Real = 1.0
	Var omegaDG : Real = 1.0
}

Function VCycle@finest ( ) : Unit {
	repeat 50 times {
		Smoother@current ( )
	}
}

Function VCycle_Tri@finest ( ) : Unit {
	repeat 50 times {
		Smoother_Tri@current ( )
	}
}

Function VCycle_DG@finest ( ) : Unit {
	repeat 50 times {
		Smoother_DG@current ( )
	}
}

Function Smoother@all ( ) : Unit {
	/*
	apply bc to Solution[active]@current
	communicate Solution[active]@current
	loop over Solution@current {
		Solution[nextSlot]@current = Solution[active]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * omegaQuad ) * ( RHS@current - Laplace@current * Solution[active]@current ) )
	}
	advance Solution@current
	*/

	apply bc to Solution@current
	communicate Solution@current

	loop over Solution@current where 0 == ( x + y ) % 2 {
		Solution@current = Solution@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * omegaQuad ) * ( RHS@current - Laplace@current * Solution@current ) )
	}

	apply bc to Solution@current
	communicate Solution@current

	loop over Solution@current where 1 == ( x + y ) % 2 {
		Solution@current = Solution@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * omegaQuad ) * ( RHS@current - Laplace@current * Solution@current ) )
	}
}

Function Smoother_Tri@all ( ) : Unit {
	apply bc to Solution_L@current
	communicate Solution_L@current
	apply bc to Solution_U@current
	communicate Solution_U@current

	loop over Solution_L@current {
		Solution_L@current = Solution_L@current + ( ( ( 1.0 / diag ( Laplace_L_L@current ) ) * omegaTri ) * ( RHS_L@current - ( Laplace_L_L@current * Solution_L@current + Laplace_L_U@current * Solution_U@current ) ) )
	}

	apply bc to Solution_L@current
	communicate Solution_L@current
	apply bc to Solution_U@current
	communicate Solution_U@current

	loop over Solution_U@current {
		Solution_U@current = Solution_U@current + ( ( ( 1.0 / diag ( Laplace_U_U@current ) ) * omegaTri ) * ( RHS_U@current - ( Laplace_U_U@current * Solution_U@current + Laplace_U_L@current * Solution_L@current ) ) )
	}
}

Function Smoother_DG@all ( ) : Unit {
	apply bc to Solution_DG_L@current
	communicate Solution_DG_L@current
	apply bc to Solution_DG_U@current
	communicate Solution_DG_U@current

	loop over Solution_DG_L@current {
		Solution_DG_L@current = Solution_DG_L@current + ( ( ( 1.0 / diag ( Laplace_DG_L_L@current ) ) * omegaDG ) * ( RHS_DG_L@current - ( Laplace_DG_L_L@current * Solution_DG_L@current + Laplace_DG_L_U@current * Solution_DG_U@current ) ) )
	}

	apply bc to Solution_DG_L@current
	communicate Solution_DG_L@current
	apply bc to Solution_DG_U@current
	communicate Solution_DG_U@current

	loop over Solution_DG_U@current {
		Solution_DG_U@current = Solution_DG_U@current + ( ( ( 1.0 / diag ( Laplace_DG_U_U@current ) ) * omegaDG ) * ( RHS_DG_U@current - ( Laplace_DG_U_U@current * Solution_DG_U@current + Laplace_DG_U_L@current * Solution_DG_L@current ) ) )
	}
}

Function UpResidual@all (  ) : Unit {
	apply bc to Solution[active]@current
	communicate Solution[active]@current
	loop over Residual@current {
		Residual@current = RHS@current - (Laplace@current * Solution[active]@current)
	}
}

Function UpResidual_Tri@all (  ) : Unit {
	apply bc to Solution_L[active]@current
	apply bc to Solution_U[active]@current
	communicate Solution_L[active]@current
	communicate Solution_U[active]@current
	loop over Residual_L@current {
		Residual_L@current = RHS_L@current - ( Laplace_L_L@current * Solution_L[active]@current + Laplace_L_U@current * Solution_U[active]@current )
	}
	loop over Residual_U@current {
		Residual_U@current = RHS_U@current - ( Laplace_U_U@current * Solution_U[active]@current + Laplace_U_L@current * Solution_L[active]@current )
	}
}

Function UpResidual_DG@all (  ) : Unit {
	apply bc to Solution_DG_L[active]@current
	apply bc to Solution_DG_U[active]@current
	communicate Solution_DG_L[active]@current
	communicate Solution_DG_U[active]@current
	loop over Residual_DG_L@current {
		Residual_DG_L@current = RHS_DG_L@current - ( Laplace_DG_L_L@current * Solution_DG_L[active]@current + Laplace_DG_L_U@current * Solution_DG_U[active]@current )
	}
	loop over Residual_DG_U@current {
		Residual_DG_U@current = RHS_DG_U@current - ( Laplace_DG_U_U@current * Solution_DG_U[active]@current + Laplace_DG_U_L@current * Solution_DG_L[active]@current )
	}
}

Function NormResidual_0@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over Residual@current with reduction( + : res ) {
		res += Residual@current * Residual@current
	}
	return sqrt ( res )
}

Function NormResidual_Tri@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over Residual_L@current with reduction( + : res ) {
		res += Residual_L@current * Residual_L@current
	}
	loop over Residual_U@current with reduction( + : res ) {
		res += Residual_U@current * Residual_U@current
	}
	return sqrt ( res )
}

Function NormResidual_DG@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over Residual_DG_L@current with reduction( + : res ) {
		res += Residual_DG_L@current * Residual_DG_L@current
	}
	loop over Residual_DG_U@current with reduction( + : res ) {
		res += Residual_DG_U@current * Residual_DG_U@current
	}
	return sqrt ( res )
}

Function NormError_0@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over Solution@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution[active]@current - ( CellCen_x@current**2 - CellCen_y@current**2 ) )
		err = max ( err, curErr )
	}
	return ( err )
}

Function NormError_Tri@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over Solution_L@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution_L[active]@current - ( CellCen_L_x@current**2 - CellCen_L_y@current**2 ) )
		err = max ( err, curErr )
	}
	loop over Solution_U@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution_U[active]@current - ( CellCen_U_x@current**2 - CellCen_U_y@current**2 ) )
		err = max ( err, curErr )
	}
	return ( err )
}

Function NormError_DG@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over Solution_DG_L@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution_DG_L[active]@current - ( CellCen_L_x@current**2 - CellCen_L_y@current**2 ) )
		err = max ( err, curErr )
	}
	loop over Solution_DG_U@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution_DG_U[active]@current - ( CellCen_U_x@current**2 - CellCen_U_y@current**2 ) )
		err = max ( err, curErr )
	}
	return ( err )
}


Function SetSolution@all (value : Real) : Unit {
	loop over Solution@current {
		Solution[active]@current = value
	}
}

Function SetSolution_Tri@all (value : Real) : Unit {
	loop over Solution_L@current {
		Solution_L[active]@current = value
	}
	loop over Solution_U@current {
		Solution_U[active]@current = value
	}
}

Function SetSolution_DG@all (value : Real) : Unit {
	loop over Solution_DG_L@current {
		Solution_DG_L[active]@current = value
	}
	loop over Solution_DG_U@current {
		Solution_DG_U[active]@current = value
	}
}

Function InitSolution ( ) : Unit {
	loop over Solution@finest {
		Solution[active]@finest = 0
	}
}

Function InitSolution_Tri ( ) : Unit {
	loop over Solution_L@finest {
		Solution_L[active]@finest = 0
	}
	loop over Solution_U@finest {
		Solution_U[active]@finest = 0
	}
}

Function InitSolution_DG ( ) : Unit {
	loop over Solution_DG_L@finest {
		Solution_DG_L[active]@finest = 0
	}
	loop over Solution_DG_U@finest {
		Solution_DG_U[active]@finest = 0
	}
}

Function InitRHS@finest ( ) : Unit {
	loop over RHS@current {
		RHS@current = 0.0
	}
}

Function InitRHS_Tri@finest ( ) : Unit {
	loop over RHS_L@current {
		RHS_L@current = 0.0
	}
	loop over RHS_U@current {
		RHS_U@current = 0.0
	}
}

Function InitRHS_DG@finest ( ) : Unit {
	loop over RHS_DG_L@current {
		RHS_DG_L@current = 0.0
	}
	loop over RHS_DG_U@current {
		RHS_DG_U@current = 0.0
	}
}

Function InitPosData@all ( ) : Unit {
	@finest {
		Var lvl : Int = levels@current ( )
		native ( 'static std::default_random_engine generator(lvl)' )
		//native ( 'static std::normal_distribution<double> distribution(0.0, 0.1 * pow(2, -lvl))' )
		native ( 'static std::uniform_real_distribution <double> distribution(-0.1 * pow(2, -lvl), 0.1 * pow(2, -lvl));' )
		native ( 'static auto randn = std::bind (distribution, generator)' )

		loop over NodePos_x@current starting [-2, -2] ending [-2, -2] {
			NodePos_x@current = vf_nodePosition_x@current
		}
		loop over NodePos_x@current sequentially {
			NodePos_x@current += randn()
		}
		loop over NodePos_y@current starting [-2, -2] ending [-2, -2] {
			NodePos_y@current = vf_nodePosition_y@current
		}
		loop over NodePos_y@current sequentially {
			NodePos_y@current += randn()
		}
	}
	@(all but finest) {
		loop over NodePos_x@current starting [-2, -2] ending [-2, -2] {
			NodePos_x@current = vf_nodePosition_x@current
		}
		loop over NodePos_x@current {
			NodePos_x@current = NodePos_x@finer
		}
		loop over NodePos_y@current starting [-2, -2] ending [-2, -2] {
			NodePos_y@current = vf_nodePosition_y@current
		}
		loop over NodePos_y@current {
			NodePos_y@current = NodePos_y@finer
		}
	}

	loop over CellCen_x@current starting [-1, -1] ending [-1, -1] {
		CellCen_x@current = 0.25 * ( NodePos_x@current@[0, 0] + NodePos_x@current@[1, 0] + NodePos_x@current@[0, 1] + NodePos_x@current@[1, 1] )
		CellCen_L_x@current = ( 1.0 / 3.0 ) * ( NodePos_x@current@[0, 0] + NodePos_x@current@[1, 0] + NodePos_x@current@[0, 1] )
		CellCen_U_x@current = ( 1.0 / 3.0 ) * ( NodePos_x@current@[1, 0] + NodePos_x@current@[0, 1] + NodePos_x@current@[1, 1] )
	}
	loop over CellCen_y@current starting [-1, -1] ending [-1, -1] {
		CellCen_y@current = 0.25 * ( NodePos_y@current@[0, 0] + NodePos_y@current@[1, 0] + NodePos_y@current@[0, 1] + NodePos_y@current@[1, 1] )
		CellCen_L_y@current = ( 1.0 / 3.0 ) * ( NodePos_y@current@[0, 0] + NodePos_y@current@[1, 0] + NodePos_y@current@[0, 1] )
		CellCen_U_y@current = ( 1.0 / 3.0 ) * ( NodePos_y@current@[1, 0] + NodePos_y@current@[0, 1] + NodePos_y@current@[1, 1] )
	}

	loop over CellVol@current starting [-1, -1] ending [-1, -1] {
		// split quad into two triangles and use Heron's formula (https://en.wikipedia.org/wiki/Heron's_formula)
		// A = 0.25 * sqrt ( 4.0 * a**2 * b**2 - (a**2 + b**2 - c**2 )**2 )
		// NOTE: assumes convex quads
		Var a : Real = sqrt ( ( NodePos_x@current@[1, 0] - NodePos_x@current@[0, 0] )**2 + ( NodePos_y@current@[1, 0] - NodePos_y@current@[0, 0] )**2 )
		Var b : Real = sqrt ( ( NodePos_x@current@[0, 1] - NodePos_x@current@[0, 0] )**2 + ( NodePos_y@current@[0, 1] - NodePos_y@current@[0, 0] )**2 )
		Var c : Real = sqrt ( ( NodePos_x@current@[0, 1] - NodePos_x@current@[1, 0] )**2 + ( NodePos_y@current@[0, 1] - NodePos_y@current@[1, 0] )**2 )
		Var d : Real = sqrt ( ( NodePos_x@current@[1, 1] - NodePos_x@current@[0, 1] )**2 + ( NodePos_y@current@[1, 1] - NodePos_y@current@[0, 1] )**2 )
		Var e : Real = sqrt ( ( NodePos_x@current@[1, 1] - NodePos_x@current@[1, 0] )**2 + ( NodePos_y@current@[1, 1] - NodePos_y@current@[1, 0] )**2 )
		CellVol_L@current = 0.25 * sqrt ( 4.0 * a**2 * b**2 - (a**2 + b**2 - c**2 )**2 )
		CellVol_U@current = 0.25 * sqrt ( 4.0 * d**2 * e**2 - (d**2 + e**2 - c**2 )**2 )
		CellVol@current = CellVol_L@current + CellVol_U@current
	}

	@(all but finest) {
		loop over CellVol@current sequentially {
			Var volFiner : Real = CellVol@finer@[0, 0] + CellVol@finer@[1, 0] + CellVol@finer@[0, 1] + CellVol@finer@[1, 1]
			Var volDif : Real = CellVol@current - volFiner
			if ( fabs ( volDif ) > 2.0e-1 * CellVol@current ) {
				print ( 'Volume dif on level', levels@current ( ), 'is', fabs ( volDif ) * 100.0 / CellVol@current, '%',
						'   should be', volFiner, 'but is', CellVol@current )
			}
		}
	}
}

Function InitLaplace@finest ( ) : Unit {
	// reset
	loop over Laplace@current {
		Laplace@current:[ 0,  0] = 0.0
		Laplace@current:[ 1,  0] = 0.0
		Laplace@current:[-1,  0] = 0.0
		Laplace@current:[ 0,  1] = 0.0
		Laplace@current:[ 0, -1] = 0.0
		Laplace@current:[ 1,  1] = 0.0
		Laplace@current:[ 1, -1] = 0.0
		Laplace@current:[-1,  1] = 0.0
		Laplace@current:[-1, -1] = 0.0
	}

	Val useSimpleInterpol : Boolean = false
	Val useRecipDist : Boolean = false
	Val useArea : Boolean = true
	Val useLaplacian : Boolean = false

	// east
	loop over Laplace@current sequentially {
		//Laplace@current:[ 1,  0] = -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current
		Var face_0_x : Real = NodePos_x@current@[1, 0] - NodePos_x@current@[1, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 0] - NodePos_y@current@[1, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_x@current@[1, 0] - CellCen_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_y@current@[1, 0] - CellCen_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace@current:[1, 0] -= faceLen * alpha / edgeLen
		Laplace@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[1, 0] += 0.25 * beta
			Laplace@current:[0, 1] += 0.25 * beta
			Laplace@current:[1, 1] += 0.25 * beta
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[1, 0] -= 0.25 * beta
			Laplace@current:[0, -1] -= 0.25 * beta
			Laplace@current:[1, -1] -= 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_SE_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_SE_E : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[1, 0] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[1, 0] )**2 )
			Var coeff_SE_S : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[0, -1] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[0, -1] )**2 )
			Var coeff_SE_SE : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[1, -1] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[1, -1] )**2 )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] -= coeff_SE_C * beta
			Laplace@current:[1, 0] -= coeff_SE_E * beta
			Laplace@current:[0, -1] -= coeff_SE_S * beta
			Laplace@current:[1, -1] -= coeff_SE_SE * beta

			Var coeff_NE_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_NE_E : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[1, 0] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[1, 0] )**2 )
			Var coeff_NE_N : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[0, 1] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[0, 1] )**2 )
			Var coeff_NE_NE : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[1, 1] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[1, 1] )**2 )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] += coeff_NE_C * beta
			Laplace@current:[1, 0] += coeff_NE_E * beta
			Laplace@current:[0, 1] += coeff_NE_N * beta
			Laplace@current:[1, 1] += coeff_NE_NE * beta
		} else if ( useArea ) {
			Var coeff_SE_C : Real = CellVol@current@[0, 0]
			Var coeff_SE_E : Real = CellVol@current@[1, 0]
			Var coeff_SE_S : Real = CellVol@current@[0, -1]
			Var coeff_SE_SE : Real = CellVol@current@[1, -1]

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] -= coeff_SE_C * beta
			Laplace@current:[1, 0] -= coeff_SE_E * beta
			Laplace@current:[0, -1] -= coeff_SE_S * beta
			Laplace@current:[1, -1] -= coeff_SE_SE * beta

			Var coeff_NE_C : Real = CellVol@current@[0, 0]
			Var coeff_NE_E : Real = CellVol@current@[1, 0]
			Var coeff_NE_N : Real = CellVol@current@[0, 1]
			Var coeff_NE_NE : Real = CellVol@current@[1, 1]

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] += coeff_NE_C * beta
			Laplace@current:[1, 0] += coeff_NE_E * beta
			Laplace@current:[0, 1] += coeff_NE_N * beta
			Laplace@current:[1, 1] += coeff_NE_NE * beta
		} else if ( useLaplacian ) {
			Val x0_SE : Real = NodePos_x@current@[1, 0]
			Val y0_SE : Real = NodePos_y@current@[1, 0]
			Val x1_SE : Real = CellCen_x@current@[0, 0]
			Val y1_SE : Real = CellCen_y@current@[0, 0]
			Val x2_SE : Real = CellCen_x@current@[1, 0]
			Val y2_SE : Real = CellCen_y@current@[1, 0]
			Val x3_SE : Real = CellCen_x@current@[0, -1]
			Val y3_SE : Real = CellCen_y@current@[0, -1]
			Val x4_SE : Real = CellCen_x@current@[1, -1]
			Val y4_SE : Real = CellCen_y@current@[1, -1]

			Var Rx_SE : Real = ( x1_SE - x0_SE ) + ( x2_SE - x0_SE ) + ( x3_SE - x0_SE ) + ( x4_SE - x0_SE )
			Var Ry_SE : Real = ( y1_SE - y0_SE ) + ( y2_SE - y0_SE ) + ( y3_SE - y0_SE ) + ( y4_SE - y0_SE )
			Var Ixx_SE : Real = ( x1_SE - x0_SE )**2 + ( x2_SE - x0_SE )**2 + ( x3_SE - x0_SE )**2 + ( x4_SE - x0_SE )**2
			Var Iyy_SE : Real = ( y1_SE - y0_SE )**2 + ( y2_SE - y0_SE )**2 + ( y3_SE - y0_SE )**2 + ( y4_SE - y0_SE )**2
			Var Ixy_SE : Real = ( x1_SE - x0_SE ) * ( y1_SE - y0_SE ) + ( x2_SE - x0_SE ) * ( y2_SE - y0_SE ) + ( x3_SE - x0_SE ) * ( y3_SE - y0_SE ) + ( x4_SE - x0_SE ) * ( y4_SE - y0_SE )

			Var lambda_SE_x : Real = ( Ixy_SE * Ry_SE - Iyy_SE * Rx_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )
			Var lambda_SE_y : Real = ( Ixy_SE * Rx_SE - Ixx_SE * Ry_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )

			Var coeff_SE_C : Real = 1.0 + lambda_SE_x * ( x1_SE - x0_SE ) + lambda_SE_y * ( y1_SE - y0_SE )
			Var coeff_SE_E : Real = 1.0 + lambda_SE_x * ( x2_SE - x0_SE ) + lambda_SE_y * ( y2_SE - y0_SE )
			Var coeff_SE_S : Real = 1.0 + lambda_SE_x * ( x3_SE - x0_SE ) + lambda_SE_y * ( y3_SE - y0_SE )
			Var coeff_SE_SE : Real = 1.0 + lambda_SE_x * ( x4_SE - x0_SE ) + lambda_SE_y * ( y4_SE - y0_SE )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] -= coeff_SE_C * beta
			Laplace@current:[1, 0] -= coeff_SE_E * beta
			Laplace@current:[0, -1] -= coeff_SE_S * beta
			Laplace@current:[1, -1] -= coeff_SE_SE * beta

			Val x0_NE : Real = NodePos_x@current@[1, 1]
			Val y0_NE : Real = NodePos_y@current@[1, 1]
			Val x1_NE : Real = CellCen_x@current@[0, 0]
			Val y1_NE : Real = CellCen_y@current@[0, 0]
			Val x2_NE : Real = CellCen_x@current@[1, 0]
			Val y2_NE : Real = CellCen_y@current@[1, 0]
			Val x3_NE : Real = CellCen_x@current@[0, 1]
			Val y3_NE : Real = CellCen_y@current@[0, 1]
			Val x4_NE : Real = CellCen_x@current@[1, 1]
			Val y4_NE : Real = CellCen_y@current@[1, 1]

			Var Rx_NE : Real = ( x1_NE - x0_NE ) + ( x2_NE - x0_NE ) + ( x3_NE - x0_NE ) + ( x4_NE - x0_NE )
			Var Ry_NE : Real = ( y1_NE - y0_NE ) + ( y2_NE - y0_NE ) + ( y3_NE - y0_NE ) + ( y4_NE - y0_NE )
			Var Ixx_NE : Real = ( x1_NE - x0_NE )**2 + ( x2_NE - x0_NE )**2 + ( x3_NE - x0_NE )**2 + ( x4_NE - x0_NE )**2
			Var Iyy_NE : Real = ( y1_NE - y0_NE )**2 + ( y2_NE - y0_NE )**2 + ( y3_NE - y0_NE )**2 + ( y4_NE - y0_NE )**2
			Var Ixy_NE : Real = ( x1_NE - x0_NE ) * ( y1_NE - y0_NE ) + ( x2_NE - x0_NE ) * ( y2_NE - y0_NE ) + ( x3_NE - x0_NE ) * ( y3_NE - y0_NE ) + ( x4_NE - x0_NE ) * ( y4_NE - y0_NE )

			Var lambda_NE_x : Real = ( Ixy_NE * Ry_NE - Iyy_NE * Rx_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )
			Var lambda_NE_y : Real = ( Ixy_NE * Rx_NE - Ixx_NE * Ry_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )

			Var coeff_NE_C : Real = 1.0 + lambda_NE_x * ( x1_NE - x0_NE ) + lambda_NE_y * ( y1_NE - y0_NE )
			Var coeff_NE_E : Real = 1.0 + lambda_NE_x * ( x2_NE - x0_NE ) + lambda_NE_y * ( y2_NE - y0_NE )
			Var coeff_NE_N : Real = 1.0 + lambda_NE_x * ( x3_NE - x0_NE ) + lambda_NE_y * ( y3_NE - y0_NE )
			Var coeff_NE_NE : Real = 1.0 + lambda_NE_x * ( x4_NE - x0_NE ) + lambda_NE_y * ( y4_NE - y0_NE )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] += coeff_NE_C * beta
			Laplace@current:[1, 0] += coeff_NE_E * beta
			Laplace@current:[0, 1] += coeff_NE_N * beta
			Laplace@current:[1, 1] += coeff_NE_NE * beta
		}

		/*if ( fabs ( alpha ) > 2.0 || fabs ( alpha ) < 0.5 ) {
			print ( 'Alpha at ', x, ';', y, ':', alpha )
		}
		if ( fabs ( beta ) > 0.5 ) {
			print ( 'Beta at ', x, ';', y, ':', beta )
		}*/
		/*if ( 1.0 != alpha + beta ) {
			print ( 'Alpha and beta at ', x, ';', y, ':', alpha, ';', beta )
		}*/

		//@finest {
			/*if ( 512 == x && 512 == y ) {
				print ( 'Node_x:	', NodePos_x@current@[0, 0], NodePos_x@current@[1, 0], NodePos_x@current@[0, 1], NodePos_x@current@[1, 1] )
				print ( 'Node_y:	', NodePos_y@current@[0, 0], NodePos_y@current@[1, 0], NodePos_y@current@[0, 1], NodePos_y@current@[1, 1] )
				print ( 'CellCen:   ', CellCen_x@current, CellCen_y@current )
				print ( 'Normal:	', norm_x, norm_y )
				print ( 'NormalLen: ', sqrt ( norm_x**2 + norm_y**2 ) )
				print ( 'Face:	  ', face_0_x, face_0_y )
				print ( 'Face_n:	', face_n_x, face_n_y )
				print ( 'Face_nLen: ', sqrt ( face_n_x**2 + face_n_y**2 ) )
				print ( 'Edge:	  ', edge_0_x, edge_0_y )
				print ( 'Coeff:	 ', Laplace@current:[ 1,  0] )
				print ( 'Should be: ', -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current )
			}*/
			/*if ( Laplace@current:[ 1,  0] != -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current ) {
				print ( 'Wrong entry on level', levels@current ( ), Laplace@current:[ 1,  0], 'should be', -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current )
			}*/
		//}
	}

	// west
	loop over Laplace@current {
		//Laplace@current:[-1,  0] = -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current
		Var face_0_x : Real = NodePos_x@current@[0, 1] - NodePos_x@current@[0, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 1] - NodePos_y@current@[0, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_x@current@[-1, 0] - CellCen_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_y@current@[-1, 0] - CellCen_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace@current:[-1, 0] -= faceLen * alpha / edgeLen
		Laplace@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[-1, 0] -= 0.25 * beta
			Laplace@current:[0, 1] -= 0.25 * beta
			Laplace@current:[-1, 1] -= 0.25 * beta

			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[-1, 0] += 0.25 * beta
			Laplace@current:[0, -1] += 0.25 * beta
			Laplace@current:[-1, -1] += 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_NW_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_NW_W : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[-1, 0] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[-1, 0] )**2 )
			Var coeff_NW_N : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[0, 1] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[0, 1] )**2 )
			Var coeff_NW_NW : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[-1, 1] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[-1, 1] )**2 )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] -= coeff_NW_C * beta
			Laplace@current:[-1, 0] -= coeff_NW_W * beta
			Laplace@current:[0, 1] -= coeff_NW_N * beta
			Laplace@current:[-1, 1] -= coeff_NW_NW * beta

			Var coeff_SW_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_SW_W : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[-1, 0] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[-1, 0] )**2 )
			Var coeff_SW_S : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[0, -1] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[0, -1] )**2 )
			Var coeff_SW_SW : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[-1, -1] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[-1, -1] )**2 )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] += coeff_SW_C * beta
			Laplace@current:[-1, 0] += coeff_SW_W * beta
			Laplace@current:[0, -1] += coeff_SW_S * beta
			Laplace@current:[-1, -1] += coeff_SW_SW * beta
		} else if ( useArea ) {
			Var coeff_NW_C : Real = CellVol@current@[0, 0]
			Var coeff_NW_W : Real = CellVol@current@[-1, 0]
			Var coeff_NW_N : Real = CellVol@current@[0, 1]
			Var coeff_NW_NW : Real = CellVol@current@[-1, 1]

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] -= coeff_NW_C * beta
			Laplace@current:[-1, 0] -= coeff_NW_W * beta
			Laplace@current:[0, 1] -= coeff_NW_N * beta
			Laplace@current:[-1, 1] -= coeff_NW_NW * beta

			Var coeff_SW_C : Real = CellVol@current@[0, 0]
			Var coeff_SW_W : Real = CellVol@current@[-1, 0]
			Var coeff_SW_S : Real = CellVol@current@[0, -1]
			Var coeff_SW_SW : Real = CellVol@current@[-1, -1]

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] += coeff_SW_C * beta
			Laplace@current:[-1, 0] += coeff_SW_W * beta
			Laplace@current:[0, -1] += coeff_SW_S * beta
			Laplace@current:[-1, -1] += coeff_SW_SW * beta
		} else if ( useLaplacian ) {
			Val x0_NW : Real = NodePos_x@current@[-1, 1]
			Val y0_NW : Real = NodePos_y@current@[-1, 1]
			Val x1_NW : Real = CellCen_x@current@[0, 0]
			Val y1_NW : Real = CellCen_y@current@[0, 0]
			Val x2_NW : Real = CellCen_x@current@[-1, 0]
			Val y2_NW : Real = CellCen_y@current@[-1, 0]
			Val x3_NW : Real = CellCen_x@current@[0, 1]
			Val y3_NW : Real = CellCen_y@current@[0, 1]
			Val x4_NW : Real = CellCen_x@current@[-1, 1]
			Val y4_NW : Real = CellCen_y@current@[-1, 1]

			Var Rx_NW : Real = ( x1_NW - x0_NW ) + ( x2_NW - x0_NW ) + ( x3_NW - x0_NW ) + ( x4_NW - x0_NW )
			Var Ry_NW : Real = ( y1_NW - y0_NW ) + ( y2_NW - y0_NW ) + ( y3_NW - y0_NW ) + ( y4_NW - y0_NW )
			Var Ixx_NW : Real = ( x1_NW - x0_NW )**2 + ( x2_NW - x0_NW )**2 + ( x3_NW - x0_NW )**2 + ( x4_NW - x0_NW )**2
			Var Iyy_NW : Real = ( y1_NW - y0_NW )**2 + ( y2_NW - y0_NW )**2 + ( y3_NW - y0_NW )**2 + ( y4_NW - y0_NW )**2
			Var Ixy_NW : Real = ( x1_NW - x0_NW ) * ( y1_NW - y0_NW ) + ( x2_NW - x0_NW ) * ( y2_NW - y0_NW ) + ( x3_NW - x0_NW ) * ( y3_NW - y0_NW ) + ( x4_NW - x0_NW ) * ( y4_NW - y0_NW )

			Var lambda_NW_x : Real = ( Ixy_NW * Ry_NW - Iyy_NW * Rx_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )
			Var lambda_NW_y : Real = ( Ixy_NW * Rx_NW - Ixx_NW * Ry_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )

			Var coeff_NW_C : Real = 1.0 + lambda_NW_x * ( x1_NW - x0_NW ) + lambda_NW_y * ( y1_NW - y0_NW )
			Var coeff_NW_W : Real = 1.0 + lambda_NW_x * ( x2_NW - x0_NW ) + lambda_NW_y * ( y2_NW - y0_NW )
			Var coeff_NW_N : Real = 1.0 + lambda_NW_x * ( x3_NW - x0_NW ) + lambda_NW_y * ( y3_NW - y0_NW )
			Var coeff_NW_NW : Real = 1.0 + lambda_NW_x * ( x4_NW - x0_NW ) + lambda_NW_y * ( y4_NW - y0_NW )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] -= coeff_NW_C * beta
			Laplace@current:[-1, 0] -= coeff_NW_W * beta
			Laplace@current:[0, 1] -= coeff_NW_N * beta
			Laplace@current:[-1, 1] -= coeff_NW_NW * beta

			Val x0_SW : Real = NodePos_x@current@[-1, 0]
			Val y0_SW : Real = NodePos_y@current@[-1, 0]
			Val x1_SW : Real = CellCen_x@current@[0, 0]
			Val y1_SW : Real = CellCen_y@current@[0, 0]
			Val x2_SW : Real = CellCen_x@current@[-1, 0]
			Val y2_SW : Real = CellCen_y@current@[-1, 0]
			Val x3_SW : Real = CellCen_x@current@[0, -1]
			Val y3_SW : Real = CellCen_y@current@[0, -1]
			Val x4_SW : Real = CellCen_x@current@[-1, -1]
			Val y4_SW : Real = CellCen_y@current@[-1, -1]

			Var Rx_SW : Real = ( x1_SW - x0_SW ) + ( x2_SW - x0_SW ) + ( x3_SW - x0_SW ) + ( x4_SW - x0_SW )
			Var Ry_SW : Real = ( y1_SW - y0_SW ) + ( y2_SW - y0_SW ) + ( y3_SW - y0_SW ) + ( y4_SW - y0_SW )
			Var Ixx_SW : Real = ( x1_SW - x0_SW )**2 + ( x2_SW - x0_SW )**2 + ( x3_SW - x0_SW )**2 + ( x4_SW - x0_SW )**2
			Var Iyy_SW : Real = ( y1_SW - y0_SW )**2 + ( y2_SW - y0_SW )**2 + ( y3_SW - y0_SW )**2 + ( y4_SW - y0_SW )**2
			Var Ixy_SW : Real = ( x1_SW - x0_SW ) * ( y1_SW - y0_SW ) + ( x2_SW - x0_SW ) * ( y2_SW - y0_SW ) + ( x3_SW - x0_SW ) * ( y3_SW - y0_SW ) + ( x4_SW - x0_SW ) * ( y4_SW - y0_SW )

			Var lambda_SW_x : Real = ( Ixy_SW * Ry_SW - Iyy_SW * Rx_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )
			Var lambda_SW_y : Real = ( Ixy_SW * Rx_SW - Ixx_SW * Ry_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )

			Var coeff_SW_C : Real = 1.0 + lambda_SW_x * ( x1_SW - x0_SW ) + lambda_SW_y * ( y1_SW - y0_SW )
			Var coeff_SW_W : Real = 1.0 + lambda_SW_x * ( x2_SW - x0_SW ) + lambda_SW_y * ( y2_SW - y0_SW )
			Var coeff_SW_S : Real = 1.0 + lambda_SW_x * ( x3_SW - x0_SW ) + lambda_SW_y * ( y3_SW - y0_SW )
			Var coeff_SW_SW : Real = 1.0 + lambda_SW_x * ( x4_SW - x0_SW ) + lambda_SW_y * ( y4_SW - y0_SW )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] += coeff_SW_C * beta
			Laplace@current:[-1, 0] += coeff_SW_W * beta
			Laplace@current:[0, -1] += coeff_SW_S * beta
			Laplace@current:[-1, -1] += coeff_SW_SW * beta
		}
	}

	// north
	loop over Laplace@current {
		//Laplace@current:[ 0,  1] = -1.0 * vf_cellWidth_x@current / vf_cellWidth_y@current
		Var face_0_x : Real = NodePos_x@current@[1, 1] - NodePos_x@current@[0, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 1] - NodePos_y@current@[0, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_x@current@[0, 1] - CellCen_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_y@current@[0, 1] - CellCen_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace@current:[0, 1] -= faceLen * alpha / edgeLen
		Laplace@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[0, 1] -= 0.25 * beta
			Laplace@current:[1, 0] -= 0.25 * beta
			Laplace@current:[1, 1] -= 0.25 * beta

			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[0, 1] += 0.25 * beta
			Laplace@current:[-1, 0] += 0.25 * beta
			Laplace@current:[-1, 1] += 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_NE_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_NE_E : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[1, 0] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[1, 0] )**2 )
			Var coeff_NE_N : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[0, 1] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[0, 1] )**2 )
			Var coeff_NE_NE : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 1] - CellCen_x@current@[1, 1] )**2 + ( NodePos_y@current@[1, 1] - CellCen_y@current@[1, 1] )**2 )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] -= coeff_NE_C * beta
			Laplace@current:[1, 0] -= coeff_NE_E * beta
			Laplace@current:[0, 1] -= coeff_NE_N * beta
			Laplace@current:[1, 1] -= coeff_NE_NE * beta

			Var coeff_NW_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_NW_W : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[-1, 0] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[-1, 0] )**2 )
			Var coeff_NW_N : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[0, 1] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[0, 1] )**2 )
			Var coeff_NW_NW : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[-1, 1] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[-1, 1] )**2 )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] += coeff_NW_C * beta
			Laplace@current:[-1, 0] += coeff_NW_W * beta
			Laplace@current:[0, 1] += coeff_NW_N * beta
			Laplace@current:[-1, 1] += coeff_NW_NW * beta
		} else if ( useArea ) {
			Var coeff_NE_C : Real = CellVol@current@[0, 0]
			Var coeff_NE_E : Real = CellVol@current@[1, 0]
			Var coeff_NE_N : Real = CellVol@current@[0, 1]
			Var coeff_NE_NE : Real = CellVol@current@[1, 1]

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] -= coeff_NE_C * beta
			Laplace@current:[1, 0] -= coeff_NE_E * beta
			Laplace@current:[0, 1] -= coeff_NE_N * beta
			Laplace@current:[1, 1] -= coeff_NE_NE * beta

			Var coeff_NW_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_NW_W : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[-1, 0] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[-1, 0] )**2 )
			Var coeff_NW_N : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[0, 1] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[0, 1] )**2 )
			Var coeff_NW_NW : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 1] - CellCen_x@current@[-1, 1] )**2 + ( NodePos_y@current@[-1, 1] - CellCen_y@current@[-1, 1] )**2 )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] += coeff_NW_C * beta
			Laplace@current:[-1, 0] += coeff_NW_W * beta
			Laplace@current:[0, 1] += coeff_NW_N * beta
			Laplace@current:[-1, 1] += coeff_NW_NW * beta
		} else if ( useLaplacian ) {
			Val x0_NE : Real = NodePos_x@current@[1, 1]
			Val y0_NE : Real = NodePos_y@current@[1, 1]
			Val x1_NE : Real = CellCen_x@current@[0, 0]
			Val y1_NE : Real = CellCen_y@current@[0, 0]
			Val x2_NE : Real = CellCen_x@current@[1, 0]
			Val y2_NE : Real = CellCen_y@current@[1, 0]
			Val x3_NE : Real = CellCen_x@current@[0, 1]
			Val y3_NE : Real = CellCen_y@current@[0, 1]
			Val x4_NE : Real = CellCen_x@current@[1, 1]
			Val y4_NE : Real = CellCen_y@current@[1, 1]

			Var Rx_NE : Real = ( x1_NE - x0_NE ) + ( x2_NE - x0_NE ) + ( x3_NE - x0_NE ) + ( x4_NE - x0_NE )
			Var Ry_NE : Real = ( y1_NE - y0_NE ) + ( y2_NE - y0_NE ) + ( y3_NE - y0_NE ) + ( y4_NE - y0_NE )
			Var Ixx_NE : Real = ( x1_NE - x0_NE )**2 + ( x2_NE - x0_NE )**2 + ( x3_NE - x0_NE )**2 + ( x4_NE - x0_NE )**2
			Var Iyy_NE : Real = ( y1_NE - y0_NE )**2 + ( y2_NE - y0_NE )**2 + ( y3_NE - y0_NE )**2 + ( y4_NE - y0_NE )**2
			Var Ixy_NE : Real = ( x1_NE - x0_NE ) * ( y1_NE - y0_NE ) + ( x2_NE - x0_NE ) * ( y2_NE - y0_NE ) + ( x3_NE - x0_NE ) * ( y3_NE - y0_NE ) + ( x4_NE - x0_NE ) * ( y4_NE - y0_NE )

			Var lambda_NE_x : Real = ( Ixy_NE * Ry_NE - Iyy_NE * Rx_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )
			Var lambda_NE_y : Real = ( Ixy_NE * Rx_NE - Ixx_NE * Ry_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )

			Var coeff_NE_C : Real = 1.0 + lambda_NE_x * ( x1_NE - x0_NE ) + lambda_NE_y * ( y1_NE - y0_NE )
			Var coeff_NE_E : Real = 1.0 + lambda_NE_x * ( x2_NE - x0_NE ) + lambda_NE_y * ( y2_NE - y0_NE )
			Var coeff_NE_N : Real = 1.0 + lambda_NE_x * ( x3_NE - x0_NE ) + lambda_NE_y * ( y3_NE - y0_NE )
			Var coeff_NE_NE : Real = 1.0 + lambda_NE_x * ( x4_NE - x0_NE ) + lambda_NE_y * ( y4_NE - y0_NE )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] -= coeff_NE_C * beta
			Laplace@current:[1, 0] -= coeff_NE_E * beta
			Laplace@current:[0, 1] -= coeff_NE_N * beta
			Laplace@current:[1, 1] -= coeff_NE_NE * beta

			Val x0_NW : Real = NodePos_x@current@[-1, 1]
			Val y0_NW : Real = NodePos_y@current@[-1, 1]
			Val x1_NW : Real = CellCen_x@current@[0, 0]
			Val y1_NW : Real = CellCen_y@current@[0, 0]
			Val x2_NW : Real = CellCen_x@current@[-1, 0]
			Val y2_NW : Real = CellCen_y@current@[-1, 0]
			Val x3_NW : Real = CellCen_x@current@[0, 1]
			Val y3_NW : Real = CellCen_y@current@[0, 1]
			Val x4_NW : Real = CellCen_x@current@[-1, 1]
			Val y4_NW : Real = CellCen_y@current@[-1, 1]

			Var Rx_NW : Real = ( x1_NW - x0_NW ) + ( x2_NW - x0_NW ) + ( x3_NW - x0_NW ) + ( x4_NW - x0_NW )
			Var Ry_NW : Real = ( y1_NW - y0_NW ) + ( y2_NW - y0_NW ) + ( y3_NW - y0_NW ) + ( y4_NW - y0_NW )
			Var Ixx_NW : Real = ( x1_NW - x0_NW )**2 + ( x2_NW - x0_NW )**2 + ( x3_NW - x0_NW )**2 + ( x4_NW - x0_NW )**2
			Var Iyy_NW : Real = ( y1_NW - y0_NW )**2 + ( y2_NW - y0_NW )**2 + ( y3_NW - y0_NW )**2 + ( y4_NW - y0_NW )**2
			Var Ixy_NW : Real = ( x1_NW - x0_NW ) * ( y1_NW - y0_NW ) + ( x2_NW - x0_NW ) * ( y2_NW - y0_NW ) + ( x3_NW - x0_NW ) * ( y3_NW - y0_NW ) + ( x4_NW - x0_NW ) * ( y4_NW - y0_NW )

			Var lambda_NW_x : Real = ( Ixy_NW * Ry_NW - Iyy_NW * Rx_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )
			Var lambda_NW_y : Real = ( Ixy_NW * Rx_NW - Ixx_NW * Ry_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )

			Var coeff_NW_C : Real = 1.0 + lambda_NW_x * ( x1_NW - x0_NW ) + lambda_NW_y * ( y1_NW - y0_NW )
			Var coeff_NW_W : Real = 1.0 + lambda_NW_x * ( x2_NW - x0_NW ) + lambda_NW_y * ( y2_NW - y0_NW )
			Var coeff_NW_N : Real = 1.0 + lambda_NW_x * ( x3_NW - x0_NW ) + lambda_NW_y * ( y3_NW - y0_NW )
			Var coeff_NW_NW : Real = 1.0 + lambda_NW_x * ( x4_NW - x0_NW ) + lambda_NW_y * ( y4_NW - y0_NW )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] += coeff_NW_C * beta
			Laplace@current:[-1, 0] += coeff_NW_W * beta
			Laplace@current:[0, 1] += coeff_NW_N * beta
			Laplace@current:[-1, 1] += coeff_NW_NW * beta
		}
	}

	// south
	loop over Laplace@current {
		//Laplace@current:[ 0, -1] = -1.0 * vf_cellWidth_x@current / vf_cellWidth_y@current
		Var face_0_x : Real = NodePos_x@current@[0, 0] - NodePos_x@current@[1, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 0] - NodePos_y@current@[1, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_x@current@[0, -1] - CellCen_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_y@current@[0, -1] - CellCen_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace@current:[0, -1] -= faceLen * alpha / edgeLen
		Laplace@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[0, -1] -= 0.25 * beta
			Laplace@current:[-1, 0] -= 0.25 * beta
			Laplace@current:[-1, -1] -= 0.25 * beta

			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[0, -1] += 0.25 * beta
			Laplace@current:[1, 0] += 0.25 * beta
			Laplace@current:[1, -1] += 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_SW_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_SW_W : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[-1, 0] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[-1, 0] )**2 )
			Var coeff_SW_S : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[0, -1] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[0, -1] )**2 )
			Var coeff_SW_SW : Real = 1.0 / sqrt ( ( NodePos_x@current@[-1, 0] - CellCen_x@current@[-1, -1] )**2 + ( NodePos_y@current@[-1, 0] - CellCen_y@current@[-1, -1] )**2 )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] -= coeff_SW_C * beta
			Laplace@current:[-1, 0] -= coeff_SW_W * beta
			Laplace@current:[0, -1] -= coeff_SW_S * beta
			Laplace@current:[-1, -1] -= coeff_SW_SW * beta

			Var coeff_SE_C : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[0, 0] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[0, 0] )**2 )
			Var coeff_SE_E : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[1, 0] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[1, 0] )**2 )
			Var coeff_SE_S : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[0, -1] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[0, -1] )**2 )
			Var coeff_SE_SE : Real = 1.0 / sqrt ( ( NodePos_x@current@[1, 0] - CellCen_x@current@[1, -1] )**2 + ( NodePos_y@current@[1, 0] - CellCen_y@current@[1, -1] )**2 )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] += coeff_SE_C * beta
			Laplace@current:[1, 0] += coeff_SE_E * beta
			Laplace@current:[0, -1] += coeff_SE_S * beta
			Laplace@current:[1, -1] += coeff_SE_SE * beta
		} else if ( useArea ) {
			Var coeff_SW_C : Real = CellVol@current@[0, 0]
			Var coeff_SW_W : Real = CellVol@current@[-1, 0]
			Var coeff_SW_S : Real = CellVol@current@[0, -1]
			Var coeff_SW_SW : Real = CellVol@current@[-1, -1]

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] -= coeff_SW_C * beta
			Laplace@current:[-1, 0] -= coeff_SW_W * beta
			Laplace@current:[0, -1] -= coeff_SW_S * beta
			Laplace@current:[-1, -1] -= coeff_SW_SW * beta

			Var coeff_SE_C : Real = CellVol@current@[0, 0]
			Var coeff_SE_E : Real = CellVol@current@[1, 0]
			Var coeff_SE_S : Real = CellVol@current@[0, -1]
			Var coeff_SE_SE : Real = CellVol@current@[1, -1]

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] += coeff_SE_C * beta
			Laplace@current:[1, 0] += coeff_SE_E * beta
			Laplace@current:[0, -1] += coeff_SE_S * beta
			Laplace@current:[1, -1] += coeff_SE_SE * beta
		} else if ( useLaplacian ) {
			Val x0_SW : Real = NodePos_x@current@[-1, 0]
			Val y0_SW : Real = NodePos_y@current@[-1, 0]
			Val x1_SW : Real = CellCen_x@current@[0, 0]
			Val y1_SW : Real = CellCen_y@current@[0, 0]
			Val x2_SW : Real = CellCen_x@current@[-1, 0]
			Val y2_SW : Real = CellCen_y@current@[-1, 0]
			Val x3_SW : Real = CellCen_x@current@[0, -1]
			Val y3_SW : Real = CellCen_y@current@[0, -1]
			Val x4_SW : Real = CellCen_x@current@[-1, -1]
			Val y4_SW : Real = CellCen_y@current@[-1, -1]

			Var Rx_SW : Real = ( x1_SW - x0_SW ) + ( x2_SW - x0_SW ) + ( x3_SW - x0_SW ) + ( x4_SW - x0_SW )
			Var Ry_SW : Real = ( y1_SW - y0_SW ) + ( y2_SW - y0_SW ) + ( y3_SW - y0_SW ) + ( y4_SW - y0_SW )
			Var Ixx_SW : Real = ( x1_SW - x0_SW )**2 + ( x2_SW - x0_SW )**2 + ( x3_SW - x0_SW )**2 + ( x4_SW - x0_SW )**2
			Var Iyy_SW : Real = ( y1_SW - y0_SW )**2 + ( y2_SW - y0_SW )**2 + ( y3_SW - y0_SW )**2 + ( y4_SW - y0_SW )**2
			Var Ixy_SW : Real = ( x1_SW - x0_SW ) * ( y1_SW - y0_SW ) + ( x2_SW - x0_SW ) * ( y2_SW - y0_SW ) + ( x3_SW - x0_SW ) * ( y3_SW - y0_SW ) + ( x4_SW - x0_SW ) * ( y4_SW - y0_SW )

			Var lambda_SW_x : Real = ( Ixy_SW * Ry_SW - Iyy_SW * Rx_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )
			Var lambda_SW_y : Real = ( Ixy_SW * Rx_SW - Ixx_SW * Ry_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )

			Var coeff_SW_C : Real = 1.0 + lambda_SW_x * ( x1_SW - x0_SW ) + lambda_SW_y * ( y1_SW - y0_SW )
			Var coeff_SW_W : Real = 1.0 + lambda_SW_x * ( x2_SW - x0_SW ) + lambda_SW_y * ( y2_SW - y0_SW )
			Var coeff_SW_S : Real = 1.0 + lambda_SW_x * ( x3_SW - x0_SW ) + lambda_SW_y * ( y3_SW - y0_SW )
			Var coeff_SW_SW : Real = 1.0 + lambda_SW_x * ( x4_SW - x0_SW ) + lambda_SW_y * ( y4_SW - y0_SW )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] -= coeff_SW_C * beta
			Laplace@current:[-1, 0] -= coeff_SW_W * beta
			Laplace@current:[0, -1] -= coeff_SW_S * beta
			Laplace@current:[-1, -1] -= coeff_SW_SW * beta

			Val x0_SE : Real = NodePos_x@current@[1, 0]
			Val y0_SE : Real = NodePos_y@current@[1, 0]
			Val x1_SE : Real = CellCen_x@current@[0, 0]
			Val y1_SE : Real = CellCen_y@current@[0, 0]
			Val x2_SE : Real = CellCen_x@current@[1, 0]
			Val y2_SE : Real = CellCen_y@current@[1, 0]
			Val x3_SE : Real = CellCen_x@current@[0, -1]
			Val y3_SE : Real = CellCen_y@current@[0, -1]
			Val x4_SE : Real = CellCen_x@current@[1, -1]
			Val y4_SE : Real = CellCen_y@current@[1, -1]

			Var Rx_SE : Real = ( x1_SE - x0_SE ) + ( x2_SE - x0_SE ) + ( x3_SE - x0_SE ) + ( x4_SE - x0_SE )
			Var Ry_SE : Real = ( y1_SE - y0_SE ) + ( y2_SE - y0_SE ) + ( y3_SE - y0_SE ) + ( y4_SE - y0_SE )
			Var Ixx_SE : Real = ( x1_SE - x0_SE )**2 + ( x2_SE - x0_SE )**2 + ( x3_SE - x0_SE )**2 + ( x4_SE - x0_SE )**2
			Var Iyy_SE : Real = ( y1_SE - y0_SE )**2 + ( y2_SE - y0_SE )**2 + ( y3_SE - y0_SE )**2 + ( y4_SE - y0_SE )**2
			Var Ixy_SE : Real = ( x1_SE - x0_SE ) * ( y1_SE - y0_SE ) + ( x2_SE - x0_SE ) * ( y2_SE - y0_SE ) + ( x3_SE - x0_SE ) * ( y3_SE - y0_SE ) + ( x4_SE - x0_SE ) * ( y4_SE - y0_SE )

			Var lambda_SE_x : Real = ( Ixy_SE * Ry_SE - Iyy_SE * Rx_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )
			Var lambda_SE_y : Real = ( Ixy_SE * Rx_SE - Ixx_SE * Ry_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )

			Var coeff_SE_C : Real = 1.0 + lambda_SE_x * ( x1_SE - x0_SE ) + lambda_SE_y * ( y1_SE - y0_SE )
			Var coeff_SE_E : Real = 1.0 + lambda_SE_x * ( x2_SE - x0_SE ) + lambda_SE_y * ( y2_SE - y0_SE )
			Var coeff_SE_S : Real = 1.0 + lambda_SE_x * ( x3_SE - x0_SE ) + lambda_SE_y * ( y3_SE - y0_SE )
			Var coeff_SE_SE : Real = 1.0 + lambda_SE_x * ( x4_SE - x0_SE ) + lambda_SE_y * ( y4_SE - y0_SE )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] += coeff_SE_C * beta
			Laplace@current:[1, 0] += coeff_SE_E * beta
			Laplace@current:[0, -1] += coeff_SE_S * beta
			Laplace@current:[1, -1] += coeff_SE_SE * beta
		}
	}

	// center
	loop over Laplace@current sequentially {
		//Laplace@current:[ 0,  0] = -1.0 * ( Laplace@current:[ 1,  0] + Laplace@current:[-1,  0] + Laplace@current:[ 0,  1] + Laplace@current:[ 0, -1] )

		if ( ( 512 == x && 512 == y ) ||
			fabs ( Laplace@current:[ 0,  0] ) > 5.0 || fabs ( Laplace@current:[ 0,  0] ) < 3.0
			|| fabs ( 
				Laplace@current:[ 0,  0]
				+ Laplace@current:[ 1,  0]
				+ Laplace@current:[-1,  0]
				+ Laplace@current:[ 0,  1]
				+ Laplace@current:[ 0, -1]
				+ Laplace@current:[ 1,  1]
				+ Laplace@current:[ 1, -1]
				+ Laplace@current:[-1,  1]
				+ Laplace@current:[-1, -1] ) > 1e-6 ) {
			print ( 'Stencil at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace@current:[ 0,  0] )
			print ( '  [ 1,  0]', '=>', Laplace@current:[ 1,  0] )
			print ( '  [-1,  0]', '=>', Laplace@current:[-1,  0] )
			print ( '  [ 0,  1]', '=>', Laplace@current:[ 0,  1] )
			print ( '  [ 0, -1]', '=>', Laplace@current:[ 0, -1] )
			print ( '  [ 1,  1]', '=>', Laplace@current:[ 1,  1] )
			print ( '  [ 1, -1]', '=>', Laplace@current:[ 1, -1] )
			print ( '  [-1,  1]', '=>', Laplace@current:[-1,  1] )
			print ( '  [-1, -1]', '=>', Laplace@current:[-1, -1] )
		}
	}
}

Function InitLaplace_Tri@all ( ) : Unit {
	// reset
	loop over Laplace_L_L@current {
		Laplace_L_L@current:[ 0,  0] = 0.0

		/*Laplace_L_L@current:[-1,  0] = 0.0
		Laplace_L_L@current:[ 1,  0] = 0.0
		Laplace_L_L@current:[ 0, -1] = 0.0
		Laplace_L_L@current:[ 0,  1] = 0.0
		Laplace_L_L@current:[-1,  1] = 0.0
		Laplace_L_L@current:[ 1, -1] = 0.0*/
	}

	loop over Laplace_L_U@current {
		Laplace_L_U@current:[ 0,  0] = 0.0
		Laplace_L_U@current:[-1,  0] = 0.0
		Laplace_L_U@current:[ 0, -1] = 0.0

		/*Laplace_L_U@current:[-1,  1] = 0.0
		Laplace_L_U@current:[-1, -1] = 0.0
		Laplace_L_U@current:[ 1, -1] = 0.0*/
	}

	loop over Laplace_U_U@current {
		Laplace_U_U@current:[ 0,  0] = 0.0

		/*Laplace_U_U@current:[-1,  0] = 0.0
		Laplace_U_U@current:[ 1,  0] = 0.0
		Laplace_U_U@current:[ 0, -1] = 0.0
		Laplace_U_U@current:[ 0,  1] = 0.0
		Laplace_U_U@current:[-1,  1] = 0.0
		Laplace_U_U@current:[ 1, -1] = 0.0*/
	}

	loop over Laplace_U_L@current {
		Laplace_U_L@current:[ 0,  0] = 0.0
		Laplace_U_L@current:[ 1,  0] = 0.0
		Laplace_U_L@current:[ 0,  1] = 0.0

		/*Laplace_U_L@current:[-1,  1] = 0.0
		Laplace_U_L@current:[ 1,  1] = 0.0
		Laplace_U_L@current:[ 1, -1] = 0.0*/
	}

	Val useSimpleInterpol : Boolean = false
	Val useRecipDist : Boolean = false
	Val useArea : Boolean = false
	Val useLaplacian : Boolean = false

	// lower west
	loop over Laplace_L_L@current {
		Var face_0_x : Real = NodePos_x@current@[0, 1] - NodePos_x@current@[0, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 1] - NodePos_y@current@[0, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_U_x@current@[-1, 0] - CellCen_L_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_U_y@current@[-1, 0] - CellCen_L_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_L_U@current:[-1, 0] -= faceLen * alpha / edgeLen
		Laplace_L_L@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace_L_L@current:[0, 0] -= beta / 6.0
			Laplace_L_U@current:[0, 0] -= beta / 6.0
			Laplace_L_U@current:[-1, 0] -= beta / 6.0
			Laplace_L_L@current:[0, 1] -= beta / 6.0
			Laplace_L_L@current:[-1, 1] -= beta / 6.0
			Laplace_L_U@current:[-1, 1] -= beta / 6.0

			Laplace_L_L@current:[0, 0] += beta / 6.0
			Laplace_L_L@current:[-1, 0] += beta / 6.0
			Laplace_L_U@current:[-1, 0] += beta / 6.0
			Laplace_L_L@current:[0, -1] += beta / 6.0
			Laplace_L_U@current:[0, -1] += beta / 6.0
			Laplace_L_U@current:[-1, -1] += beta / 6.0
		}
	}

	// lower south
	loop over Laplace_L_L@current {
		Var face_0_x : Real = NodePos_x@current@[0, 0] - NodePos_x@current@[1, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 0] - NodePos_y@current@[1, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_U_x@current@[0, -1] - CellCen_L_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_U_y@current@[0, -1] - CellCen_L_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_L_U@current:[0, -1] -= faceLen * alpha / edgeLen
		Laplace_L_L@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace_L_L@current:[0, 0] -= beta / 6.0
			Laplace_L_L@current:[-1, 0] -= beta / 6.0
			Laplace_L_U@current:[-1, 0] -= beta / 6.0
			Laplace_L_L@current:[0, -1] -= beta / 6.0
			Laplace_L_U@current:[0, -1] -= beta / 6.0
			Laplace_L_U@current:[-1, -1] -= beta / 6.0

			Laplace_L_L@current:[0, 0] += beta / 6.0
			Laplace_L_U@current:[0, 0] += beta / 6.0
			Laplace_L_L@current:[1, 0] += beta / 6.0
			Laplace_L_U@current:[0, -1] += beta / 6.0
			Laplace_L_L@current:[1, -1] += beta / 6.0
			Laplace_L_U@current:[1, -1] += beta / 6.0
		}
	}

	// lower diagonal
	loop over Laplace_L_L@current {
		Var face_0_x : Real = NodePos_x@current@[1, 0] - NodePos_x@current@[0, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 0] - NodePos_y@current@[0, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_U_x@current@[0, 0] - CellCen_L_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_U_y@current@[0, 0] - CellCen_L_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_L_U@current:[0, 0] -= faceLen * alpha / edgeLen
		Laplace_L_L@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace_L_L@current:[0, 0] -= beta / 6.0
			Laplace_L_U@current:[0, 0] -= beta / 6.0
			Laplace_L_L@current:[1, 0] -= beta / 6.0
			Laplace_L_U@current:[0, -1] -= beta / 6.0
			Laplace_L_L@current:[1, -1] -= beta / 6.0
			Laplace_L_U@current:[1, -1] -= beta / 6.0

			Laplace_L_L@current:[0, 0] += beta / 6.0
			Laplace_L_U@current:[0, 0] += beta / 6.0
			Laplace_L_U@current:[-1, 0] += beta / 6.0
			Laplace_L_L@current:[0, 1] += beta / 6.0
			Laplace_L_L@current:[-1, 1] += beta / 6.0
			Laplace_L_U@current:[-1, 1] += beta / 6.0
		}
	}

	// upper east
	loop over Laplace_U_U@current {
		Var face_0_x : Real = NodePos_x@current@[1, 0] - NodePos_x@current@[1, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 0] - NodePos_y@current@[1, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_L_x@current@[1, 0] - CellCen_U_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_L_y@current@[1, 0] - CellCen_U_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_U_L@current:[1, 0] -= faceLen * alpha / edgeLen
		Laplace_U_U@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace_U_L@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[0, 0] -= beta / 6.0
			Laplace_U_L@current:[1, 0] -= beta / 6.0
			Laplace_U_U@current:[0, -1] -= beta / 6.0
			Laplace_U_L@current:[1, -1] -= beta / 6.0
			Laplace_U_U@current:[1, -1] -= beta / 6.0

			Laplace_U_U@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[1, 0] += beta / 6.0
			Laplace_U_L@current:[1, 0] += beta / 6.0
			Laplace_U_U@current:[0, 1] += beta / 6.0
			Laplace_U_L@current:[0, 1] += beta / 6.0
			Laplace_U_L@current:[1, 1] += beta / 6.0
		}
	}

	// upper north
	loop over Laplace_U_U@current {
		Var face_0_x : Real = NodePos_x@current@[1, 1] - NodePos_x@current@[0, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 1] - NodePos_y@current@[0, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_L_x@current@[0, 1] - CellCen_U_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_L_y@current@[0, 1] - CellCen_U_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_U_L@current:[0, 1] -= faceLen * alpha / edgeLen
		Laplace_U_U@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace_U_U@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[1, 0] -= beta / 6.0
			Laplace_U_L@current:[1, 0] -= beta / 6.0
			Laplace_U_U@current:[0, 1] -= beta / 6.0
			Laplace_U_L@current:[0, 1] -= beta / 6.0
			Laplace_U_L@current:[1, 1] -= beta / 6.0

			Laplace_U_L@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[-1, 0] += beta / 6.0
			Laplace_U_L@current:[0, 1] += beta / 6.0
			Laplace_U_L@current:[-1, 1] += beta / 6.0
			Laplace_U_U@current:[-1, 1] += beta / 6.0
		}
	}

	// upper diag
	loop over Laplace_U_U@current {
		Var face_0_x : Real = NodePos_x@current@[0, 1] - NodePos_x@current@[1, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 1] - NodePos_y@current@[1, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_L_x@current@[0, 0] - CellCen_U_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_L_y@current@[0, 0] - CellCen_U_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_U_L@current:[0, 0] -= faceLen * alpha / edgeLen
		Laplace_U_U@current:[0, 0] += faceLen * alpha / edgeLen

		if ( useSimpleInterpol ) {
			Laplace_U_L@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[-1, 0] -= beta / 6.0
			Laplace_U_L@current:[0, 1] -= beta / 6.0
			Laplace_U_L@current:[-1, 1] -= beta / 6.0
			Laplace_U_U@current:[-1, 1] -= beta / 6.0

			Laplace_U_L@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[0, 0] += beta / 6.0
			Laplace_U_L@current:[1, 0] += beta / 6.0
			Laplace_U_U@current:[0, -1] += beta / 6.0
			Laplace_U_L@current:[1, -1] += beta / 6.0
			Laplace_U_U@current:[1, -1] += beta / 6.0
		}
	}

	loop over Laplace_L_L@current {
		if ( 512 == x && 512 == y ) {
			print ( 'Laplace_L_L at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_L_L@current:[ 0,  0] )
			print ( 'Laplace_L_U at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_L_U@current:[ 0,  0] )
			print ( '  [-1,  0]', '=>', Laplace_L_U@current:[-1,  0] )
			print ( '  [ 0, -1]', '=>', Laplace_L_U@current:[ 0, -1] )
			print ( 'Laplace_U_U at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_U_U@current:[ 0,  0] )
			print ( 'Laplace_U_L at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_U_L@current:[ 0,  0] )
			print ( '  [ 1,  0]', '=>', Laplace_U_L@current:[ 1,  0] )
			print ( '  [ 0,  1]', '=>', Laplace_U_L@current:[ 0,  1] )
		}
	}
}
Function InitLaplace_DG@all ( ) : Unit {
	// reset
	loop over Laplace_DG_L_L@current {
		Laplace_DG_L_L@current:[ 0,  0] = 0.0
	}

	loop over Laplace_DG_L_U@current {
		Laplace_DG_L_U@current:[ 0,  0] = 0.0
		Laplace_DG_L_U@current:[-1,  0] = 0.0
		Laplace_DG_L_U@current:[ 0, -1] = 0.0
	}

	loop over Laplace_DG_U_U@current {
		Laplace_DG_U_U@current:[ 0,  0] = 0.0
	}

	loop over Laplace_DG_U_L@current {
		Laplace_DG_U_L@current:[ 0,  0] = 0.0
		Laplace_DG_U_L@current:[ 1,  0] = 0.0
		Laplace_DG_U_L@current:[ 0,  1] = 0.0
	}

	// lower west
	loop over Laplace_DG_L_L@current {
		Var face_0_x : Real = NodePos_x@current@[0, 1] - NodePos_x@current@[0, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 1] - NodePos_y@current@[0, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_U_x@current@[-1, 0] - CellCen_L_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_U_y@current@[-1, 0] - CellCen_L_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		
		
		
		Laplace_DG_L_U@current:[-1, 0] -= faceLen * alpha / edgeLen
		Laplace_DG_L_L@current:[0, 0] += faceLen * alpha / edgeLen
	}

	// lower south
	loop over Laplace_DG_L_L@current {
		Var face_0_x : Real = NodePos_x@current@[0, 0] - NodePos_x@current@[1, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 0] - NodePos_y@current@[1, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_U_x@current@[0, -1] - CellCen_L_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_U_y@current@[0, -1] - CellCen_L_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_DG_L_U@current:[0, -1] -= faceLen * alpha / edgeLen
		Laplace_DG_L_L@current:[0, 0] += faceLen * alpha / edgeLen
	}

	// lower diagonal
	loop over Laplace_DG_L_L@current {
		Var face_0_x : Real = NodePos_x@current@[1, 0] - NodePos_x@current@[0, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 0] - NodePos_y@current@[0, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_U_x@current@[0, 0] - CellCen_L_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_U_y@current@[0, 0] - CellCen_L_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_DG_L_U@current:[0, 0] -= faceLen * alpha / edgeLen
		Laplace_DG_L_L@current:[0, 0] += faceLen * alpha / edgeLen
	}

	// upper east
	loop over Laplace_DG_U_U@current {
		Var face_0_x : Real = NodePos_x@current@[1, 0] - NodePos_x@current@[1, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 0] - NodePos_y@current@[1, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_L_x@current@[1, 0] - CellCen_U_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_L_y@current@[1, 0] - CellCen_U_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_DG_U_L@current:[1, 0] -= faceLen * alpha / edgeLen
		Laplace_DG_U_U@current:[0, 0] += faceLen * alpha / edgeLen
	}

	// upper north
	loop over Laplace_DG_U_U@current {
		Var face_0_x : Real = NodePos_x@current@[1, 1] - NodePos_x@current@[0, 1]
		Var face_0_y : Real = NodePos_y@current@[1, 1] - NodePos_y@current@[0, 1]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_L_x@current@[0, 1] - CellCen_U_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_L_y@current@[0, 1] - CellCen_U_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_DG_U_L@current:[0, 1] -= faceLen * alpha / edgeLen
		Laplace_DG_U_U@current:[0, 0] += faceLen * alpha / edgeLen
	}

	// upper diag
	loop over Laplace_DG_U_U@current {
		Var face_0_x : Real = NodePos_x@current@[0, 1] - NodePos_x@current@[1, 0]
		Var face_0_y : Real = NodePos_y@current@[0, 1] - NodePos_y@current@[1, 0]
		Var faceLen : Real = sqrt ( face_0_x**2 + face_0_y**2 )
		Var face_n_x : Real = face_0_x / faceLen
		Var face_n_y : Real = face_0_y / faceLen
		Var norm_x : Real = -face_n_y
		Var norm_y : Real =  face_n_x
		Var edge_0_x : Real = CellCen_L_x@current@[0, 0] - CellCen_U_x@current@[0, 0]
		Var edge_0_y : Real = CellCen_L_y@current@[0, 0] - CellCen_U_y@current@[0, 0]
		Var edgeLen : Real = sqrt ( edge_0_x**2 + edge_0_y**2 )
		Var edge_n_x : Real = edge_0_x / edgeLen
		Var edge_n_y : Real = edge_0_y / edgeLen
		Var alpha : Real = -1.0 * ( face_n_y**2 + face_n_x**2 ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Var beta : Real = ( edge_n_y * face_n_y + edge_n_x * face_n_x ) / ( edge_n_x * face_n_y - edge_n_y * face_n_x )
		Laplace_DG_U_L@current:[0, 0] -= faceLen * alpha / edgeLen
		Laplace_DG_U_U@current:[0, 0] += faceLen * alpha / edgeLen
	}

	loop over Laplace_DG_L_L@current {
		if ( 512 == x && 512 == y ) {
			print ( 'Laplace_DG_L_L at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_DG_L_L@current:[ 0,  0] )
			print ( 'Laplace_DG_L_U at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_DG_L_U@current:[ 0,  0] )
			print ( '  [-1,  0]', '=>', Laplace_DG_L_U@current:[-1,  0] )
			print ( '  [ 0, -1]', '=>', Laplace_DG_L_U@current:[ 0, -1] )
			print ( 'Laplace_DG_U_U at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_DG_U_U@current:[ 0,  0] )
			print ( 'Laplace_DG_U_L at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_DG_U_L@current:[ 0,  0] )
			print ( '  [ 1,  0]', '=>', Laplace_DG_U_L@current:[ 1,  0] )
			print ( '  [ 0,  1]', '=>', Laplace_DG_U_L@current:[ 0,  1] )
		}
	}
}


Function Solve ( ) : Unit {
	UpResidual@finest ( )
	Variable resStart_0 : Real = NormResidual_0@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( 'Starting residual at 0', resStart_0 )
	startTimer ( 'timeToSolve' )
	Variable numIt : Integer = 0
	repeat until (res_0 < ( 1.0E-5 * resStart_0 ) || numIt >= 100) {
		numIt += 1
		startTimer ( 'cycle' )
		VCycle@finest (  )
		stopTimer ( 'cycle' )
		if (getTotalFromTimer ( 'cycle' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		startTimer ( 'convergenceChecking' )
		UpResidual@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_0@finest ( )
		print ( 'Error at 0:', curError_0 )
	stopTimer ( 'convergenceChecking' )
	}
	stopTimer ( 'timeToSolve' )
	print ( 'Total time to solve in', numIt, 'steps :', getTotalFromTimer ( 'timeToSolve' ) )
	print ( 'Mean time per vCycle: ', getMeanFromTimer ( 'cycle' ) )
}

Function Solve_Tri ( ) : Unit {
	UpResidual_Tri@finest ( )
	Variable resStart_0 : Real = NormResidual_Tri@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( 'Starting residual at 0', resStart_0 )
	startTimer ( 'timeToSolve_Tri' )
	Variable numIt : Integer = 0
	repeat until (res_0 < ( 1.0E-5 * resStart_0 ) || numIt >= 100) {
		numIt += 1
		startTimer ( 'cycle_Tri' )
		VCycle_Tri@finest (  )
		stopTimer ( 'cycle_Tri' )
		if (getTotalFromTimer ( 'cycle_Tri' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle_Tri' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		startTimer ( 'convergenceChecking_Tri' )
		UpResidual_Tri@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_Tri@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_Tri@finest ( )
		print ( 'Error at 0:', curError_0 )
	stopTimer ( 'convergenceChecking_Tri' )
	}
	stopTimer ( 'timeToSolve_Tri' )
	print ( 'Total time to solve in', numIt, 'steps :', getTotalFromTimer ( 'timeToSolve_Tri' ) )
	print ( 'Mean time per vCycle: ', getMeanFromTimer ( 'cycle_Tri' ) )
}

Function Solve_DG ( ) : Unit {
	UpResidual_DG@finest ( )
	Variable resStart_0 : Real = NormResidual_DG@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( 'Starting residual at 0', resStart_0 )
	startTimer ( 'timeToSolve_DG' )
	Variable numIt : Integer = 0
	repeat until (res_0 < ( 1.0E-5 * resStart_0 ) || numIt >= 100) {
		numIt += 1
		startTimer ( 'cycle_DG' )
		VCycle_DG@finest (  )
		stopTimer ( 'cycle_DG' )
		if (getTotalFromTimer ( 'cycle_DG' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle_DG' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		startTimer ( 'convergenceChecking_DG' )
		UpResidual_DG@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_DG@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_DG@finest ( )
		print ( 'Error at 0:', curError_0 )
	stopTimer ( 'convergenceChecking_DG' )
	}
	stopTimer ( 'timeToSolve_DG' )
	print ( 'Total time to solve in', numIt, 'steps :', getTotalFromTimer ( 'timeToSolve_DG' ) )
	print ( 'Mean time per vCycle: ', getMeanFromTimer ( 'cycle_DG' ) )
}

Function Application ( ) : Unit {
	startTimer ( 'setup' )
	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )
	stopTimer ( 'setup' )
	print ( 'Total time to setup: ', getTotalFromTimer ( 'setup' ) )
	startTimer ( 'init' )
	InitPosData@finest ( )
	InitLaplace@finest ( )
	InitLaplace_Tri@finest ( )
	InitLaplace_DG@finest ( )
	InitRHS@finest ( )
	InitRHS_Tri@finest ( )
	InitSolution ( )
	InitSolution_Tri ( )
	stopTimer ( 'init' )
	print ( 'Total time to init: ', getTotalFromTimer ( 'init' ) )
	Solve ( )
	Solve_Tri ( )
	Solve_DG ( )
	destroyGlobals ( )
}
