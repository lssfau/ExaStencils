


Globals {
	Var curTime : Real = 0.0
	Var maxTime : Real = 1.0e-1
	Var dt      : Real = 1.0e-5
	
	Var adaptDt : Boolean = true
	Var useLF		: Boolean = true
	
	Var printInterval : Int = -1
}



Field uVis from hu
Field vVis from hv
Field velMag from h
Field hVis from h



Function Solve@finest {
	Var it : Int = 0
	
	repeat until curTime >= maxTime {
		UpdateVis@finest ( )

		if ( 0 == it % 10 ) {
			print ( curTime, '/', maxTime, 'dt = ', dt )
		}

		if ( printInterval > 0 and 0 == it % printInterval ) {
			PrintFields ( it / printInterval )
		}

		if ( adaptDt ) {
			UpdateTimestepSize@finest ( )
		}

		Update ( )
		
		AdvanceTimestep ( )
		curTime += dt
		it += 1
	}	
}

Function PrintFields@finest ( index : Int ) {
	uVis = hu / h
	vVis = hv / h
	
	Var filename_u : String
	buildString ( filename_u, "u_", index, ".csv" )
	Var filename_v : String
	buildString ( filename_v, "v_", index, ".csv" )
	Var filename_h : String
	buildString ( filename_h, "h_", index, ".csv" )

	printField ( filename_u, vVis@current )
	printField ( filename_v, uVis@current )
	printField ( filename_h, h@current )
}

/*Function Update@all {
	hNew = h + (
		  dt * ( evalAtEastFace  ( hu ) - evalAtWestFace  ( hu ) ) / vf_gridWidth_y
		+ dt * ( evalAtNorthFace ( hv ) - evalAtSouthFace ( hv ) ) / vf_gridWidth_x )
	
	// TODO: sign?
	huNew = hu + ( integrateOverEastFace ( g * h * b ) - integrateOverWestFace ( g * h * b ) ) + (
		  dt * ( integrateOverEastFace  ( hu**2 / h + 0.5 * g * h**2 ) - integrateOverWestFace  ( hu**2 / h + 0.5 * g * h**2 ) ) / vf_cellVolume
		+ dt * ( integrateOverNorthFace ( hu * hv / h )                - integrateOverSouthFace ( hu * hv / h )                ) / vf_cellVolume )

	if ( useLF ) {
		huNew += (
			- ( hLF / 2.0 * tau ) * ( ( hu@[1,0]**2 / h@[1,0] + 0.5 * g * h@[1,0]**2 ) - ( hu**2 / h + 0.5 * g * h**2 ) )
			+ ( hLF / 2.0 * tau ) * ( ( hu**2 / h + 0.5 * g * h**2 ) - ( hu@[-1,0]**2 / h@[-1,0] + 0.5 * g * h@[-1,0]**2 ) )
			- ( hLF / 2.0 * tau ) * ( hu@[0,1] * hv@[0,1] / h@[0,1] - hu * hv / h )
			+ ( hLF / 2.0 * tau ) * ( hu * hv / h - hu@[0,-1] * hv@[0,-1] / h@[0,-1] )
		)
	}

	// TODO: sign?
	hvNew = hv + ( integrateOverNorthFace ( g * h * b ) - integrateOverSouthFace ( g * h * b ) ) + (
		  dt * ( integrateOverEastFace  ( hu * hv / h )                - integrateOverWestFace  ( hu * hv / h ) ) / vf_cellVolume
		+ dt * ( integrateOverNorthFace ( hv**2 / h + 0.5 * g * h**2 ) - integrateOverSouthFace ( hv**2 / h + 0.5 * g * h**2 ) ) / vf_cellVolume )

	if ( useLF ) {
		hvNew += (
			- ( hLF / 2.0 * tau ) * ( hu@[1,0] * hv@[1,0] / h@[1,0] - hu * hv / h )
			+ ( hLF / 2.0 * tau ) * ( hu * hv / h - hu@[-1,0] * hv@[-1,0] / h@[-1,0] )
			- ( hLF / 2.0 * tau ) * ( ( hv@[0,1]**2 / h@[0,1] + 0.5 * g * h@[0,1]**2 ) - ( hv**2 / h + 0.5 * g * h**2 ) )
			+ ( hLF / 2.0 * tau ) * ( ( hv**2 / h + 0.5 * g * h**2 ) - ( hv@[0,-1]**2 / h@[0,-1] + 0.5 * g * h@[0,-1]**2 ) )
		)
	}
}*/

Function AdvanceTimestep@all {
	h  = hNew
	hu = huNew
	hv = hvNew
}




