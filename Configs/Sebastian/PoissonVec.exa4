Domain global< [ 0, 0, 0 ] to [ 1, 1, 1 ] >

Layout NoComm< ColumnVector<Real, 2>, Node >@all {
	ghostLayers = [ 0, 0, 0 ]
	duplicateLayers = [ 1, 1, 1 ]
}
Layout BasicComm< ColumnVector<Real, 2>, Node >@all {
	ghostLayers = [ 1, 1, 1 ] with communication
	duplicateLayers = [ 1, 1, 1 ] with communication
}

Field Solution< global, BasicComm, 0.0 >[2]@(coarsest to 0)
Field Solution< global, BasicComm, 0.0 >[2]@(1 to (finest - 1))
Field Solution< global, BasicComm, ( vf_boundaryCoord_x@current * vf_boundaryCoord_x@current - 0.5 * vf_boundaryCoord_y@current * vf_boundaryCoord_y@current - 0.5 * vf_boundaryCoord_z@current * vf_boundaryCoord_z@current ) >[2]@finest
Field Residual< global, BasicComm, 0.0 >@all
Field RHS< global, NoComm, None >@(coarsest to 0)
Field RHS< global, NoComm, None >@(1 to finest)
Field VecP< global, BasicComm, 0.0 >@coarsest
Field VecGradP< global, NoComm, None >@coarsest

Stencil Laplace@all {
	[ 0,  0,  0] => { {  6.0, 0.0 }, { 0.0,  6.0 } }
	[ 1,  0,  0] => { { -1.0, 0.0 }, { 0.0, -1.0 } }
	[-1,  0,  0] => { { -1.0, 0.0 }, { 0.0, -1.0 } }
	[ 0,  1,  0] => { { -1.0, 0.0 }, { 0.0, -1.0 } }
	[ 0, -1,  0] => { { -1.0, 0.0 }, { 0.0, -1.0 } }
	[ 0,  0,  1] => { { -1.0, 0.0 }, { 0.0, -1.0 } }
	[ 0,  0, -1] => { { -1.0, 0.0 }, { 0.0, -1.0 } }
}
Stencil CorrectionStencil@all {
	[    0,     0,     0] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
	[x % 2,     0,     0] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
	[    0, y % 2,     0] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
	[x % 2, y % 2,     0] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
	[    0,     0, z % 2] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
	[x % 2,     0, z % 2] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
	[    0, y % 2, z % 2] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
	[x % 2, y % 2, z % 2] => { { 0.0625, 0.0 }, { 0.0, 0.0625 } }
}
Stencil RestrictionStencil@all {
	[ 0,  0,  0] => { {   1.0, 0.0 }, { 0.0,   1.0 } }
	[ 0,  0, -1] => { {   0.5, 0.0 }, { 0.0,   0.5 } }
	[ 0,  0,  1] => { {   0.5, 0.0 }, { 0.0,   0.5 } }
	[ 0, -1,  0] => { {   0.5, 0.0 }, { 0.0,   0.5 } }
	[ 0,  1,  0] => { {   0.5, 0.0 }, { 0.0,   0.5 } }
	[-1,  0,  0] => { {   0.5, 0.0 }, { 0.0,   0.5 } }
	[ 1,  0,  0] => { {   0.5, 0.0 }, { 0.0,   0.5 } }
	[ 0, -1,  1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[ 0, -1, -1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[ 0,  1,  1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[ 0,  1, -1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[-1,  0,  1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[-1,  0, -1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[ 1,  0,  1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[ 1,  0, -1] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[-1, -1,  0] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[-1,  1,  0] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[ 1, -1,  0] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[ 1,  1,  0] => { {  0.25, 0.0 }, { 0.0,  0.25 } }
	[-1, -1,  1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
	[-1, -1, -1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
	[-1,  1,  1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
	[-1,  1, -1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
	[ 1, -1,  1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
	[ 1, -1, -1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
	[ 1,  1,  1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
	[ 1,  1, -1] => { { 0.125, 0.0 }, { 0.0, 0.125 } }
}

Globals {
}

Function VCycle@coarsest ( ) : Unit {
	VCycle_0@current ( )
}
Function VCycle_0@coarsest ( ) : Unit {
	UpResidual@current ( )
	communicate Residual@current
	Variable res : Real = NormResidual_0@current ( )
	Variable initialRes : Real = res
	loop over VecP@current {
		VecP@current = Residual@current
	}
	Variable cgSteps : Integer
	repeat 512 times count cgSteps {
	communicate VecP@current
		loop over VecP@current {
			VecGradP@current = Laplace@current * VecP@current
		}
		Variable alphaDenom : Real = 0
		loop over VecP@current where x > 0 && y > 0 && z > 0 with reduction( + : alphaDenom ) {
			alphaDenom += VecP@current * VecGradP@current
		}
		Variable alpha : Real = res * res / alphaDenom
		loop over Solution@current {
			Solution[currentSlot]@current += alpha * VecP@current
			Residual@current -= alpha * VecGradP@current
		}
		Variable nextRes : Real = NormResidual_0@current ( )
		if ( nextRes <= 0.001 * initialRes ) {
			return
		}
		Variable beta : Real = (nextRes * nextRes) / (res * res)
		loop over VecP@current {
			VecP@current = Residual@current + beta * VecP@current
		}
		res = nextRes
	}
	print ( 'Maximum number of cgs iterations (', 512, ') was exceeded' )
}

Function VCycle@((coarsest + 1) to finest) ( ) : Unit {
	repeat 3 times {
		Smoother@current ( )
	}
	UpResidual@current ( )
	Restriction@current ( )
	SetSolution@coarser ( 0 )
		VCycle@coarser ( )
	Correction@current ( )
	repeat 3 times {
		Smoother@current ( )
	}
}

Function Smoother@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Solution[active]@current
	loop over Solution@current {
		Solution[nextSlot]@current = Solution[active]@current + 0.8 * inverse ( diag ( Laplace@current ) ) * ( RHS@current - Laplace@current * Solution[active]@current )
	}
	advance Solution@current
}

Function UpResidual@all (  ) : Unit {
	communicate Solution[active]@current
	loop over Residual@current {
		Residual@current = RHS@current - (Laplace@current * Solution[active]@current)
	}
}
Function NormResidual_0@(coarsest and finest) ( ) : Real {
	Variable res0 : Real = 0
	Variable res1 : Real = 0
	loop over Residual@current where x > 0 && y > 0 && z > 0 with reduction( + : res0 ) {
		Var res : Real = dot ( Residual@current, { 1, 0 }T )
		res0 += res * res
	}
	loop over Residual@current where x > 0 && y > 0 && z > 0 with reduction( + : res1 ) {
		Var res : Real = dot ( Residual@current, { 0, 1 }T )
		res1 += res * res
	}
	print ( 'Resid 0:', sqrt ( res0 ), 'Resid 1:', sqrt ( res1 ) )
	return sqrt ( res0 + res1 )
}

/*Function NormError_0@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over Solution@current where x > 0 && y > 0 && z > 0 with reduction( max : err ) {
		Var realSol : Real = vf_nodePosition_x@current * vf_nodePosition_x@current - 0.5 * vf_nodePosition_y@current * vf_nodePosition_y@current - 0.5 * vf_nodePosition_z@current * vf_nodePosition_z@current
		Variable curErr : ColumnVector<Real, 2> = {
			fabs ( { 1, 0 } * Solution[active]@current - realSol ),
			fabs ( { 0, 1 } * Solution[active]@current - realSol )
		}
		err = max ( err, dot ( curErr, curErr ) )
	}
	return ( err )
}*/

Function NormError_0@(finest) ( ) : Real {
	Variable err0 : Real = 0
	Variable err1 : Real = 0
	loop over Solution@current where x > 0 && y > 0 && z > 0 with reduction( max : err0 ) {
		Var realSol : Real = vf_nodePosition_x@current * vf_nodePosition_x@current - 0.5 * vf_nodePosition_y@current * vf_nodePosition_y@current - 0.5 * vf_nodePosition_z@current * vf_nodePosition_z@current
		
		Var sol0 : Real = dot ( Solution[active]@current, { 1, 0 }T )
		err0 = max ( err0, fabs ( sol0 - realSol ) )
	}
	loop over Solution@current where x > 0 && y > 0 && z > 0 with reduction( max : err1 ) {
		Var realSol : Real = vf_nodePosition_x@current * vf_nodePosition_x@current - 0.5 * vf_nodePosition_y@current * vf_nodePosition_y@current - 0.5 * vf_nodePosition_z@current * vf_nodePosition_z@current
		
		Var sol1 : Real = dot ( Solution[active]@current, { 0, 1 }T )
		err1 = max ( err1, fabs ( sol1 - realSol ) )
	}
	print ( 'Error 0:', err0, 'Error 1:', err1 )	
	return ( max ( err0, err1 ) )
}

Function CompareComponents@all ( ) : Real {
	Var dif : Real = 0.0
	loop over Solution@current where x > 0 && y > 0 && z > 0 with reduction( + : dif ) {
		/*Var sol0 : Real = { 1, 0 } * Solution[active]@current
		Var sol1 : Real = { 0, 1 } * Solution[active]@current*/
		Var sol0 : Real = dot ( Solution[active]@current, { 1, 0 }T )
		Var sol1 : Real = dot ( Solution[active]@current, { 0, 1 }T )
		dif += (sol0 - sol1)**2
	}
	return ( dif )
}

Function Restriction@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Residual@current
	loop over RHS@coarser {
		RHS@coarser = RestrictionStencil@current * Residual@current
	}
}
Function Correction@((coarsest + 1) to finest) ( ) : Unit {
	communicate ghost of Solution[active]@coarser
	loop over Solution@current {
		Solution[active]@current += CorrectionStencil@current * Solution[active]@coarser
	}
}

Function SetSolution@all (value : Real) : Unit {
	loop over Solution@current {
		Solution[active]@current = value
	}
}
Function InitSolution ( ) : Unit {
	loop over Solution@finest {
		Solution[active]@finest = 0
	}
}
Function InitRHS@finest ( ) : Unit {
	loop over RHS@current {
		RHS@current = 0.0
	}
}

Function Solve ( ) : Unit {
	UpResidual@finest ( )
	Variable resStart_0 : Real = NormResidual_0@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( 'Starting residual at 0', resStart_0 )
	startTimer ( 'timeToSolve' )
	Variable numIt : Integer = 0
	repeat until (res_0 < ( 1.0E-5 * resStart_0 ) || numIt >= 100) {
		numIt += 1
		startTimer ( 'cycle' )
		VCycle@finest (  )
		stopTimer ( 'cycle' )
		if (getTotalFromTimer ( 'cycle' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		startTimer ( 'convergenceChecking' )
		UpResidual@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_0@finest ( )
		print ( 'Error at 0:', curError_0 )
		print ( 'Dif between components:', CompareComponents@finest() )
	stopTimer ( 'convergenceChecking' )
	}
	stopTimer ( 'timeToSolve' )
	print ( 'Total time to solve in', numIt, 'steps :', getTotalFromTimer ( 'timeToSolve' ) )
	print ( 'Mean time per vCycle: ', getMeanFromTimer ( 'cycle' ) )
}

Function Application ( ) : Unit {
	startTimer ( 'setup' )
	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )
	stopTimer ( 'setup' )
	print ( 'Total time to setup: ', getTotalFromTimer ( 'setup' ) )
	InitRHS@finest ( )
	InitSolution ( )
	apply bc to Solution[0]@0
	apply bc to Solution[1]@0
	apply bc to Solution[0]@1
	apply bc to Solution[1]@1
	apply bc to Solution[0]@2
	apply bc to Solution[1]@2
	apply bc to Solution[0]@3
	apply bc to Solution[1]@3
	apply bc to Solution[0]@4
	apply bc to Solution[1]@4
	apply bc to Solution[0]@5
	apply bc to Solution[1]@5
	apply bc to Solution[0]@6
	apply bc to Solution[1]@6
	apply bc to VecP@coarsest
	Solve ( )
	destroyGlobals ( )
}


