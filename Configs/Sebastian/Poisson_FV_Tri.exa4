Domain global< [ 0, 0 ] to [ 1, 1 ] >

Layout NoComm< Real, Cell >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 0, 0 ]
}
Layout BasicComm< Real, Cell >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 0, 0 ] with communication
}
Layout BasicCommVec< Vector< Real, 2 >, Cell >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 0, 0 ] with communication
}
Layout NoCommSF< Array<Real><9>, Cell >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 0, 0 ]
}

Field Solution< global, BasicComm, applyBC_Sol@current ( ) >@all
Field Residual< global, BasicComm, applyBC_Res@current ( ) >@all
Field RHS< global, NoComm, None >@all
Field VecP< global, BasicComm, 0.0 >@coarsest
Field VecGradP< global, NoComm, None >@coarsest

Field Solution_L< global, BasicComm, applyBC_Sol_L@current ( ) >@all
Field Solution_U< global, BasicComm, applyBC_Sol_U@current ( ) >@all
Field Residual_L< global, BasicComm, applyBC_Res_L@current ( ) >@all
Field Residual_U< global, BasicComm, applyBC_Res_U@current ( ) >@all
Field RHS_L< global, NoComm, None >@all
Field RHS_U< global, NoComm, None >@all
Field VecP_L< global, BasicComm, 0.0 >@coarsest
Field VecP_U< global, BasicComm, 0.0 >@coarsest
Field VecGradP_L< global, NoComm, None >@coarsest
Field VecGradP_U< global, NoComm, None >@coarsest

Field CellVol< global, BasicComm, None >@all

Field CellCen_L< global, BasicCommVec, None >@all
Field CellCen_U< global, BasicCommVec, None >@all
Field CellCen_L_x< global, BasicComm, None >@all
Field CellCen_U_x< global, BasicComm, None >@all
Field CellCen_L_y< global, BasicComm, None >@all
Field CellCen_U_y< global, BasicComm, None >@all
Field CellVol_L< global, BasicComm, None >@all
Field CellVol_U< global, BasicComm, None >@all

Field LaplaceCoeff< global, NoCommSF, None >@all
StencilField Laplace< LaplaceCoeff => LaplaceStencil >@all

Field LaplaceCoeff_L_L< global, NoCommSF, None >@all
StencilField Laplace_L_L< LaplaceCoeff_L_L => LaplaceStencil_L_L >@all
Field LaplaceCoeff_L_U< global, NoCommSF, None >@all
StencilField Laplace_L_U< LaplaceCoeff_L_U => LaplaceStencil_L_U >@all
Field LaplaceCoeff_U_U< global, NoCommSF, None >@all
StencilField Laplace_U_U< LaplaceCoeff_U_U => LaplaceStencil_U_U >@all
Field LaplaceCoeff_U_L< global, NoCommSF, None >@all
StencilField Laplace_U_L< LaplaceCoeff_U_L => LaplaceStencil_U_L >@all

Stencil LaplaceStencil@all {
	[ 0,  0] => 0.0
	[ 1,  0] => 0.0
	[-1,  0] => 0.0
	[ 0,  1] => 0.0
	[ 0, -1] => 0.0
	[ 1,  1] => 0.0
	[ 1, -1] => 0.0
	[-1,  1] => 0.0
	[-1, -1] => 0.0
}
Stencil ProlongateValue@all {
	[ 0, 0] => 1.0
}
Stencil RestrictIntegral@all {
	[ 0,  0] => 1.0
	[ 0,  1] => 1.0
	[ 1,  0] => 1.0
	[ 1,  1] => 1.0
}
Stencil RestrictValue@all {
	[ 0,  0] => 0.25
	[ 0,  1] => 0.25
	[ 1,  0] => 0.25
	[ 1,  1] => 0.25
}

Stencil LaplaceStencil_L_L@all {
	[ 0,  0] => 0.0

	[-1,  0] => 0.0
	[ 1,  0] => 0.0
	[ 0, -1] => 0.0
	[ 0,  1] => 0.0
	[-1,  1] => 0.0
	[ 1, -1] => 0.0
}

Stencil LaplaceStencil_L_U@all {
	[ 0,  0] => 0.0
	[-1,  0] => 0.0
	[ 0, -1] => 0.0

	[-1,  1] => 0.0
	[-1, -1] => 0.0
	[ 1, -1] => 0.0
}

Stencil LaplaceStencil_U_U@all {
	[ 0,  0] => 0.0

	[-1,  0] => 0.0
	[ 1,  0] => 0.0
	[ 0, -1] => 0.0
	[ 0,  1] => 0.0
	[-1,  1] => 0.0
	[ 1, -1] => 0.0
}

Stencil LaplaceStencil_U_L@all {
	[ 0,  0] => 0.0
	[ 1,  0] => 0.0
	[ 0,  1] => 0.0

	[-1,  1] => 0.0
	[ 1,  1] => 0.0
	[ 1, -1] => 0.0
}

Function applyBC_Sol@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Solution@current only ghost [-1,  0] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[1, 0]
		Val p1_y : Real = vf_cellCenter_y@current@[1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[1, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[1, 0]
	}
	loop over Solution@current only ghost [ 1,  0] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[-1, 0]
		Val p1_y : Real = vf_cellCenter_y@current@[-1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[-1, 0]
	}
	loop over Solution@current only ghost [ 0,  1] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[0, -1]
		Val p1_y : Real = vf_cellCenter_y@current@[0, -1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[0, -1]
	}
	loop over Solution@current only ghost [ 0, -1] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[0, 1]
		Val p1_y : Real = vf_cellCenter_y@current@[0, 1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 1]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[0, 1]
	}
	
	/*loop over Solution@current only ghost [-1, -1] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[1, 1]
		Val p1_y : Real = vf_cellCenter_y@current@[1, 1]

		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Val n0_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n0_y : Real = vf_nodePosition_y@current@[1, 1]
		Val n1_x : Real = vf_nodePosition_x@current@[2, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[2, 1]
		Val n2_x : Real = vf_nodePosition_x@current@[1, 2]
		Val n2_y : Real = vf_nodePosition_y@current@[1, 2]

		Var f_1_x : Real = n1_x - n0_x // nx
		Var f_1_y : Real = n1_y - n0_y
		Var f_2_x : Real = n2_x - n0_x // nx
		Var f_2_y : Real = n2_y - n0_y

		Var alpha_1 : Real = 1.0 / ( -f_1_x * e_y + e_x * f_1_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta_1 : Real = 1.0 / ( -f_1_x * e_y + e_x * f_1_y ) * ( -f_1_y * ( p0_x - n0_x ) + f_1_x * ( p0_y - n0_y ) )
		Var alpha_2 : Real = 1.0 / ( -f_2_x * e_y + e_x * f_2_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta_2 : Real = 1.0 / ( -f_2_x * e_y + e_x * f_2_y ) * ( -f_2_y * ( p0_x - n0_x ) + f_2_x * ( p0_y - n0_y ) )
		
		if ( 0.0 <= alpha_1 && alpha_1 <= 1.0 ) {
			Var boundary_x : Real = n0_x + alpha_1 * f_1_x
			Var boundary_y : Real = n0_y + alpha_1 * f_1_y

			Var w_i : Real = 1.0 / ( 1.0 - beta_1 )
			Var w_1 : Real = -beta_1 / ( 1.0 - beta_1 )

			Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[0, 1]
		} else if ( 0.0 <= alpha_2 && alpha_2 <= 1.0 ) {
			Var boundary_x : Real = n0_x + alpha_2 * f_2_x
			Var boundary_y : Real = n0_y + alpha_2 * f_2_y

			Var w_i : Real = 1.0 / ( 1.0 - beta_2 )
			Var w_1 : Real = -beta_2 / ( 1.0 - beta_2 )

			Solution@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution@current@[1, 1]
		} else {
			print ( 'intersection is very wrong at', x, y, 'with alphas', alpha_1, alpha_2, 'and betas', beta_1, beta_2)
		}
	}*/
}

Function applyBC_Sol@(all but finest) ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Solution@current only ghost [-1,  0] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[1, 0]
		Val p1_y : Real = vf_cellCenter_y@current@[1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[1, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * 0.0 + w_1 * Solution@current@[1, 0]
	}
	loop over Solution@current only ghost [ 1,  0] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[-1, 0]
		Val p1_y : Real = vf_cellCenter_y@current@[-1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * 0.0 + w_1 * Solution@current@[-1, 0]
	}
	loop over Solution@current only ghost [ 0,  1] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[0, -1]
		Val p1_y : Real = vf_cellCenter_y@current@[0, -1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * 0.0 + w_1 * Solution@current@[0, -1]
	}
	loop over Solution@current only ghost [ 0, -1] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[0, 1]
		Val p1_y : Real = vf_cellCenter_y@current@[0, 1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 1]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution@current = w_i * 0.0 + w_1 * Solution@current@[0, 1]
	}
}

Function applyBC_Res@all ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Residual@current only ghost [-1,  0] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[1, 0]
		Val p1_y : Real = vf_cellCenter_y@current@[1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[1, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual@current = w_i * 0.0 + w_1 * Residual@current@[1, 0]
	}
	loop over Residual@current only ghost [ 1,  0] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[-1, 0]
		Val p1_y : Real = vf_cellCenter_y@current@[-1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual@current = w_i * 0.0 + w_1 * Residual@current@[-1, 0]
	}
	loop over Residual@current only ghost [ 0,  1] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[0, -1]
		Val p1_y : Real = vf_cellCenter_y@current@[0, -1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual@current = w_i * 0.0 + w_1 * Residual@current@[0, -1]
	}
	loop over Residual@current only ghost [ 0, -1] on boundary {
		Val p0_x : Real = vf_cellCenter_x@current@[0, 0]
		Val p0_y : Real = vf_cellCenter_y@current@[0, 0]
		Val p1_x : Real = vf_cellCenter_x@current@[0, 1]
		Val p1_y : Real = vf_cellCenter_y@current@[0, 1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 1]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual@current = w_i * 0.0 + w_1 * Residual@current@[0, 1]
	}
}

Function applyBC_Sol_L@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	/*loop over Solution_L@current only ghost [-1,  0] on boundary {
		Solution_L@current = Solution_L@current@[ 1,  0]
	}*/
	loop over Solution_L@current only ghost [ 1,  0] on boundary {
		//Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 0] + vf_nodePosition_x@current@[0, 1] )
		//Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 0] + vf_nodePosition_y@current@[0, 1] )
		//Solution_L@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_U@current@[-1,  0]

		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[-1, 0]
		Val p1_y : Real = CellCen_U_y@current@[-1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_L@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_U@current@[-1, 0]
	}
	loop over Solution_L@current only ghost [ 0,  1] on boundary {
		//Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 0] + vf_nodePosition_x@current@[1, 0] )
		//Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 0] + vf_nodePosition_y@current@[1, 0] )
		//Solution_L@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_U@current@[ 0, -1]

		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[0, -1]
		Val p1_y : Real = CellCen_U_y@current@[0, -1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_L@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_U@current@[0, -1]
	}
	/*loop over Solution_L@current only ghost [ 0, -1] on boundary {
		Solution_L@current = Solution_L@current@[ 0,  1]
	}*/
}
Function applyBC_Sol_U@finest ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Solution_U@current only ghost [-1,  0] on boundary {
		//Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[1, 0] + vf_nodePosition_x@current@[1, 1] )
		//Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[1, 0] + vf_nodePosition_y@current@[1, 1] )
		//Solution_U@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_L@current@[ 1,  0]

		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[1, 0]
		Val p1_y : Real = CellCen_L_y@current@[1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[1, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_U@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_L@current@[1, 0]
	}
	/*loop over Solution_U@current only ghost [ 1,  0] on boundary {
		Solution_U@current = Solution_U@current@[-1,  0]
	}*/
	/*loop over Solution_U@current only ghost [ 0,  1] on boundary {
		Solution_U@current = Solution_U@current@[ 0, -1]
	}*/
	loop over Solution_U@current only ghost [ 0, -1] on boundary {
		//Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 1] + vf_nodePosition_x@current@[1, 1] )
		//Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 1] + vf_nodePosition_y@current@[1, 1] )
		//Solution_U@current = 2.0 * ( boundary_x**2 - boundary_y**2 ) - Solution_L@current@[ 0,  1]

		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[0, 1]
		Val p1_y : Real = CellCen_L_y@current@[0, 1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 1]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var boundary_x : Real = n0_x + alpha * f_x
		Var boundary_y : Real = n0_y + alpha * f_y

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_U@current = w_i * ( boundary_x**2 - boundary_y**2 ) + w_1 * Solution_L@current@[0, 1]
	}
}

Function applyBC_Sol_L@(all but finest) ( ) : Unit {
	/*loop over Solution_L@current only ghost [-1,  0] on boundary {
		Solution_L@current = Solution_L@current@[ 1,  0]
	}*/
	loop over Solution_L@current only ghost [ 1,  0] on boundary {
		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[-1, 0]
		Val p1_y : Real = CellCen_U_y@current@[-1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_L@current = w_i * 0.0 + w_1 * Solution_U@current@[-1, 0]
	}
	loop over Solution_L@current only ghost [ 0,  1] on boundary {
		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[0, -1]
		Val p1_y : Real = CellCen_U_y@current@[0, -1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_L@current = w_i * 0.0 + w_1 * Solution_U@current@[0, -1]
	}
	/*loop over Solution_L@current only ghost [ 0, -1] on boundary {
		Solution_L@current = Solution_L@current@[ 0,  1]
	}*/
}
Function applyBC_Sol_U@(all but finest) ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Solution_U@current only ghost [-1,  0] on boundary {
		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[1, 0]
		Val p1_y : Real = CellCen_L_y@current@[1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[1, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_U@current = w_i * 0.0 + w_1 * Solution_L@current@[1, 0]
	}
	/*loop over Solution_U@current only ghost [ 1,  0] on boundary {
		Solution_U@current = Solution_U@current@[-1,  0]
	}*/
	/*loop over Solution_U@current only ghost [ 0,  1] on boundary {
		Solution_U@current = Solution_U@current@[ 0, -1]
	}*/
	loop over Solution_U@current only ghost [ 0, -1] on boundary {
		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[0, 1]
		Val p1_y : Real = CellCen_L_y@current@[0, 1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 1]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Solution_U@current = w_i * 0.0 + w_1 * Solution_L@current@[0, 1]
	}
}
/*
Function applyBC_Sol_L@(all but finest) ( ) : Unit {
	loop over Solution_L@current only ghost [ 1,  0] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 0] + vf_nodePosition_x@current@[0, 1] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 0] + vf_nodePosition_y@current@[0, 1] )
		Solution_L@current = 2.0 * 0.0 - Solution_U@current@[-1,  0]
	}
	loop over Solution_L@current only ghost [ 0,  1] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 0] + vf_nodePosition_x@current@[1, 0] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 0] + vf_nodePosition_y@current@[1, 0] )
		Solution_L@current = 2.0 * 0.0 - Solution_U@current@[ 0, -1]
	}
}
Function applyBC_Sol_U@(all but finest) ( ) : Unit {
	loop over Solution_U@current only ghost [-1,  0] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[1, 0] + vf_nodePosition_x@current@[1, 1] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[1, 0] + vf_nodePosition_y@current@[1, 1] )
		Solution_U@current = 2.0 * 0.0 - Solution_L@current@[ 1,  0]
	}
	loop over Solution_U@current only ghost [ 0, -1] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 1] + vf_nodePosition_x@current@[1, 1] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 1] + vf_nodePosition_y@current@[1, 1] )
		Solution_U@current = 2.0 * 0.0 - Solution_L@current@[ 0,  1]
	}
}
*/
/*Function applyBC_Res_L@all ( ) : Unit {
	loop over Residual_L@current only ghost [ 1,  0] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 0] + vf_nodePosition_x@current@[0, 1] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 0] + vf_nodePosition_y@current@[0, 1] )
		Residual_L@current = 2.0 * 0.0 - Residual_U@current@[-1,  0]
	}
	loop over Residual_L@current only ghost [ 0,  1] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 0] + vf_nodePosition_x@current@[1, 0] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 0] + vf_nodePosition_y@current@[1, 0] )
		Residual_L@current = 2.0 * 0.0 - Residual_U@current@[ 0, -1]
	}
}
Function applyBC_Res_U@all ( ) : Unit {
	loop over Residual_U@current only ghost [-1,  0] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[1, 0] + vf_nodePosition_x@current@[1, 1] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[1, 0] + vf_nodePosition_y@current@[1, 1] )
		Residual_U@current = 2.0 * 0.0 - Residual_L@current@[ 1,  0]
	}
	loop over Residual_U@current only ghost [ 0, -1] on boundary {
		Val boundary_x : Real = 0.5 * ( vf_nodePosition_x@current@[0, 1] + vf_nodePosition_x@current@[1, 1] )
		Val boundary_y : Real = 0.5 * ( vf_nodePosition_y@current@[0, 1] + vf_nodePosition_y@current@[1, 1] )
		Residual_U@current = 2.0 * 0.0 - Residual_L@current@[ 0,  1]
	}
}
*/

Function applyBC_Res_L@all ( ) : Unit {
	/*loop over Residual_L@current only ghost [-1,  0] on boundary {
		Residual_L@current = Residual_L@current@[ 1,  0]
	}*/
	loop over Residual_L@current only ghost [ 1,  0] on boundary {
		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[-1, 0]
		Val p1_y : Real = CellCen_U_y@current@[-1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[0, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual_L@current = w_i * 0.0 + w_1 * Residual_U@current@[-1, 0]
	}
	loop over Residual_L@current only ghost [ 0,  1] on boundary {
		Val p0_x : Real = CellCen_L_x@current@[0, 0]
		Val p0_y : Real = CellCen_L_y@current@[0, 0]
		Val p1_x : Real = CellCen_U_x@current@[0, -1]
		Val p1_y : Real = CellCen_U_y@current@[0, -1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 0]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual_L@current = w_i * 0.0 + w_1 * Residual_U@current@[0, -1]
	}
	/*loop over Residual_L@current only ghost [ 0, -1] on boundary {
		Residual_L@current = Residual_L@current@[ 0,  1]
	}*/
}
Function applyBC_Res_U@all ( ) : Unit {
	// vf_boundaryCoord_x@current**2 - vf_boundaryCoord_y@current**2
	loop over Residual_U@current only ghost [-1,  0] on boundary {
		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[1, 0]
		Val p1_y : Real = CellCen_L_y@current@[1, 0]
		Val n0_x : Real = vf_nodePosition_x@current@[1, 0]
		Val n0_y : Real = vf_nodePosition_y@current@[1, 0]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual_U@current = w_i * 0.0 + w_1 * Residual_L@current@[1, 0]
	}
	/*loop over Residual_U@current only ghost [ 1,  0] on boundary {
		Residual_U@current = Residual_U@current@[-1,  0]
	}*/
	/*loop over Residual_U@current only ghost [ 0,  1] on boundary {
		Residual_U@current = Residual_U@current@[ 0, -1]
	}*/
	loop over Residual_U@current only ghost [ 0, -1] on boundary {
		Val p0_x : Real = CellCen_U_x@current@[0, 0]
		Val p0_y : Real = CellCen_U_y@current@[0, 0]
		Val p1_x : Real = CellCen_L_x@current@[0, 1]
		Val p1_y : Real = CellCen_L_y@current@[0, 1]
		Val n0_x : Real = vf_nodePosition_x@current@[0, 1]
		Val n0_y : Real = vf_nodePosition_y@current@[0, 1]
		Val n1_x : Real = vf_nodePosition_x@current@[1, 1]
		Val n1_y : Real = vf_nodePosition_y@current@[1, 1]

		Var f_x : Real = n1_x - n0_x // nx
		Var f_y : Real = n1_y - n0_y
		Var e_x : Real = p1_x - p0_x // px
		Var e_y : Real = p1_y - p0_y

		Var alpha : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -e_y * ( p0_x - n0_x ) + e_x * ( p0_y - n0_y ) )
		Var beta : Real = 1.0 / ( -f_x * e_y + e_x * f_y ) * ( -f_y * ( p0_x - n0_x ) + f_x * ( p0_y - n0_y ) )

		Var w_i : Real = 1.0 / ( 1.0 - beta )
		Var w_1 : Real = -beta / ( 1.0 - beta )

		Residual_U@current = w_i * 0.0 + w_1 * Residual_L@current@[0, 1]
	}
}

Globals {
	Var factor : Real = 1.0
	Var omegaQuad : Real = 1.0
	Var omegaTri : Real = 1.0
}

Function VCycle@coarsest ( ) : Unit {
	VCycle_0@current ( )
}
Function VCycle_0@coarsest ( ) : Unit {
	UpResidual@current ( )
	apply bc to Residual@current
	communicate Residual@current
	Variable res : Real = NormResidual_0@current ( )
	Variable initialRes : Real = res
	loop over VecP@current {
		VecP@current = Residual@current
	}
	Variable cgSteps : Integer
	repeat 512 times count cgSteps {
	apply bc to VecP@current
	communicate VecP@current
		loop over VecP@current {
			VecGradP@current = Laplace@current * VecP@current
		}
		Variable alphaDenom : Real = 0
		loop over VecP@current with reduction( + : alphaDenom ) {
			alphaDenom += VecP@current * VecGradP@current
		}
		Variable alpha : Real = res * res / alphaDenom
		loop over Solution@current {
			Solution[currentSlot]@current += alpha * VecP@current
			Residual@current -= alpha * VecGradP@current
		}
		Variable nextRes : Real = NormResidual_0@current ( )
		if ( nextRes <= 0.001 * initialRes ) {
			return
		}
		Variable beta : Real = (nextRes * nextRes) / (res * res)
		loop over VecP@current {
			VecP@current = Residual@current + beta * VecP@current
		}
		res = nextRes
	}
	print ( 'Maximum number of cgs iterations (', 512, ') was exceeded' )
}

Function VCycle@((coarsest + 1) to finest) ( ) : Unit {
	repeat 3 times {
		Smoother@current ( )
	}
	UpResidual@current ( )
	Restriction@current ( )
	SetSolution@coarser ( 0 )
		VCycle@coarser ( )
	Correction@current ( )
	repeat 3 times {
		Smoother@current ( )
	}
}

Function VCycle_Tri@coarsest ( ) : Unit {
	repeat 128 times {
		Smoother_Tri@current ( )
	}
}

Function VCycle_Tri@((coarsest + 1) to finest) ( ) : Unit {
	repeat 3 times {
		Smoother_Tri@current ( )
	}
	UpResidual_Tri@current ( )
	Restriction_Tri@current ( )
	SetSolution_Tri@coarser ( 0 )
		VCycle_Tri@coarser ( )
	Correction_Tri@current ( )
	repeat 3 times {
		Smoother_Tri@current ( )
	}
}

Function Smoother@((coarsest + 1) to finest) ( ) : Unit {
	/*
	apply bc to Solution[active]@current
	communicate Solution[active]@current
	loop over Solution@current {
		Solution[nextSlot]@current = Solution[active]@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * omegaQuad ) * ( RHS@current - Laplace@current * Solution[active]@current ) )
	}
	advance Solution@current
	*/

	apply bc to Solution@current
	communicate Solution@current

	loop over Solution@current where 0 == ( x + y ) % 2 {
		Solution@current = Solution@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * omegaQuad ) * ( RHS@current - Laplace@current * Solution@current ) )
	}

	apply bc to Solution@current
	communicate Solution@current

	loop over Solution@current where 1 == ( x + y ) % 2 {
		Solution@current = Solution@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * omegaQuad ) * ( RHS@current - Laplace@current * Solution@current ) )
	}
}

Function Smoother_Tri@all ( ) : Unit {
	apply bc to Solution_L@current
	communicate Solution_L@current
	apply bc to Solution_U@current
	communicate Solution_U@current

	loop over Solution_L@current {
		Solution_L@current = Solution_L@current + ( ( ( 1.0 / diag ( Laplace_L_L@current ) ) * omegaTri ) * ( RHS_L@current - ( Laplace_L_L@current * Solution_L@current + Laplace_L_U@current * Solution_U@current ) ) )
	}

	apply bc to Solution_L@current
	communicate Solution_L@current
	apply bc to Solution_U@current
	communicate Solution_U@current

	loop over Solution_U@current {
		Solution_U@current = Solution_U@current + ( ( ( 1.0 / diag ( Laplace_U_U@current ) ) * omegaTri ) * ( RHS_U@current - ( Laplace_U_U@current * Solution_U@current + Laplace_U_L@current * Solution_L@current ) ) )
	}
}

Function UpResidual@all (  ) : Unit {
	apply bc to Solution[active]@current
	communicate Solution[active]@current
	loop over Residual@current {
		Residual@current = RHS@current - (Laplace@current * Solution[active]@current)
	}
}

Function UpResidual_Tri@all (  ) : Unit {
	apply bc to Solution_L[active]@current
	apply bc to Solution_U[active]@current
	communicate Solution_L[active]@current
	communicate Solution_U[active]@current
	loop over Residual_L@current {
		Residual_L@current = RHS_L@current - ( Laplace_L_L@current * Solution_L[active]@current + Laplace_L_U@current * Solution_U[active]@current )
	}
	loop over Residual_U@current {
		Residual_U@current = RHS_U@current - ( Laplace_U_U@current * Solution_U[active]@current + Laplace_U_L@current * Solution_L[active]@current )
	}
}

Function NormResidual_0@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over Residual@current with reduction( + : res ) {
		res += Residual@current * Residual@current
	}
	return sqrt ( res )
}

Function NormResidual_Tri@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over Residual_L@current with reduction( + : res ) {
		res += Residual_L@current * Residual_L@current
	}
	loop over Residual_U@current with reduction( + : res ) {
		res += Residual_U@current * Residual_U@current
	}
	return sqrt ( res )
}

Function NormError_0@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over Solution@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution[active]@current - ( vf_cellCenter_x@current**2 - vf_cellCenter_y@current**2 ) )
		err = max ( err, curErr )
	}
	return ( err )
}

Function NormError_Tri@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over Solution_L@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution_L[active]@current - ( CellCen_L_x@current**2 - CellCen_L_y@current**2 ) )
		err = max ( err, curErr )
	}
	loop over Solution_U@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution_U[active]@current - ( CellCen_U_x@current**2 - CellCen_U_y@current**2 ) )
		err = max ( err, curErr )
	}
	return ( err )
}

Function Restriction@((coarsest + 1) to finest) ( ) : Unit {
	apply bc to Residual@current
	communicate Residual@current
	loop over RHS@coarser {
		Var correction : Real = CellVol@coarser / ( CellVol@current@[0, 0] + CellVol@current@[1, 0] + CellVol@current@[0, 1] + CellVol@current@[1, 1] )
		RHS@coarser = correction * RestrictIntegral@current * Residual@current
	}
}

Function Restriction_Tri@((coarsest + 1) to finest) ( ) : Unit {
	apply bc to Residual_L@current
	apply bc to Residual_U@current
	communicate Residual_L@current
	communicate Residual_U@current
	loop over RHS_L@coarser {
		Var correction : Real = CellVol_L@coarser / ( CellVol_L@current@[0, 0] + CellVol_U@current@[0, 0] + CellVol_L@current@[1, 0] + CellVol_L@current@[0, 1] )
		RHS_L@coarser = correction * ( Residual_L@current@[0, 0] + Residual_U@current@[0, 0] + Residual_L@current@[1, 0] + Residual_L@current@[0, 1] )
	}
	loop over RHS_U@coarser {
		Var correction : Real = CellVol_U@coarser / ( CellVol_U@current@[1, 1] + CellVol_L@current@[1, 1] + CellVol_U@current@[1, 0] + CellVol_U@current@[0, 1] )
		RHS_U@coarser = correction * ( Residual_U@current@[1, 1] + Residual_L@current@[1, 1] + Residual_U@current@[1, 0] + Residual_U@current@[0, 1] )
	}
}

Function Correction@((coarsest + 1) to finest) ( ) : Unit {
	apply bc to Solution[active]@coarser
	communicate Solution[active]@coarser
	loop over Solution@current {
		Var correction : Real = 1.0
		Solution[active]@current += correction * ProlongateValue@current * Solution[active]@coarser
	}
}

Function Correction_Tri@((coarsest + 1) to finest) ( ) : Unit {
	apply bc to Solution_L@coarser
	apply bc to Solution_U@coarser
	communicate Solution_L@coarser
	communicate Solution_U@coarser
	loop over Solution_L@coarser {
		Var correction : Real = factor

		Solution_L@current@[0, 0] += correction * Solution_L@coarser
		Solution_U@current@[0, 0] += correction * Solution_L@coarser
		Solution_L@current@[1, 0] += correction * Solution_L@coarser
		Solution_L@current@[0, 1] += correction * Solution_L@coarser

		Solution_U@current@[1, 1] += correction * Solution_U@coarser
		Solution_L@current@[1, 1] += correction * Solution_U@coarser
		Solution_U@current@[1, 0] += correction * Solution_U@coarser
		Solution_U@current@[0, 1] += correction * Solution_U@coarser
	}
}

Function SetSolution@all (value : Real) : Unit {
	loop over Solution@current {
		Solution[active]@current = value
	}
}

Function SetSolution_Tri@all (value : Real) : Unit {
	loop over Solution_L@current {
		Solution_L[active]@current = value
	}
	loop over Solution_U@current {
		Solution_U[active]@current = value
	}
}

Function InitSolution ( ) : Unit {
	loop over Solution@finest {
		Solution[active]@finest = 0
	}
}

Function InitSolution_Tri ( ) : Unit {
	loop over Solution_L@finest {
		Solution_L[active]@finest = 0
	}
	loop over Solution_U@finest {
		Solution_U[active]@finest = 0
	}
}

Function InitRHS@finest ( ) : Unit {
	loop over RHS@current {
		RHS@current = 0.0
	}
}

Function InitRHS_Tri@finest ( ) : Unit {
	loop over RHS_L@current {
		RHS_L@current = 0.0
	}
	loop over RHS_U@current {
		RHS_U@current = 0.0
	}
}

Function InitPosData@all ( ) : Unit {
	loop over CellCen_L@current starting [-1, -1] ending [-1, -1] {
		CellCen_L@current = ( 1.0 / 3.0 ) * ( vf_nodePosAsVec@current@[0, 0] + vf_nodePosAsVec@current@[1, 0] + vf_nodePosAsVec@current@[0, 1] )
		CellCen_U@current = ( 1.0 / 3.0 ) * ( vf_nodePosAsVec@current@[1, 0] + vf_nodePosAsVec@current@[0, 1] + vf_nodePosAsVec@current@[1, 1] )
	}
	loop over CellCen_L_x@current starting [-1, -1] ending [-1, -1] {
		CellCen_L_x@current = ( 1.0 / 3.0 ) * ( vf_nodePosition_x@current@[0, 0] + vf_nodePosition_x@current@[1, 0] + vf_nodePosition_x@current@[0, 1] )
		CellCen_U_x@current = ( 1.0 / 3.0 ) * ( vf_nodePosition_x@current@[1, 0] + vf_nodePosition_x@current@[0, 1] + vf_nodePosition_x@current@[1, 1] )
	}
	loop over CellCen_L_y@current starting [-1, -1] ending [-1, -1] {
		CellCen_L_y@current = ( 1.0 / 3.0 ) * ( vf_nodePosition_y@current@[0, 0] + vf_nodePosition_y@current@[1, 0] + vf_nodePosition_y@current@[0, 1] )
		CellCen_U_y@current = ( 1.0 / 3.0 ) * ( vf_nodePosition_y@current@[1, 0] + vf_nodePosition_y@current@[0, 1] + vf_nodePosition_y@current@[1, 1] )
	}

	loop over CellVol@current starting [-1, -1] ending [-1, -1] {
		// split quad into two triangles and use Heron's formula (https://en.wikipedia.org/wiki/Heron's_formula)
		// A = 0.25 * sqrt ( 4.0 * a**2 * b**2 - (a**2 + b**2 - c**2 )**2 )
		// NOTE: assumes convex quads
		Var a : Real = sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_nodePosition_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_nodePosition_y@current@[0, 0] )**2 )
		Var b : Real = sqrt ( ( vf_nodePosition_x@current@[0, 1] - vf_nodePosition_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[0, 1] - vf_nodePosition_y@current@[0, 0] )**2 )
		Var c : Real = sqrt ( ( vf_nodePosition_x@current@[0, 1] - vf_nodePosition_x@current@[1, 0] )**2 + ( vf_nodePosition_y@current@[0, 1] - vf_nodePosition_y@current@[1, 0] )**2 )
		Var d : Real = sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_nodePosition_x@current@[0, 1] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_nodePosition_y@current@[0, 1] )**2 )
		Var e : Real = sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_nodePosition_x@current@[1, 0] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_nodePosition_y@current@[1, 0] )**2 )
		CellVol_L@current = 0.25 * sqrt ( 4.0 * a**2 * b**2 - (a**2 + b**2 - c**2 )**2 )
		CellVol_U@current = 0.25 * sqrt ( 4.0 * d**2 * e**2 - (d**2 + e**2 - c**2 )**2 )
		CellVol@current = CellVol_L@current + CellVol_U@current
	}

	@(all but finest) {
		loop over CellVol@current sequentially {
			Var volFiner : Real = CellVol@finer@[0, 0] + CellVol@finer@[1, 0] + CellVol@finer@[0, 1] + CellVol@finer@[1, 1]
			Var volDif : Real = CellVol@current - volFiner
			if ( fabs ( volDif ) > 2.0e-1 * CellVol@current ) {
				print ( 'Volume dif on level', levels@current ( ), 'is', fabs ( volDif ) * 100.0 / CellVol@current, '%',
						'   should be', volFiner, 'but is', CellVol@current )
			}
		}
	}

	@(all but coarsest) {
		InitPosData@coarser ( )
	}
}

Function InitLaplace@(all but finest) ( ) : Unit {
	loop over Laplace@current {
		//Laplace@current = ProlongateValue@finer * Laplace@finer * RestrictValue@finer
		//ProlongateValue@finer * Laplace@finer * RestrictValue@finer
		//RestrictValue@finer * Laplace@finer * ProlongateValue@finer 
		//ProlongateValue@finer * Laplace@finer * RestrictValue@current

		Val factor : Real = ( 1.0 / sqrt ( 2.0 ) ) * ( 1.0 / sqrt ( 2.0 ) )
		Laplace@current:[ 0,  0] = factor * (
			  Laplace@finer@[0, 0]:[ 0,  0] + Laplace@finer@[0, 0]:[ 1,  0] + Laplace@finer@[0, 0]:[ 0,  1] + Laplace@finer@[0, 0]:[ 1,  1]
			+ Laplace@finer@[1, 0]:[ 0,  0] + Laplace@finer@[1, 0]:[-1,  0] + Laplace@finer@[1, 0]:[ 0,  1] + Laplace@finer@[1, 0]:[-1,  1]
			+ Laplace@finer@[0, 1]:[ 0,  0] + Laplace@finer@[0, 1]:[ 1,  0] + Laplace@finer@[0, 1]:[ 0, -1] + Laplace@finer@[0, 1]:[ 1, -1]
			+ Laplace@finer@[1, 1]:[ 0,  0] + Laplace@finer@[1, 1]:[-1,  0] + Laplace@finer@[1, 1]:[ 0, -1] + Laplace@finer@[1, 1]:[-1, -1]
		)
		Laplace@current:[ 1,  0] = factor * (
			  Laplace@finer@[1, 0]:[ 1,  0] + Laplace@finer@[1, 0]:[ 1,  1]
			+ Laplace@finer@[1, 1]:[ 1,  0] + Laplace@finer@[1, 1]:[ 1, -1]
		)
		Laplace@current:[-1,  0] = factor * (
			  Laplace@finer@[0, 0]:[-1,  0] + Laplace@finer@[0, 0]:[-1,  1]
			+ Laplace@finer@[0, 1]:[-1,  0] + Laplace@finer@[0, 1]:[-1, -1]
		)
		Laplace@current:[ 0,  1] = factor * (
			  Laplace@finer@[0, 1]:[ 0,  1] + Laplace@finer@[0, 1]:[ 1,  1]
			+ Laplace@finer@[1, 1]:[ 0,  1] + Laplace@finer@[1, 1]:[-1,  1]
		)
		Laplace@current:[ 0, -1] = factor * (
			  Laplace@finer@[0, 0]:[ 0, -1] + Laplace@finer@[0, 0]:[ 1, -1]
			+ Laplace@finer@[1, 0]:[ 0, -1] + Laplace@finer@[1, 0]:[-1, -1]
		)
		Laplace@current:[ 1,  1] = factor * Laplace@finer@[1, 1]:[ 1,  1]
		Laplace@current:[ 1, -1] = factor * Laplace@finer@[1, 0]:[ 1, -1]
		Laplace@current:[-1,  1] = factor * Laplace@finer@[0, 1]:[-1,  1]
		Laplace@current:[-1, -1] = factor * Laplace@finer@[0, 0]:[-1, -1]

		// injection
		/*Laplace@current:[ 0,  0] = Laplace@finer:[ 0,  0]
		Laplace@current:[-1,  0] = Laplace@finer:[-1,  0]
		Laplace@current:[ 0,  1] = Laplace@finer:[ 0,  1]
		Laplace@current:[ 0, -1] = Laplace@finer:[ 0, -1]
		Laplace@current:[ 1,  1] = Laplace@finer:[ 1,  1]
		Laplace@current:[ 1, -1] = Laplace@finer:[ 1, -1]
		Laplace@current:[-1,  1] = Laplace@finer:[-1,  1]
		Laplace@current:[-1, -1] = Laplace@finer:[-1, -1]*/

		// coarsen coefficients separately
		/*Laplace@current:[ 0,  0] = RestrictValue@finer * Laplace@finer:[ 0,  0]
		Laplace@current:[-1,  0] = RestrictValue@finer * Laplace@finer:[-1,  0]
		Laplace@current:[ 0,  1] = RestrictValue@finer * Laplace@finer:[ 0,  1]
		Laplace@current:[ 0, -1] = RestrictValue@finer * Laplace@finer:[ 0, -1]
		Laplace@current:[ 1,  1] = RestrictValue@finer * Laplace@finer:[ 1,  1]
		Laplace@current:[ 1, -1] = RestrictValue@finer * Laplace@finer:[ 1, -1]
		Laplace@current:[-1,  1] = RestrictValue@finer * Laplace@finer:[-1,  1]
		Laplace@current:[-1, -1] = RestrictValue@finer * Laplace@finer:[-1, -1]*/

		if ( 256 == x && 256 == y ) {
			print ( 'GC Stencil at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace@current:[ 0,  0] )
			print ( '  [ 1,  0]', '=>', Laplace@current:[ 1,  0] )
			print ( '  [-1,  0]', '=>', Laplace@current:[-1,  0] )
			print ( '  [ 0,  1]', '=>', Laplace@current:[ 0,  1] )
			print ( '  [ 0, -1]', '=>', Laplace@current:[ 0, -1] )
			print ( '  [ 1,  1]', '=>', Laplace@current:[ 1,  1] )
			print ( '  [ 1, -1]', '=>', Laplace@current:[ 1, -1] )
			print ( '  [-1,  1]', '=>', Laplace@current:[-1,  1] )
			print ( '  [-1, -1]', '=>', Laplace@current:[-1, -1] )
		}
	}

	@(all but coarsest) {
		InitLaplace@coarser ( )
	}
}

Function InitLaplace@finest ( ) : Unit {
	// reset
	loop over Laplace@current {
		Laplace@current:[ 0,  0] = 0.0
		Laplace@current:[ 1,  0] = 0.0
		Laplace@current:[-1,  0] = 0.0
		Laplace@current:[ 0,  1] = 0.0
		Laplace@current:[ 0, -1] = 0.0
		Laplace@current:[ 1,  1] = 0.0
		Laplace@current:[ 1, -1] = 0.0
		Laplace@current:[-1,  1] = 0.0
		Laplace@current:[-1, -1] = 0.0
	}

	Val useSimpleInterpol : Boolean = true
	Val useRecipDist : Boolean = false
	Val useArea : Boolean = false
	Val useLaplacian : Boolean = false

	// east
	loop over Laplace@current sequentially {
		//Laplace@current:[ 1,  0] = -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[1, 0] - vf_nodePosAsVec@current@[1, 1]
		Var edge_0  : Vec2 = vf_cellCenAsVec@current@[1, 0] - vf_cellCenAsVec@current@[0, 0]
		//Var faceLen : Real = sqrt ( dot ( face_0, face_0 ) )
		//Var face_n  : Vec2 = face_0 / faceLen
		//Var edgeLen : Real = sqrt ( dot ( edge_0, edge_0 ) )
		//Var edge_n  : Vec2 = edge_0 / edgeLen
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace@current:[1, 0] -= alpha
		Laplace@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[1, 0] += 0.25 * beta
			Laplace@current:[0, 1] += 0.25 * beta
			Laplace@current:[1, 1] += 0.25 * beta
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[1, 0] -= 0.25 * beta
			Laplace@current:[0, -1] -= 0.25 * beta
			Laplace@current:[1, -1] -= 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_SE_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_SE_E : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[1, 0] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[1, 0] )**2 )
			Var coeff_SE_S : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[0, -1] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[0, -1] )**2 )
			Var coeff_SE_SE : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[1, -1] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[1, -1] )**2 )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] -= coeff_SE_C * beta
			Laplace@current:[1, 0] -= coeff_SE_E * beta
			Laplace@current:[0, -1] -= coeff_SE_S * beta
			Laplace@current:[1, -1] -= coeff_SE_SE * beta

			Var coeff_NE_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_NE_E : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[1, 0] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[1, 0] )**2 )
			Var coeff_NE_N : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[0, 1] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[0, 1] )**2 )
			Var coeff_NE_NE : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[1, 1] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[1, 1] )**2 )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] += coeff_NE_C * beta
			Laplace@current:[1, 0] += coeff_NE_E * beta
			Laplace@current:[0, 1] += coeff_NE_N * beta
			Laplace@current:[1, 1] += coeff_NE_NE * beta
		} else if ( useArea ) {
			Var coeff_SE_C : Real = CellVol@current@[0, 0]
			Var coeff_SE_E : Real = CellVol@current@[1, 0]
			Var coeff_SE_S : Real = CellVol@current@[0, -1]
			Var coeff_SE_SE : Real = CellVol@current@[1, -1]

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] -= coeff_SE_C * beta
			Laplace@current:[1, 0] -= coeff_SE_E * beta
			Laplace@current:[0, -1] -= coeff_SE_S * beta
			Laplace@current:[1, -1] -= coeff_SE_SE * beta

			Var coeff_NE_C : Real = CellVol@current@[0, 0]
			Var coeff_NE_E : Real = CellVol@current@[1, 0]
			Var coeff_NE_N : Real = CellVol@current@[0, 1]
			Var coeff_NE_NE : Real = CellVol@current@[1, 1]

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] += coeff_NE_C * beta
			Laplace@current:[1, 0] += coeff_NE_E * beta
			Laplace@current:[0, 1] += coeff_NE_N * beta
			Laplace@current:[1, 1] += coeff_NE_NE * beta
		} else if ( useLaplacian ) {
			Val x0_SE : Real = vf_nodePosition_x@current@[1, 0]
			Val y0_SE : Real = vf_nodePosition_y@current@[1, 0]
			Val x1_SE : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_SE : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_SE : Real = vf_cellCenter_x@current@[1, 0]
			Val y2_SE : Real = vf_cellCenter_y@current@[1, 0]
			Val x3_SE : Real = vf_cellCenter_x@current@[0, -1]
			Val y3_SE : Real = vf_cellCenter_y@current@[0, -1]
			Val x4_SE : Real = vf_cellCenter_x@current@[1, -1]
			Val y4_SE : Real = vf_cellCenter_y@current@[1, -1]

			Var Rx_SE : Real = ( x1_SE - x0_SE ) + ( x2_SE - x0_SE ) + ( x3_SE - x0_SE ) + ( x4_SE - x0_SE )
			Var Ry_SE : Real = ( y1_SE - y0_SE ) + ( y2_SE - y0_SE ) + ( y3_SE - y0_SE ) + ( y4_SE - y0_SE )
			Var Ixx_SE : Real = ( x1_SE - x0_SE )**2 + ( x2_SE - x0_SE )**2 + ( x3_SE - x0_SE )**2 + ( x4_SE - x0_SE )**2
			Var Iyy_SE : Real = ( y1_SE - y0_SE )**2 + ( y2_SE - y0_SE )**2 + ( y3_SE - y0_SE )**2 + ( y4_SE - y0_SE )**2
			Var Ixy_SE : Real = ( x1_SE - x0_SE ) * ( y1_SE - y0_SE ) + ( x2_SE - x0_SE ) * ( y2_SE - y0_SE ) + ( x3_SE - x0_SE ) * ( y3_SE - y0_SE ) + ( x4_SE - x0_SE ) * ( y4_SE - y0_SE )

			Var lambda_SE_x : Real = ( Ixy_SE * Ry_SE - Iyy_SE * Rx_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )
			Var lambda_SE_y : Real = ( Ixy_SE * Rx_SE - Ixx_SE * Ry_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )

			Var coeff_SE_C : Real = 1.0 + lambda_SE_x * ( x1_SE - x0_SE ) + lambda_SE_y * ( y1_SE - y0_SE )
			Var coeff_SE_E : Real = 1.0 + lambda_SE_x * ( x2_SE - x0_SE ) + lambda_SE_y * ( y2_SE - y0_SE )
			Var coeff_SE_S : Real = 1.0 + lambda_SE_x * ( x3_SE - x0_SE ) + lambda_SE_y * ( y3_SE - y0_SE )
			Var coeff_SE_SE : Real = 1.0 + lambda_SE_x * ( x4_SE - x0_SE ) + lambda_SE_y * ( y4_SE - y0_SE )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] -= coeff_SE_C * beta
			Laplace@current:[1, 0] -= coeff_SE_E * beta
			Laplace@current:[0, -1] -= coeff_SE_S * beta
			Laplace@current:[1, -1] -= coeff_SE_SE * beta

			Val x0_NE : Real = vf_nodePosition_x@current@[1, 1]
			Val y0_NE : Real = vf_nodePosition_y@current@[1, 1]
			Val x1_NE : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_NE : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_NE : Real = vf_cellCenter_x@current@[1, 0]
			Val y2_NE : Real = vf_cellCenter_y@current@[1, 0]
			Val x3_NE : Real = vf_cellCenter_x@current@[0, 1]
			Val y3_NE : Real = vf_cellCenter_y@current@[0, 1]
			Val x4_NE : Real = vf_cellCenter_x@current@[1, 1]
			Val y4_NE : Real = vf_cellCenter_y@current@[1, 1]

			Var Rx_NE : Real = ( x1_NE - x0_NE ) + ( x2_NE - x0_NE ) + ( x3_NE - x0_NE ) + ( x4_NE - x0_NE )
			Var Ry_NE : Real = ( y1_NE - y0_NE ) + ( y2_NE - y0_NE ) + ( y3_NE - y0_NE ) + ( y4_NE - y0_NE )
			Var Ixx_NE : Real = ( x1_NE - x0_NE )**2 + ( x2_NE - x0_NE )**2 + ( x3_NE - x0_NE )**2 + ( x4_NE - x0_NE )**2
			Var Iyy_NE : Real = ( y1_NE - y0_NE )**2 + ( y2_NE - y0_NE )**2 + ( y3_NE - y0_NE )**2 + ( y4_NE - y0_NE )**2
			Var Ixy_NE : Real = ( x1_NE - x0_NE ) * ( y1_NE - y0_NE ) + ( x2_NE - x0_NE ) * ( y2_NE - y0_NE ) + ( x3_NE - x0_NE ) * ( y3_NE - y0_NE ) + ( x4_NE - x0_NE ) * ( y4_NE - y0_NE )

			Var lambda_NE_x : Real = ( Ixy_NE * Ry_NE - Iyy_NE * Rx_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )
			Var lambda_NE_y : Real = ( Ixy_NE * Rx_NE - Ixx_NE * Ry_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )

			Var coeff_NE_C : Real = 1.0 + lambda_NE_x * ( x1_NE - x0_NE ) + lambda_NE_y * ( y1_NE - y0_NE )
			Var coeff_NE_E : Real = 1.0 + lambda_NE_x * ( x2_NE - x0_NE ) + lambda_NE_y * ( y2_NE - y0_NE )
			Var coeff_NE_N : Real = 1.0 + lambda_NE_x * ( x3_NE - x0_NE ) + lambda_NE_y * ( y3_NE - y0_NE )
			Var coeff_NE_NE : Real = 1.0 + lambda_NE_x * ( x4_NE - x0_NE ) + lambda_NE_y * ( y4_NE - y0_NE )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] += coeff_NE_C * beta
			Laplace@current:[1, 0] += coeff_NE_E * beta
			Laplace@current:[0, 1] += coeff_NE_N * beta
			Laplace@current:[1, 1] += coeff_NE_NE * beta
		}

		/*if ( fabs ( alpha ) > 2.0 || fabs ( alpha ) < 0.5 ) {
			print ( 'Alpha at ', x, ';', y, ':', alpha )
		}
		if ( fabs ( beta ) > 0.5 ) {
			print ( 'Beta at ', x, ';', y, ':', beta )
		}*/
		/*if ( 1.0 != alpha + beta ) {
			print ( 'Alpha and beta at ', x, ';', y, ':', alpha, ';', beta )
		}*/

		//@finest {
			/*if ( 512 == x && 512 == y ) {
				print ( 'Node_x:	', vf_nodePosition_x@current@[0, 0], vf_nodePosition_x@current@[1, 0], vf_nodePosition_x@current@[0, 1], vf_nodePosition_x@current@[1, 1] )
				print ( 'Node_y:	', vf_nodePosition_y@current@[0, 0], vf_nodePosition_y@current@[1, 0], vf_nodePosition_y@current@[0, 1], vf_nodePosition_y@current@[1, 1] )
				print ( 'CellCen:   ', vf_cellCenter_x@current, vf_cellCenter_y@current )
				print ( 'Normal:	', norm_x, norm_y )
				print ( 'NormalLen: ', sqrt ( norm_x**2 + norm_y**2 ) )
				print ( 'Face:	  ', face_0_x, face_0_y )
				print ( 'Face_n:	', face_n_x, face_n_y )
				print ( 'Face_nLen: ', sqrt ( face_n_x**2 + face_n_y**2 ) )
				print ( 'Edge:	  ', edge_0_x, edge_0_y )
				print ( 'Coeff:	 ', Laplace@current:[ 1,  0] )
				print ( 'Should be: ', -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current )
			}*/
			/*if ( Laplace@current:[ 1,  0] != -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current ) {
				print ( 'Wrong entry on level', levels@current ( ), Laplace@current:[ 1,  0], 'should be', -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current )
			}*/
		//}
	}

	// west
	loop over Laplace@current {
		//Laplace@current:[-1,  0] = -1.0 * vf_cellWidth_y@current / vf_cellWidth_x@current
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[0, 1] - vf_nodePosAsVec@current@[0, 0]
		Var edge_0  : Vec2 = vf_cellCenAsVec@current@[-1, 0] - vf_cellCenAsVec@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace@current:[-1, 0] -= alpha
		Laplace@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[-1, 0] -= 0.25 * beta
			Laplace@current:[0, 1] -= 0.25 * beta
			Laplace@current:[-1, 1] -= 0.25 * beta

			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[-1, 0] += 0.25 * beta
			Laplace@current:[0, -1] += 0.25 * beta
			Laplace@current:[-1, -1] += 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_NW_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_NW_W : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[-1, 0] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[-1, 0] )**2 )
			Var coeff_NW_N : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[0, 1] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[0, 1] )**2 )
			Var coeff_NW_NW : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[-1, 1] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[-1, 1] )**2 )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] -= coeff_NW_C * beta
			Laplace@current:[-1, 0] -= coeff_NW_W * beta
			Laplace@current:[0, 1] -= coeff_NW_N * beta
			Laplace@current:[-1, 1] -= coeff_NW_NW * beta

			Var coeff_SW_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_SW_W : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[-1, 0] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[-1, 0] )**2 )
			Var coeff_SW_S : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[0, -1] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[0, -1] )**2 )
			Var coeff_SW_SW : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[-1, -1] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[-1, -1] )**2 )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] += coeff_SW_C * beta
			Laplace@current:[-1, 0] += coeff_SW_W * beta
			Laplace@current:[0, -1] += coeff_SW_S * beta
			Laplace@current:[-1, -1] += coeff_SW_SW * beta
		} else if ( useArea ) {
			Var coeff_NW_C : Real = CellVol@current@[0, 0]
			Var coeff_NW_W : Real = CellVol@current@[-1, 0]
			Var coeff_NW_N : Real = CellVol@current@[0, 1]
			Var coeff_NW_NW : Real = CellVol@current@[-1, 1]

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] -= coeff_NW_C * beta
			Laplace@current:[-1, 0] -= coeff_NW_W * beta
			Laplace@current:[0, 1] -= coeff_NW_N * beta
			Laplace@current:[-1, 1] -= coeff_NW_NW * beta

			Var coeff_SW_C : Real = CellVol@current@[0, 0]
			Var coeff_SW_W : Real = CellVol@current@[-1, 0]
			Var coeff_SW_S : Real = CellVol@current@[0, -1]
			Var coeff_SW_SW : Real = CellVol@current@[-1, -1]

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] += coeff_SW_C * beta
			Laplace@current:[-1, 0] += coeff_SW_W * beta
			Laplace@current:[0, -1] += coeff_SW_S * beta
			Laplace@current:[-1, -1] += coeff_SW_SW * beta
		} else if ( useLaplacian ) {
			Val x0_NW : Real = vf_nodePosition_x@current@[-1, 1]
			Val y0_NW : Real = vf_nodePosition_y@current@[-1, 1]
			Val x1_NW : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_NW : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_NW : Real = vf_cellCenter_x@current@[-1, 0]
			Val y2_NW : Real = vf_cellCenter_y@current@[-1, 0]
			Val x3_NW : Real = vf_cellCenter_x@current@[0, 1]
			Val y3_NW : Real = vf_cellCenter_y@current@[0, 1]
			Val x4_NW : Real = vf_cellCenter_x@current@[-1, 1]
			Val y4_NW : Real = vf_cellCenter_y@current@[-1, 1]

			Var Rx_NW : Real = ( x1_NW - x0_NW ) + ( x2_NW - x0_NW ) + ( x3_NW - x0_NW ) + ( x4_NW - x0_NW )
			Var Ry_NW : Real = ( y1_NW - y0_NW ) + ( y2_NW - y0_NW ) + ( y3_NW - y0_NW ) + ( y4_NW - y0_NW )
			Var Ixx_NW : Real = ( x1_NW - x0_NW )**2 + ( x2_NW - x0_NW )**2 + ( x3_NW - x0_NW )**2 + ( x4_NW - x0_NW )**2
			Var Iyy_NW : Real = ( y1_NW - y0_NW )**2 + ( y2_NW - y0_NW )**2 + ( y3_NW - y0_NW )**2 + ( y4_NW - y0_NW )**2
			Var Ixy_NW : Real = ( x1_NW - x0_NW ) * ( y1_NW - y0_NW ) + ( x2_NW - x0_NW ) * ( y2_NW - y0_NW ) + ( x3_NW - x0_NW ) * ( y3_NW - y0_NW ) + ( x4_NW - x0_NW ) * ( y4_NW - y0_NW )

			Var lambda_NW_x : Real = ( Ixy_NW * Ry_NW - Iyy_NW * Rx_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )
			Var lambda_NW_y : Real = ( Ixy_NW * Rx_NW - Ixx_NW * Ry_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )

			Var coeff_NW_C : Real = 1.0 + lambda_NW_x * ( x1_NW - x0_NW ) + lambda_NW_y * ( y1_NW - y0_NW )
			Var coeff_NW_W : Real = 1.0 + lambda_NW_x * ( x2_NW - x0_NW ) + lambda_NW_y * ( y2_NW - y0_NW )
			Var coeff_NW_N : Real = 1.0 + lambda_NW_x * ( x3_NW - x0_NW ) + lambda_NW_y * ( y3_NW - y0_NW )
			Var coeff_NW_NW : Real = 1.0 + lambda_NW_x * ( x4_NW - x0_NW ) + lambda_NW_y * ( y4_NW - y0_NW )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] -= coeff_NW_C * beta
			Laplace@current:[-1, 0] -= coeff_NW_W * beta
			Laplace@current:[0, 1] -= coeff_NW_N * beta
			Laplace@current:[-1, 1] -= coeff_NW_NW * beta

			Val x0_SW : Real = vf_nodePosition_x@current@[-1, 0]
			Val y0_SW : Real = vf_nodePosition_y@current@[-1, 0]
			Val x1_SW : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_SW : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_SW : Real = vf_cellCenter_x@current@[-1, 0]
			Val y2_SW : Real = vf_cellCenter_y@current@[-1, 0]
			Val x3_SW : Real = vf_cellCenter_x@current@[0, -1]
			Val y3_SW : Real = vf_cellCenter_y@current@[0, -1]
			Val x4_SW : Real = vf_cellCenter_x@current@[-1, -1]
			Val y4_SW : Real = vf_cellCenter_y@current@[-1, -1]

			Var Rx_SW : Real = ( x1_SW - x0_SW ) + ( x2_SW - x0_SW ) + ( x3_SW - x0_SW ) + ( x4_SW - x0_SW )
			Var Ry_SW : Real = ( y1_SW - y0_SW ) + ( y2_SW - y0_SW ) + ( y3_SW - y0_SW ) + ( y4_SW - y0_SW )
			Var Ixx_SW : Real = ( x1_SW - x0_SW )**2 + ( x2_SW - x0_SW )**2 + ( x3_SW - x0_SW )**2 + ( x4_SW - x0_SW )**2
			Var Iyy_SW : Real = ( y1_SW - y0_SW )**2 + ( y2_SW - y0_SW )**2 + ( y3_SW - y0_SW )**2 + ( y4_SW - y0_SW )**2
			Var Ixy_SW : Real = ( x1_SW - x0_SW ) * ( y1_SW - y0_SW ) + ( x2_SW - x0_SW ) * ( y2_SW - y0_SW ) + ( x3_SW - x0_SW ) * ( y3_SW - y0_SW ) + ( x4_SW - x0_SW ) * ( y4_SW - y0_SW )

			Var lambda_SW_x : Real = ( Ixy_SW * Ry_SW - Iyy_SW * Rx_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )
			Var lambda_SW_y : Real = ( Ixy_SW * Rx_SW - Ixx_SW * Ry_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )

			Var coeff_SW_C : Real = 1.0 + lambda_SW_x * ( x1_SW - x0_SW ) + lambda_SW_y * ( y1_SW - y0_SW )
			Var coeff_SW_W : Real = 1.0 + lambda_SW_x * ( x2_SW - x0_SW ) + lambda_SW_y * ( y2_SW - y0_SW )
			Var coeff_SW_S : Real = 1.0 + lambda_SW_x * ( x3_SW - x0_SW ) + lambda_SW_y * ( y3_SW - y0_SW )
			Var coeff_SW_SW : Real = 1.0 + lambda_SW_x * ( x4_SW - x0_SW ) + lambda_SW_y * ( y4_SW - y0_SW )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] += coeff_SW_C * beta
			Laplace@current:[-1, 0] += coeff_SW_W * beta
			Laplace@current:[0, -1] += coeff_SW_S * beta
			Laplace@current:[-1, -1] += coeff_SW_SW * beta
		}
	}

	// north
	loop over Laplace@current {
		//Laplace@current:[ 0,  1] = -1.0 * vf_cellWidth_x@current / vf_cellWidth_y@current
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[1, 1] - vf_nodePosAsVec@current@[0, 1]
		Var edge_0  : Vec2 = vf_cellCenAsVec@current@[0, 1] - vf_cellCenAsVec@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace@current:[0, 1] -= alpha
		Laplace@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[0, 1] -= 0.25 * beta
			Laplace@current:[1, 0] -= 0.25 * beta
			Laplace@current:[1, 1] -= 0.25 * beta

			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[0, 1] += 0.25 * beta
			Laplace@current:[-1, 0] += 0.25 * beta
			Laplace@current:[-1, 1] += 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_NE_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_NE_E : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[1, 0] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[1, 0] )**2 )
			Var coeff_NE_N : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[0, 1] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[0, 1] )**2 )
			Var coeff_NE_NE : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 1] - vf_cellCenter_x@current@[1, 1] )**2 + ( vf_nodePosition_y@current@[1, 1] - vf_cellCenter_y@current@[1, 1] )**2 )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] -= coeff_NE_C * beta
			Laplace@current:[1, 0] -= coeff_NE_E * beta
			Laplace@current:[0, 1] -= coeff_NE_N * beta
			Laplace@current:[1, 1] -= coeff_NE_NE * beta

			Var coeff_NW_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_NW_W : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[-1, 0] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[-1, 0] )**2 )
			Var coeff_NW_N : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[0, 1] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[0, 1] )**2 )
			Var coeff_NW_NW : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[-1, 1] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[-1, 1] )**2 )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] += coeff_NW_C * beta
			Laplace@current:[-1, 0] += coeff_NW_W * beta
			Laplace@current:[0, 1] += coeff_NW_N * beta
			Laplace@current:[-1, 1] += coeff_NW_NW * beta
		} else if ( useArea ) {
			Var coeff_NE_C : Real = CellVol@current@[0, 0]
			Var coeff_NE_E : Real = CellVol@current@[1, 0]
			Var coeff_NE_N : Real = CellVol@current@[0, 1]
			Var coeff_NE_NE : Real = CellVol@current@[1, 1]

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] -= coeff_NE_C * beta
			Laplace@current:[1, 0] -= coeff_NE_E * beta
			Laplace@current:[0, 1] -= coeff_NE_N * beta
			Laplace@current:[1, 1] -= coeff_NE_NE * beta

			Var coeff_NW_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_NW_W : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[-1, 0] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[-1, 0] )**2 )
			Var coeff_NW_N : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[0, 1] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[0, 1] )**2 )
			Var coeff_NW_NW : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 1] - vf_cellCenter_x@current@[-1, 1] )**2 + ( vf_nodePosition_y@current@[-1, 1] - vf_cellCenter_y@current@[-1, 1] )**2 )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] += coeff_NW_C * beta
			Laplace@current:[-1, 0] += coeff_NW_W * beta
			Laplace@current:[0, 1] += coeff_NW_N * beta
			Laplace@current:[-1, 1] += coeff_NW_NW * beta
		} else if ( useLaplacian ) {
			Val x0_NE : Real = vf_nodePosition_x@current@[1, 1]
			Val y0_NE : Real = vf_nodePosition_y@current@[1, 1]
			Val x1_NE : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_NE : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_NE : Real = vf_cellCenter_x@current@[1, 0]
			Val y2_NE : Real = vf_cellCenter_y@current@[1, 0]
			Val x3_NE : Real = vf_cellCenter_x@current@[0, 1]
			Val y3_NE : Real = vf_cellCenter_y@current@[0, 1]
			Val x4_NE : Real = vf_cellCenter_x@current@[1, 1]
			Val y4_NE : Real = vf_cellCenter_y@current@[1, 1]

			Var Rx_NE : Real = ( x1_NE - x0_NE ) + ( x2_NE - x0_NE ) + ( x3_NE - x0_NE ) + ( x4_NE - x0_NE )
			Var Ry_NE : Real = ( y1_NE - y0_NE ) + ( y2_NE - y0_NE ) + ( y3_NE - y0_NE ) + ( y4_NE - y0_NE )
			Var Ixx_NE : Real = ( x1_NE - x0_NE )**2 + ( x2_NE - x0_NE )**2 + ( x3_NE - x0_NE )**2 + ( x4_NE - x0_NE )**2
			Var Iyy_NE : Real = ( y1_NE - y0_NE )**2 + ( y2_NE - y0_NE )**2 + ( y3_NE - y0_NE )**2 + ( y4_NE - y0_NE )**2
			Var Ixy_NE : Real = ( x1_NE - x0_NE ) * ( y1_NE - y0_NE ) + ( x2_NE - x0_NE ) * ( y2_NE - y0_NE ) + ( x3_NE - x0_NE ) * ( y3_NE - y0_NE ) + ( x4_NE - x0_NE ) * ( y4_NE - y0_NE )

			Var lambda_NE_x : Real = ( Ixy_NE * Ry_NE - Iyy_NE * Rx_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )
			Var lambda_NE_y : Real = ( Ixy_NE * Rx_NE - Ixx_NE * Ry_NE ) / ( Ixx_NE * Iyy_NE - Ixy_NE**2 )

			Var coeff_NE_C : Real = 1.0 + lambda_NE_x * ( x1_NE - x0_NE ) + lambda_NE_y * ( y1_NE - y0_NE )
			Var coeff_NE_E : Real = 1.0 + lambda_NE_x * ( x2_NE - x0_NE ) + lambda_NE_y * ( y2_NE - y0_NE )
			Var coeff_NE_N : Real = 1.0 + lambda_NE_x * ( x3_NE - x0_NE ) + lambda_NE_y * ( y3_NE - y0_NE )
			Var coeff_NE_NE : Real = 1.0 + lambda_NE_x * ( x4_NE - x0_NE ) + lambda_NE_y * ( y4_NE - y0_NE )

			Var coeffSum_NE : Real = coeff_NE_C + coeff_NE_E + coeff_NE_N + coeff_NE_NE
			coeff_NE_C /= coeffSum_NE
			coeff_NE_E /= coeffSum_NE
			coeff_NE_N /= coeffSum_NE
			coeff_NE_NE /= coeffSum_NE

			Laplace@current:[0, 0] -= coeff_NE_C * beta
			Laplace@current:[1, 0] -= coeff_NE_E * beta
			Laplace@current:[0, 1] -= coeff_NE_N * beta
			Laplace@current:[1, 1] -= coeff_NE_NE * beta

			Val x0_NW : Real = vf_nodePosition_x@current@[-1, 1]
			Val y0_NW : Real = vf_nodePosition_y@current@[-1, 1]
			Val x1_NW : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_NW : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_NW : Real = vf_cellCenter_x@current@[-1, 0]
			Val y2_NW : Real = vf_cellCenter_y@current@[-1, 0]
			Val x3_NW : Real = vf_cellCenter_x@current@[0, 1]
			Val y3_NW : Real = vf_cellCenter_y@current@[0, 1]
			Val x4_NW : Real = vf_cellCenter_x@current@[-1, 1]
			Val y4_NW : Real = vf_cellCenter_y@current@[-1, 1]

			Var Rx_NW : Real = ( x1_NW - x0_NW ) + ( x2_NW - x0_NW ) + ( x3_NW - x0_NW ) + ( x4_NW - x0_NW )
			Var Ry_NW : Real = ( y1_NW - y0_NW ) + ( y2_NW - y0_NW ) + ( y3_NW - y0_NW ) + ( y4_NW - y0_NW )
			Var Ixx_NW : Real = ( x1_NW - x0_NW )**2 + ( x2_NW - x0_NW )**2 + ( x3_NW - x0_NW )**2 + ( x4_NW - x0_NW )**2
			Var Iyy_NW : Real = ( y1_NW - y0_NW )**2 + ( y2_NW - y0_NW )**2 + ( y3_NW - y0_NW )**2 + ( y4_NW - y0_NW )**2
			Var Ixy_NW : Real = ( x1_NW - x0_NW ) * ( y1_NW - y0_NW ) + ( x2_NW - x0_NW ) * ( y2_NW - y0_NW ) + ( x3_NW - x0_NW ) * ( y3_NW - y0_NW ) + ( x4_NW - x0_NW ) * ( y4_NW - y0_NW )

			Var lambda_NW_x : Real = ( Ixy_NW * Ry_NW - Iyy_NW * Rx_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )
			Var lambda_NW_y : Real = ( Ixy_NW * Rx_NW - Ixx_NW * Ry_NW ) / ( Ixx_NW * Iyy_NW - Ixy_NW**2 )

			Var coeff_NW_C : Real = 1.0 + lambda_NW_x * ( x1_NW - x0_NW ) + lambda_NW_y * ( y1_NW - y0_NW )
			Var coeff_NW_W : Real = 1.0 + lambda_NW_x * ( x2_NW - x0_NW ) + lambda_NW_y * ( y2_NW - y0_NW )
			Var coeff_NW_N : Real = 1.0 + lambda_NW_x * ( x3_NW - x0_NW ) + lambda_NW_y * ( y3_NW - y0_NW )
			Var coeff_NW_NW : Real = 1.0 + lambda_NW_x * ( x4_NW - x0_NW ) + lambda_NW_y * ( y4_NW - y0_NW )

			Var coeffSum_NW : Real = coeff_NW_C + coeff_NW_W + coeff_NW_N + coeff_NW_NW
			coeff_NW_C /= coeffSum_NW
			coeff_NW_W /= coeffSum_NW
			coeff_NW_N /= coeffSum_NW
			coeff_NW_NW /= coeffSum_NW

			Laplace@current:[0, 0] += coeff_NW_C * beta
			Laplace@current:[-1, 0] += coeff_NW_W * beta
			Laplace@current:[0, 1] += coeff_NW_N * beta
			Laplace@current:[-1, 1] += coeff_NW_NW * beta
		}
	}

	// south
	loop over Laplace@current {
		//Laplace@current:[ 0, -1] = -1.0 * vf_cellWidth_x@current / vf_cellWidth_y@current
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[0, 0] - vf_nodePosAsVec@current@[1, 0]
		Var edge_0  : Vec2 = vf_cellCenAsVec@current@[0, -1] - vf_cellCenAsVec@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace@current:[0, -1] -= alpha
		Laplace@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace@current:[0, 0] -= 0.25 * beta
			Laplace@current:[0, -1] -= 0.25 * beta
			Laplace@current:[-1, 0] -= 0.25 * beta
			Laplace@current:[-1, -1] -= 0.25 * beta

			Laplace@current:[0, 0] += 0.25 * beta
			Laplace@current:[0, -1] += 0.25 * beta
			Laplace@current:[1, 0] += 0.25 * beta
			Laplace@current:[1, -1] += 0.25 * beta
		} else if ( useRecipDist ) {
			Var coeff_SW_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_SW_W : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[-1, 0] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[-1, 0] )**2 )
			Var coeff_SW_S : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[0, -1] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[0, -1] )**2 )
			Var coeff_SW_SW : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[-1, 0] - vf_cellCenter_x@current@[-1, -1] )**2 + ( vf_nodePosition_y@current@[-1, 0] - vf_cellCenter_y@current@[-1, -1] )**2 )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] -= coeff_SW_C * beta
			Laplace@current:[-1, 0] -= coeff_SW_W * beta
			Laplace@current:[0, -1] -= coeff_SW_S * beta
			Laplace@current:[-1, -1] -= coeff_SW_SW * beta

			Var coeff_SE_C : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[0, 0] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[0, 0] )**2 )
			Var coeff_SE_E : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[1, 0] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[1, 0] )**2 )
			Var coeff_SE_S : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[0, -1] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[0, -1] )**2 )
			Var coeff_SE_SE : Real = 1.0 / sqrt ( ( vf_nodePosition_x@current@[1, 0] - vf_cellCenter_x@current@[1, -1] )**2 + ( vf_nodePosition_y@current@[1, 0] - vf_cellCenter_y@current@[1, -1] )**2 )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] += coeff_SE_C * beta
			Laplace@current:[1, 0] += coeff_SE_E * beta
			Laplace@current:[0, -1] += coeff_SE_S * beta
			Laplace@current:[1, -1] += coeff_SE_SE * beta
		} else if ( useArea ) {
			Var coeff_SW_C : Real = CellVol@current@[0, 0]
			Var coeff_SW_W : Real = CellVol@current@[-1, 0]
			Var coeff_SW_S : Real = CellVol@current@[0, -1]
			Var coeff_SW_SW : Real = CellVol@current@[-1, -1]

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] -= coeff_SW_C * beta
			Laplace@current:[-1, 0] -= coeff_SW_W * beta
			Laplace@current:[0, -1] -= coeff_SW_S * beta
			Laplace@current:[-1, -1] -= coeff_SW_SW * beta

			Var coeff_SE_C : Real = CellVol@current@[0, 0]
			Var coeff_SE_E : Real = CellVol@current@[1, 0]
			Var coeff_SE_S : Real = CellVol@current@[0, -1]
			Var coeff_SE_SE : Real = CellVol@current@[1, -1]

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] += coeff_SE_C * beta
			Laplace@current:[1, 0] += coeff_SE_E * beta
			Laplace@current:[0, -1] += coeff_SE_S * beta
			Laplace@current:[1, -1] += coeff_SE_SE * beta
		} else if ( useLaplacian ) {
			Val x0_SW : Real = vf_nodePosition_x@current@[-1, 0]
			Val y0_SW : Real = vf_nodePosition_y@current@[-1, 0]
			Val x1_SW : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_SW : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_SW : Real = vf_cellCenter_x@current@[-1, 0]
			Val y2_SW : Real = vf_cellCenter_y@current@[-1, 0]
			Val x3_SW : Real = vf_cellCenter_x@current@[0, -1]
			Val y3_SW : Real = vf_cellCenter_y@current@[0, -1]
			Val x4_SW : Real = vf_cellCenter_x@current@[-1, -1]
			Val y4_SW : Real = vf_cellCenter_y@current@[-1, -1]

			Var Rx_SW : Real = ( x1_SW - x0_SW ) + ( x2_SW - x0_SW ) + ( x3_SW - x0_SW ) + ( x4_SW - x0_SW )
			Var Ry_SW : Real = ( y1_SW - y0_SW ) + ( y2_SW - y0_SW ) + ( y3_SW - y0_SW ) + ( y4_SW - y0_SW )
			Var Ixx_SW : Real = ( x1_SW - x0_SW )**2 + ( x2_SW - x0_SW )**2 + ( x3_SW - x0_SW )**2 + ( x4_SW - x0_SW )**2
			Var Iyy_SW : Real = ( y1_SW - y0_SW )**2 + ( y2_SW - y0_SW )**2 + ( y3_SW - y0_SW )**2 + ( y4_SW - y0_SW )**2
			Var Ixy_SW : Real = ( x1_SW - x0_SW ) * ( y1_SW - y0_SW ) + ( x2_SW - x0_SW ) * ( y2_SW - y0_SW ) + ( x3_SW - x0_SW ) * ( y3_SW - y0_SW ) + ( x4_SW - x0_SW ) * ( y4_SW - y0_SW )

			Var lambda_SW_x : Real = ( Ixy_SW * Ry_SW - Iyy_SW * Rx_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )
			Var lambda_SW_y : Real = ( Ixy_SW * Rx_SW - Ixx_SW * Ry_SW ) / ( Ixx_SW * Iyy_SW - Ixy_SW**2 )

			Var coeff_SW_C : Real = 1.0 + lambda_SW_x * ( x1_SW - x0_SW ) + lambda_SW_y * ( y1_SW - y0_SW )
			Var coeff_SW_W : Real = 1.0 + lambda_SW_x * ( x2_SW - x0_SW ) + lambda_SW_y * ( y2_SW - y0_SW )
			Var coeff_SW_S : Real = 1.0 + lambda_SW_x * ( x3_SW - x0_SW ) + lambda_SW_y * ( y3_SW - y0_SW )
			Var coeff_SW_SW : Real = 1.0 + lambda_SW_x * ( x4_SW - x0_SW ) + lambda_SW_y * ( y4_SW - y0_SW )

			Var coeffSum_SW : Real = coeff_SW_C + coeff_SW_W + coeff_SW_S + coeff_SW_SW
			coeff_SW_C /= coeffSum_SW
			coeff_SW_W /= coeffSum_SW
			coeff_SW_S /= coeffSum_SW
			coeff_SW_SW /= coeffSum_SW

			Laplace@current:[0, 0] -= coeff_SW_C * beta
			Laplace@current:[-1, 0] -= coeff_SW_W * beta
			Laplace@current:[0, -1] -= coeff_SW_S * beta
			Laplace@current:[-1, -1] -= coeff_SW_SW * beta

			Val x0_SE : Real = vf_nodePosition_x@current@[1, 0]
			Val y0_SE : Real = vf_nodePosition_y@current@[1, 0]
			Val x1_SE : Real = vf_cellCenter_x@current@[0, 0]
			Val y1_SE : Real = vf_cellCenter_y@current@[0, 0]
			Val x2_SE : Real = vf_cellCenter_x@current@[1, 0]
			Val y2_SE : Real = vf_cellCenter_y@current@[1, 0]
			Val x3_SE : Real = vf_cellCenter_x@current@[0, -1]
			Val y3_SE : Real = vf_cellCenter_y@current@[0, -1]
			Val x4_SE : Real = vf_cellCenter_x@current@[1, -1]
			Val y4_SE : Real = vf_cellCenter_y@current@[1, -1]

			Var Rx_SE : Real = ( x1_SE - x0_SE ) + ( x2_SE - x0_SE ) + ( x3_SE - x0_SE ) + ( x4_SE - x0_SE )
			Var Ry_SE : Real = ( y1_SE - y0_SE ) + ( y2_SE - y0_SE ) + ( y3_SE - y0_SE ) + ( y4_SE - y0_SE )
			Var Ixx_SE : Real = ( x1_SE - x0_SE )**2 + ( x2_SE - x0_SE )**2 + ( x3_SE - x0_SE )**2 + ( x4_SE - x0_SE )**2
			Var Iyy_SE : Real = ( y1_SE - y0_SE )**2 + ( y2_SE - y0_SE )**2 + ( y3_SE - y0_SE )**2 + ( y4_SE - y0_SE )**2
			Var Ixy_SE : Real = ( x1_SE - x0_SE ) * ( y1_SE - y0_SE ) + ( x2_SE - x0_SE ) * ( y2_SE - y0_SE ) + ( x3_SE - x0_SE ) * ( y3_SE - y0_SE ) + ( x4_SE - x0_SE ) * ( y4_SE - y0_SE )

			Var lambda_SE_x : Real = ( Ixy_SE * Ry_SE - Iyy_SE * Rx_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )
			Var lambda_SE_y : Real = ( Ixy_SE * Rx_SE - Ixx_SE * Ry_SE ) / ( Ixx_SE * Iyy_SE - Ixy_SE**2 )

			Var coeff_SE_C : Real = 1.0 + lambda_SE_x * ( x1_SE - x0_SE ) + lambda_SE_y * ( y1_SE - y0_SE )
			Var coeff_SE_E : Real = 1.0 + lambda_SE_x * ( x2_SE - x0_SE ) + lambda_SE_y * ( y2_SE - y0_SE )
			Var coeff_SE_S : Real = 1.0 + lambda_SE_x * ( x3_SE - x0_SE ) + lambda_SE_y * ( y3_SE - y0_SE )
			Var coeff_SE_SE : Real = 1.0 + lambda_SE_x * ( x4_SE - x0_SE ) + lambda_SE_y * ( y4_SE - y0_SE )

			Var coeffSum_SE : Real = coeff_SE_C + coeff_SE_E + coeff_SE_S + coeff_SE_SE
			coeff_SE_C /= coeffSum_SE
			coeff_SE_E /= coeffSum_SE
			coeff_SE_S /= coeffSum_SE
			coeff_SE_SE /= coeffSum_SE

			Laplace@current:[0, 0] += coeff_SE_C * beta
			Laplace@current:[1, 0] += coeff_SE_E * beta
			Laplace@current:[0, -1] += coeff_SE_S * beta
			Laplace@current:[1, -1] += coeff_SE_SE * beta
		}
	}

	// center
	loop over Laplace@current sequentially {
		//Laplace@current:[ 0,  0] = -1.0 * ( Laplace@current:[ 1,  0] + Laplace@current:[-1,  0] + Laplace@current:[ 0,  1] + Laplace@current:[ 0, -1] )

		if ( ( 512 == x && 512 == y ) ||
			fabs ( Laplace@current:[ 0,  0] ) > 5.0 || fabs ( Laplace@current:[ 0,  0] ) < 3.0
			|| fabs ( 
				Laplace@current:[ 0,  0]
				+ Laplace@current:[ 1,  0]
				+ Laplace@current:[-1,  0]
				+ Laplace@current:[ 0,  1]
				+ Laplace@current:[ 0, -1]
				+ Laplace@current:[ 1,  1]
				+ Laplace@current:[ 1, -1]
				+ Laplace@current:[-1,  1]
				+ Laplace@current:[-1, -1] ) > 1e-6 ) {
			print ( 'Stencil at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace@current:[ 0,  0] )
			print ( '  [ 1,  0]', '=>', Laplace@current:[ 1,  0] )
			print ( '  [-1,  0]', '=>', Laplace@current:[-1,  0] )
			print ( '  [ 0,  1]', '=>', Laplace@current:[ 0,  1] )
			print ( '  [ 0, -1]', '=>', Laplace@current:[ 0, -1] )
			print ( '  [ 1,  1]', '=>', Laplace@current:[ 1,  1] )
			print ( '  [ 1, -1]', '=>', Laplace@current:[ 1, -1] )
			print ( '  [-1,  1]', '=>', Laplace@current:[-1,  1] )
			print ( '  [-1, -1]', '=>', Laplace@current:[-1, -1] )
		}
	}

	@(all but coarsest) {
		InitLaplace@coarser ( )
	}
}

Function CoarsenLaplace_Tri@(all but finest) ( ) : Unit {
	Val factor : Real = ( 1.0 / sqrt ( 2.0 ) ) * ( 1.0 / sqrt ( 2.0 ) )

	loop over Laplace_L_L@current {
		Laplace_L_L@current:[ 0,  0] = factor * (
			  Laplace_L_L@finer@[0, 0]:[ 0,  0] + Laplace_L_U@finer@[0, 0]:[ 0,  0]
			+ Laplace_L_L@finer@[1, 0]:[ 0,  0] + Laplace_L_U@finer@[1, 0]:[-1,  0]
			+ Laplace_L_L@finer@[0, 1]:[ 0,  0] + Laplace_L_U@finer@[0, 1]:[ 0, -1]
			+ Laplace_U_U@finer@[0, 0]:[ 0,  0] + Laplace_U_L@finer@[0, 0]:[ 0,  0]
			+ Laplace_U_L@finer@[0, 0]:[ 1,  0] + Laplace_U_L@finer@[0, 0]:[ 0,  1]
		)
	}
	
	loop over Laplace_L_U@current {
		Laplace_L_U@current:[ 0,  0] = factor * ( Laplace_L_U@finer@[1, 0]:[ 0,  0] + Laplace_L_U@finer@[0, 1]:[ 0,  0] )
		Laplace_L_U@current:[-1,  0] = factor * ( Laplace_L_U@finer@[0, 0]:[-1,  0] + Laplace_L_U@finer@[0, 1]:[-1,  0] )
		Laplace_L_U@current:[ 0, -1] = factor * ( Laplace_L_U@finer@[0, 0]:[ 0, -1] + Laplace_L_U@finer@[1, 0]:[ 0, -1] )
	}

	loop over Laplace_U_U@current {
		Laplace_U_U@current:[ 0,  0] = factor * (
			  Laplace_U_U@finer@[1, 1]:[ 0,  0] + Laplace_U_L@finer@[1, 1]:[ 0,  0]
			+ Laplace_U_U@finer@[1, 0]:[ 0,  0] + Laplace_U_L@finer@[1, 0]:[ 0,  1]
			+ Laplace_U_U@finer@[0, 1]:[ 0,  0] + Laplace_U_L@finer@[0, 1]:[ 1,  0]
			+ Laplace_L_L@finer@[1, 1]:[ 0,  0] + Laplace_L_U@finer@[1, 1]:[ 0,  0]
			+ Laplace_L_U@finer@[1, 1]:[-1,  0] + Laplace_L_U@finer@[1, 1]:[ 0, -1]
		)
	}
	
	loop over Laplace_U_L@current {
		Laplace_U_L@current:[ 0,  0] = factor * ( Laplace_U_L@finer@[1, 0]:[ 0,  0] + Laplace_U_L@finer@[0, 1]:[ 0,  0] )
		Laplace_U_L@current:[ 1,  0] = factor * ( Laplace_U_L@finer@[1, 0]:[ 1,  0] + Laplace_U_L@finer@[1, 1]:[ 1,  0] )
		Laplace_U_L@current:[ 0,  1] = factor * ( Laplace_U_L@finer@[0, 1]:[ 0,  1] + Laplace_U_L@finer@[1, 1]:[ 0,  1] )
	}

	@(all but coarsest) {
		CoarsenLaplace_Tri@coarser ( )
	}
}

Function InitLaplace_Tri@all ( ) : Unit {
	// reset
	loop over Laplace_L_L@current {
		Laplace_L_L@current:[ 0,  0] = 0.0

		Laplace_L_L@current:[-1,  0] = 0.0
		Laplace_L_L@current:[ 1,  0] = 0.0
		Laplace_L_L@current:[ 0, -1] = 0.0
		Laplace_L_L@current:[ 0,  1] = 0.0
		Laplace_L_L@current:[-1,  1] = 0.0
		Laplace_L_L@current:[ 1, -1] = 0.0
	}

	loop over Laplace_L_U@current {
		Laplace_L_U@current:[ 0,  0] = 0.0
		Laplace_L_U@current:[-1,  0] = 0.0
		Laplace_L_U@current:[ 0, -1] = 0.0

		Laplace_L_U@current:[-1,  1] = 0.0
		Laplace_L_U@current:[-1, -1] = 0.0
		Laplace_L_U@current:[ 1, -1] = 0.0
	}

	loop over Laplace_U_U@current {
		Laplace_U_U@current:[ 0,  0] = 0.0

		Laplace_U_U@current:[-1,  0] = 0.0
		Laplace_U_U@current:[ 1,  0] = 0.0
		Laplace_U_U@current:[ 0, -1] = 0.0
		Laplace_U_U@current:[ 0,  1] = 0.0
		Laplace_U_U@current:[-1,  1] = 0.0
		Laplace_U_U@current:[ 1, -1] = 0.0
	}

	loop over Laplace_U_L@current {
		Laplace_U_L@current:[ 0,  0] = 0.0
		Laplace_U_L@current:[ 1,  0] = 0.0
		Laplace_U_L@current:[ 0,  1] = 0.0

		Laplace_U_L@current:[-1,  1] = 0.0
		Laplace_U_L@current:[ 1,  1] = 0.0
		Laplace_U_L@current:[ 1, -1] = 0.0
	}

	Val useSimpleInterpol : Boolean = true
	Val useRecipDist : Boolean = false
	Val useArea : Boolean = false
	Val useLaplacian : Boolean = false

	// lower west
	loop over Laplace_L_L@current {
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[0, 1] - vf_nodePosAsVec@current@[0, 0]
		Var edge_0  : Vec2 = CellCen_U@current@[-1, 0] - CellCen_L@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace_L_U@current:[-1, 0] -= alpha
		Laplace_L_L@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace_L_L@current:[0, 0] -= beta / 6.0
			Laplace_L_U@current:[0, 0] -= beta / 6.0
			Laplace_L_U@current:[-1, 0] -= beta / 6.0
			Laplace_L_L@current:[0, 1] -= beta / 6.0
			Laplace_L_L@current:[-1, 1] -= beta / 6.0
			Laplace_L_U@current:[-1, 1] -= beta / 6.0

			Laplace_L_L@current:[0, 0] += beta / 6.0
			Laplace_L_L@current:[-1, 0] += beta / 6.0
			Laplace_L_U@current:[-1, 0] += beta / 6.0
			Laplace_L_L@current:[0, -1] += beta / 6.0
			Laplace_L_U@current:[0, -1] += beta / 6.0
			Laplace_L_U@current:[-1, -1] += beta / 6.0
		}
	}

	// lower south
	loop over Laplace_L_L@current {
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[0, 0] - vf_nodePosAsVec@current@[1, 0]
		Var edge_0  : Vec2 = CellCen_U@current@[0, -1] - CellCen_L@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace_L_U@current:[0, -1] -= alpha
		Laplace_L_L@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace_L_L@current:[0, 0] -= beta / 6.0
			Laplace_L_L@current:[-1, 0] -= beta / 6.0
			Laplace_L_U@current:[-1, 0] -= beta / 6.0
			Laplace_L_L@current:[0, -1] -= beta / 6.0
			Laplace_L_U@current:[0, -1] -= beta / 6.0
			Laplace_L_U@current:[-1, -1] -= beta / 6.0

			Laplace_L_L@current:[0, 0] += beta / 6.0
			Laplace_L_U@current:[0, 0] += beta / 6.0
			Laplace_L_L@current:[1, 0] += beta / 6.0
			Laplace_L_U@current:[0, -1] += beta / 6.0
			Laplace_L_L@current:[1, -1] += beta / 6.0
			Laplace_L_U@current:[1, -1] += beta / 6.0
		}
	}

	// lower diagonal
	loop over Laplace_L_L@current {
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[1, 0] - vf_nodePosAsVec@current@[0, 1]
		Var edge_0  : Vec2 = CellCen_U@current@[0, 0] - CellCen_L@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace_L_U@current:[0, 0] -= alpha
		Laplace_L_L@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace_L_L@current:[0, 0] -= beta / 6.0
			Laplace_L_U@current:[0, 0] -= beta / 6.0
			Laplace_L_L@current:[1, 0] -= beta / 6.0
			Laplace_L_U@current:[0, -1] -= beta / 6.0
			Laplace_L_L@current:[1, -1] -= beta / 6.0
			Laplace_L_U@current:[1, -1] -= beta / 6.0

			Laplace_L_L@current:[0, 0] += beta / 6.0
			Laplace_L_U@current:[0, 0] += beta / 6.0
			Laplace_L_U@current:[-1, 0] += beta / 6.0
			Laplace_L_L@current:[0, 1] += beta / 6.0
			Laplace_L_L@current:[-1, 1] += beta / 6.0
			Laplace_L_U@current:[-1, 1] += beta / 6.0
		}
	}

	// upper east
	loop over Laplace_U_U@current {
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[1, 0] - vf_nodePosAsVec@current@[1, 1]
		Var edge_0  : Vec2 = CellCen_L@current@[1, 0] - CellCen_U@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace_U_L@current:[1, 0] -= alpha
		Laplace_U_U@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace_U_L@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[0, 0] -= beta / 6.0
			Laplace_U_L@current:[1, 0] -= beta / 6.0
			Laplace_U_U@current:[0, -1] -= beta / 6.0
			Laplace_U_L@current:[1, -1] -= beta / 6.0
			Laplace_U_U@current:[1, -1] -= beta / 6.0

			Laplace_U_U@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[1, 0] += beta / 6.0
			Laplace_U_L@current:[1, 0] += beta / 6.0
			Laplace_U_U@current:[0, 1] += beta / 6.0
			Laplace_U_L@current:[0, 1] += beta / 6.0
			Laplace_U_L@current:[1, 1] += beta / 6.0
		}
	}

	// upper north
	loop over Laplace_U_U@current {
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[1, 1] - vf_nodePosAsVec@current@[0, 1]
		Var edge_0  : Vec2 = CellCen_L@current@[0, 1] - CellCen_U@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace_U_L@current:[0, 1] -= alpha
		Laplace_U_U@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace_U_U@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[1, 0] -= beta / 6.0
			Laplace_U_L@current:[1, 0] -= beta / 6.0
			Laplace_U_U@current:[0, 1] -= beta / 6.0
			Laplace_U_L@current:[0, 1] -= beta / 6.0
			Laplace_U_L@current:[1, 1] -= beta / 6.0

			Laplace_U_L@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[-1, 0] += beta / 6.0
			Laplace_U_L@current:[0, 1] += beta / 6.0
			Laplace_U_L@current:[-1, 1] += beta / 6.0
			Laplace_U_U@current:[-1, 1] += beta / 6.0
		}
	}

	// upper diag
	loop over Laplace_U_U@current {
		Var face_0  : Vec2 = vf_nodePosAsVec@current@[0, 1] - vf_nodePosAsVec@current@[1, 0]
		Var edge_0  : Vec2 = CellCen_L@current@[0, 0] - CellCen_U@current@[0, 0]
		Var alpha   : Real = dot ( face_0, face_0 ) / cross ( face_0, edge_0 )
		Var beta    : Real = dot ( edge_0, face_0 ) / cross ( edge_0, face_0 )
		Laplace_U_L@current:[0, 0] -= alpha
		Laplace_U_U@current:[0, 0] += alpha

		if ( useSimpleInterpol ) {
			Laplace_U_L@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[0, 0] -= beta / 6.0
			Laplace_U_U@current:[-1, 0] -= beta / 6.0
			Laplace_U_L@current:[0, 1] -= beta / 6.0
			Laplace_U_L@current:[-1, 1] -= beta / 6.0
			Laplace_U_U@current:[-1, 1] -= beta / 6.0

			Laplace_U_L@current:[0, 0] += beta / 6.0
			Laplace_U_U@current:[0, 0] += beta / 6.0
			Laplace_U_L@current:[1, 0] += beta / 6.0
			Laplace_U_U@current:[0, -1] += beta / 6.0
			Laplace_U_L@current:[1, -1] += beta / 6.0
			Laplace_U_U@current:[1, -1] += beta / 6.0
		}
	}

	loop over Laplace_L_L@current {
		if ( 512 == x && 512 == y ) {
			print ( 'Laplace_L_L at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_L_L@current:[ 0,  0] )
			print ( 'Laplace_L_U at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_L_U@current:[ 0,  0] )
			print ( '  [-1,  0]', '=>', Laplace_L_U@current:[-1,  0] )
			print ( '  [ 0, -1]', '=>', Laplace_L_U@current:[ 0, -1] )
			print ( 'Laplace_U_U at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_U_U@current:[ 0,  0] )
			print ( 'Laplace_U_L at ', x, ';', y )
			print ( '  [ 0,  0]', '=>', Laplace_U_L@current:[ 0,  0] )
			print ( '  [ 1,  0]', '=>', Laplace_U_L@current:[ 1,  0] )
			print ( '  [ 0,  1]', '=>', Laplace_U_L@current:[ 0,  1] )
		}
	}

	@(all but coarsest) {
		if (false) {
			CoarsenLaplace_Tri@coarser ( )
		} else {
			InitLaplace_Tri@coarser ( )
		}
	}
}

Function Solve ( ) : Unit {
	UpResidual@finest ( )
	Variable resStart_0 : Real = NormResidual_0@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( 'Starting residual at 0', resStart_0 )
	startTimer ( 'timeToSolve' )
	Variable numIt : Integer = 0
	repeat until (res_0 < ( 1.0E-5 * resStart_0 ) || numIt >= 100) {
		numIt += 1
		startTimer ( 'cycle' )
		VCycle@finest (  )
		stopTimer ( 'cycle' )
		if (getTotalFromTimer ( 'cycle' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		startTimer ( 'convergenceChecking' )
		UpResidual@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_0@finest ( )
		print ( 'Error at 0:', curError_0 )
	stopTimer ( 'convergenceChecking' )
	}
	stopTimer ( 'timeToSolve' )
	print ( 'Total time to solve in', numIt, 'steps :', getTotalFromTimer ( 'timeToSolve' ) )
	print ( 'Mean time per vCycle: ', getMeanFromTimer ( 'cycle' ) )
}

Function Solve_Tri ( ) : Unit {
	UpResidual_Tri@finest ( )
	Variable resStart_0 : Real = NormResidual_Tri@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( 'Starting residual at 0', resStart_0 )
	startTimer ( 'timeToSolve_Tri' )
	Variable numIt : Integer = 0
	repeat until (res_0 < ( 1.0E-5 * resStart_0 ) || numIt >= 100) {
		numIt += 1
		startTimer ( 'cycle_Tri' )
		VCycle_Tri@finest (  )
		stopTimer ( 'cycle_Tri' )
		if (getTotalFromTimer ( 'cycle_Tri' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle_Tri' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		startTimer ( 'convergenceChecking_Tri' )
		UpResidual_Tri@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_Tri@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_Tri@finest ( )
		print ( 'Error at 0:', curError_0 )
	stopTimer ( 'convergenceChecking_Tri' )
	}
	stopTimer ( 'timeToSolve_Tri' )
	print ( 'Total time to solve in', numIt, 'steps :', getTotalFromTimer ( 'timeToSolve_Tri' ) )
	print ( 'Mean time per vCycle: ', getMeanFromTimer ( 'cycle_Tri' ) )
}

Function Application ( ) : Unit {
	startTimer ( 'setup' )
	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )
	initGeometry ( )
	stopTimer ( 'setup' )
	print ( 'Total time to setup: ', getTotalFromTimer ( 'setup' ) )
	startTimer ( 'init' )
	InitPosData@finest ( )
	InitLaplace@finest ( )
	InitLaplace_Tri@finest ( )
	InitRHS@finest ( )
	InitRHS_Tri@finest ( )
	InitSolution ( )
	InitSolution_Tri ( )
	stopTimer ( 'init' )
	print ( 'Total time to init: ', getTotalFromTimer ( 'init' ) )
	Solve ( )
	Solve_Tri ( )
	destroyGlobals ( )
}

