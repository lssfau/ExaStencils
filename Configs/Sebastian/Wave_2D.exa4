Domain global< [ 0, 0 ] to [ 1, 1 ] >

Layout NoComm< Real, Cell >@all {
	ghostLayers = [ 0, 0 ]
	duplicateLayers = [ 0, 0 ]
}
Layout BasicComm< Real, Cell >@all {
	ghostLayers = [ 1, 1 ] with communication
	duplicateLayers = [ 0, 0 ] with communication
}

Field Solution< global, BasicComm, 0.0 >@(all but finest)
Field Solution< global, BasicComm, sin ( vf_boundaryCoord_x@current * PI ) * sin ( curTime ) >[3]@finest
Field Residual< global, BasicComm, 0.0 >@all
Field RHS< global, NoComm, None >@all
Field VecP< global, BasicComm, 0.0 >@coarsest
Field VecGradP< global, NoComm, None >@coarsest

Field ColorVal< global, NoComm, None >@finest

Stencil Laplace@all {
	[ 0,  0] => ( 1.0 / ( dt**2 ) + 2.0 * c / ( vf_cellWidth_x@current * vf_cellWidth_x@current ) + 2.0 * c / ( vf_cellWidth_y@current * vf_cellWidth_y@current ) )
	[ 1,  0] => ( ( -1.0 * c / ( vf_cellWidth_x@current * vf_cellWidth_x@current ) ) )
	[-1,  0] => ( ( -1.0 * c / ( vf_cellWidth_x@current * vf_cellWidth_x@current ) ) )
	[ 0,  1] => ( ( -1.0 * c / ( vf_cellWidth_y@current * vf_cellWidth_y@current ) ) )
	[ 0, -1] => ( ( -1.0 * c / ( vf_cellWidth_y@current * vf_cellWidth_y@current ) ) )
}
Stencil CorrectionStencil@all {
	[ 0, 0] => 1.0
}
Stencil RestrictionStencil@all {
	[ 0,  0] => ( 1.0 / 4.0 )
	[ 0,  1] => ( 1.0 / 4.0 )
	[ 1,  0] => ( 1.0 / 4.0 )
	[ 1,  1] => ( 1.0 / 4.0 )
}

Globals {
	Var c : Real = 128.0
	Var dt : Real = 1.0 / 64.0
	Var curTime : Real = 0.0
	Var maxTime : Real = 100.0
}

Function VCycle@coarsest ( ) : Unit {
	VCycle_0@current ( )
}
Function VCycle_0@coarsest ( ) : Unit {
	UpResidual@current ( )
	apply bc to Residual@current
	communicate Residual@current
	Variable res : Real = NormResidual_0@current ( )
	Variable initialRes : Real = res
	loop over VecP@current {
		VecP@current = Residual@current
	}
	Variable cgSteps : Integer
	repeat 512 times count cgSteps {
	apply bc to VecP@current
	communicate VecP@current
		loop over VecP@current {
			VecGradP@current = Laplace@current * VecP@current
		}
		Variable alphaDenom : Real = 0
		loop over VecP@current with reduction( + : alphaDenom ) {
			alphaDenom += VecP@current * VecGradP@current
		}
		Variable alpha : Real = res * res / alphaDenom
		loop over Solution@current {
			Solution[currentSlot]@current += alpha * VecP@current
			Residual@current -= alpha * VecGradP@current
		}
		Variable nextRes : Real = NormResidual_0@current ( )
		if ( nextRes <= 0.001 * initialRes ) {
			return
		}
		Variable beta : Real = (nextRes * nextRes) / (res * res)
		loop over VecP@current {
			VecP@current = Residual@current + beta * VecP@current
		}
		res = nextRes
	}
	print ( 'Maximum number of cgs iterations (', 512, ') was exceeded' )
}

Function VCycle@((coarsest + 1) to finest) ( ) : Unit {
	repeat 3 times {
		Smoother@current ( )
	}
	UpResidual@current ( )
	Restriction@current ( )
	SetSolution@coarser ( 0 )
		VCycle@coarser ( )
	Correction@current ( )
	repeat 3 times {
		Smoother@current ( )
	}
}

Function Smoother@((coarsest + 1) to finest) ( ) : Unit {
	apply bc to Solution@current
	communicate Solution@current where 1 == ((64 + x + y) % 2)
	loop over Solution@current where 0 == ((x + y) % 2) {
		Solution@current = Solution@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 1.0 ) * ( RHS@current - Laplace@current * Solution@current ) )
	}
	apply bc to Solution@current
	communicate Solution@current where 0 == ((64 + x + y) % 2)
	loop over Solution@current where 1 == ((x + y) % 2) {
		Solution@current = Solution@current + ( ( ( 1.0 / diag ( Laplace@current ) ) * 1.0 ) * ( RHS@current - Laplace@current * Solution@current ) )
	}
}

Function UpResidual@all (  ) : Unit {
	apply bc to Solution[active]@current
	communicate Solution[active]@current
	loop over Residual@current {
		Residual@current = RHS@current - (Laplace@current * Solution[active]@current)
	}
}
Function NormResidual_0@(coarsest and finest) ( ) : Real {
	Variable res : Real = 0
	loop over Residual@current with reduction( + : res ) {
		res += Residual@current * Residual@current
	}
	return sqrt ( res )
}

Function NormError_0@(finest) ( ) : Real {
	Variable err : Real = 0
	loop over Solution@current with reduction( max : err ) {
		Variable curErr : Real = fabs ( Solution[active]@current - ( sin ( PI * vf_cellCenter_x@current ) * sinh ( PI * vf_cellCenter_y@current ) ) )
		err = max ( err, curErr )
	}
	return ( err )
}

Function Restriction@((coarsest + 1) to finest) ( ) : Unit {
	apply bc to Residual@current
	communicate ghost of Residual@current
	loop over RHS@coarser {
		RHS@coarser = RestrictionStencil@current * Residual@current
	}
}
Function Correction@((coarsest + 1) to finest) ( ) : Unit {
	apply bc to Solution[active]@coarser
	communicate ghost of Solution[active]@coarser
	loop over Solution@current {
		Solution[active]@current += CorrectionStencil@current * Solution[active]@coarser
	}
}

Function SetSolution@all (value : Real) : Unit {
	loop over Solution@current {
		Solution[active]@current = value
	}
}
Function InitSolution@finest ( ) : Unit {
	loop over Solution@current {
		//Solution[previous]@current = 0
		//Solution[active]@current = 0
		Solution[next]@current = 0
		//Solution[next]@current = max ( 0.0, 1.0 - ( vf_cellCenter_x@current - 0.5 ) ** 2 ) * max ( 0.0, 1.0 - ( vf_cellCenter_y@current - 0.5 ) ** 2 )
		//Solution[next]@current = sin ( vf_cellCenter_x@current * PI ) * cos ( vf_cellCenter_y@current * PI )
		//Solution[next]@current = max ( 0.0, 1.0 - fabs ( 64. * vf_cellCenter_x@current - 32. ) )
		//Solution[next]@current = max ( 0.0, 1.0 - fabs ( 64. * vf_cellCenter_x@current - 64. ) )
		Solution[previous]@current = Solution[next]@current
		Solution[active]@current = Solution[next]@current
	}
	advance Solution@current
}
Function InitRHS@finest ( ) : Unit {
	loop over RHS@current {
		RHS@current = 0.0
	}
}

Function TimeStep@finest ( ) : Unit {
	if ( false ) {
		loop over Solution@current {
			Solution[next]@current = c * dt * dt * ( Laplace@current * Solution[active]@current ) + 2. * Solution[active]@current - Solution[previous]@current
			//Solution[next]@current = c * dt * ( Laplace@current * Solution[active]@current ) + Solution[active]@current
		}
		advance Solution@current
	} else {
		loop over RHS@current {
			RHS@current = ( 2. * Solution[active]@current - Solution[previous]@current ) / ( dt**2 )
		}
		loop over Solution@current {
			Solution[next]@current = Solution[active]@current
		}
		
		advance Solution@current
		
		Solve ( )
	}
}

Function Solve ( ) : Unit {
	UpResidual@finest ( )
	Variable resStart_0 : Real = NormResidual_0@finest (  )
	Variable res_0 : Real = resStart_0
	Variable resOld_0 : Real = 0
	print ( 'Starting residual at 0', resStart_0 )
	startTimer ( 'timeToSolve' )
	Variable numIt : Integer = 0
	repeat until (res_0 <= 1.0E-5 * resStart_0 || numIt >= 10) {
		numIt += 1
		startTimer ( 'cycle' )
		VCycle@finest (  )
		stopTimer ( 'cycle' )
		if (getTotalFromTimer ( 'cycle' ) > 1200000 ) {
			print ( 'Aborting solve after', getTotalFromTimer ( 'cycle' ), 'ms which exceeds the limit of', 1200000, 'ms' )
			return
		}
		startTimer ( 'convergenceChecking' )
		UpResidual@finest ( )
		resOld_0 = res_0
		res_0 = NormResidual_0@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError_0@finest ( )
		print ( 'Error at 0:', curError_0 )
	stopTimer ( 'convergenceChecking' )
	}
	stopTimer ( 'timeToSolve' )
	print ( 'Total time to solve in', numIt, 'steps :', getTotalFromTimer ( 'timeToSolve' ) )
	print ( 'Mean time per vCycle: ', getMeanFromTimer ( 'cycle' ) )
}

Function Application ( ) : Unit {
	startTimer ( 'setup' )
	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )
	stopTimer ( 'setup' )
	print ( 'Total time to setup: ', getTotalFromTimer ( 'setup' ) )
	InitRHS@finest ( )
	InitSolution@finest ( )
	//Solve ( )
	
	Var it : Int = 0
	repeat until curTime >= maxTime {
		if ( 0 == it % 16 ) {
			print ( 'Printing', it / 16 )
			
			loop over ColorVal@finest {
				// mapping to [0; 1]
				ColorVal@finest = 0.5 * Solution@finest + 0.5
			}

			Var filename : String
			buildString ( filename, "wave_", it / 16, ".png" )
			writeMappedImage ( ColorVal@finest, filename )
		}

		TimeStep@finest ( )
		curTime += dt
		it += 1

		//showImage ( Solution[next]@finest, Solution[previous]@finest, Solution[active]@finest )
	}

	destroyGlobals ( )
}

