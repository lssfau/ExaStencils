
Stencil RestrictionCell@all from default restriction on Cell with 'linear'
Stencil CorrectionCell@all from default prolongation on Cell with 'linear'

Stencil RestrictionFaceX@all from default restriction on Face_x with 'linear'
Stencil CorrectionFaceX@all from default prolongation on Face_x with 'linear'

Stencil RestrictionFaceY@all from default restriction on Face_y with 'linear'
Stencil CorrectionFaceY@all from default prolongation on Face_y with 'linear'

Stencil RestrictionCellIntegral@all from default restriction on Cell with 'integral_linear'
Stencil CorrectionCellIntegral@all from default prolongation on Cell with 'integral_linear'

Stencil RestrictionFaceXIntegral@all from default restriction on Face_x with 'integral_linear'
Stencil CorrectionFaceXIntegral@all from default prolongation on Face_x with 'integral_linear'

Stencil RestrictionFaceYIntegral@all from default restriction on Face_y with 'integral_linear'
Stencil CorrectionFaceYIntegral@all from default prolongation on Face_y with 'integral_linear'


Field uApprox from u
Field vApprox from v
Field pApprox from p

Field uOld from u
Field vOld from v
Field pOld from p

Function TimeStep@finest {
	if ( dt == curTime ) {
		// first iteration
		FMG@coarsest ( )
	} else {
		FMG@finest ( )
	}
}

Function FMG@all {
	curFinest = levels@current ( )
	
	if ( nonLinearNewton and newtonSwitch > 0 ) {
		nonLinearNewton = false
		print ( 'nonLinearNewton:', 'false' )
	}

	UpdateRhs ( )
	AssembleStencil ( )
	UpdateResidual ( )

	Var initRes : Real    = NormResidual_L2 ()
	Var curRes  : Real    = initRes
	Var prevRes : Real    = curRes
	Var numIt   : Integer = 0

	Var minIt   : Integer = 0
	//if ( curTime > dt ) {
		// not the first iteration
		minIt = 1
	//}

	repeat until ( numIt >= minIt && ( curRes <= resThres || numIt >= 100 ) ) {
		// current level is already set up
		@(all but coarsest) {
			AssembleAllLevels@coarser ( true )
		}
		RelaxSystem@current ( )

		// perform single cycle
		VCycle ( )

		if ( !nonLinearNewton and numIt >= newtonSwitch ) {
			nonLinearNewton = true
			print ( 'nonLinearNewton:', 'true' )
		}

		// check for convergence
		prevRes = curRes
		UpdateRhs ( )
		AssembleStencil ( )
		UpdateResidual ( )
		curRes = NormResidual_L2@current()
		numIt += 1
		
		print ( 'convergence rate:', curRes / prevRes )
	}

	print ( levels@current ( ), 'took', numIt, 'iterations' )

	// go to finer level if applicable
	@(all but finest) {
		// propagation
		u@finer = CorrectionFaceX * u
		v@finer = CorrectionFaceY * v
		p@finer = CorrectionCell * p

		// solve on finer level
		FMG@finer ( )
	}
}


Function AssembleAllLevels@all ( useFinerSol : Boolean ) {
	@(all but finest) {
		if ( useFinerSol ) {
			u = RestrictionFaceX@finer * u@finer
			v = RestrictionFaceY@finer * v@finer
			p = RestrictionCell@finer  * p@finer
		}
	}

	AssembleStencil@current ( )

	@(all but coarsest) {
		AssembleAllLevels@coarser ( true )
	}
}


Function VCycle@(all but coarsest) ( ) : Unit {
	Smoother ( )

	UpdateResidual ( )
	Restriction@coarser ( )

	VCycle@coarser ( )

	Correction ( )

	Smoother ( )
}

Function VCycle@coarsest ( ) : Unit {
	// TODO: implement real cgs
	repeat 100 times {
		Smoother ( )
	}
}

Function UpdateResidual@all {
	residual_u = rhs_u - ( Laplace_xStag_xStag * u + A12 * v + B1 * p )
	residual_v = rhs_v - ( Laplace_yStag_yStag * v + A21 * u + B2 * p )
	residual_p = rhs_p - ( C1 * u + C2 * v )
}


Function Restriction@(all but finest) {
	// coarsen current guess
	uApprox = RestrictionFaceX@finer * u@finer
	u = uApprox

	vApprox = RestrictionFaceY@finer * v@finer
	v = vApprox

	pApprox = RestrictionCell@finer  * p@finer
	p = pApprox

	//AssembleStencil@current ( )

	// f = r + A v
	rhs_u = RestrictionFaceXIntegral@finer * residual_u@finer + Laplace_xStag_xStag * u + A12 * v + B1 * p
	rhs_v = RestrictionFaceYIntegral@finer * residual_v@finer + Laplace_yStag_yStag * v + A21 * u + B2 * p
	rhs_p = RestrictionCellIntegral@finer  * residual_p@finer + C1 * u + C2 * v

	//rhs_u += uOld * vf_xStagCellVolume / dt
	//rhs_v += vOld * vf_yStagCellVolume / dt
	//rhs_v += gravity * rho * vf_yStagCellVolume * vf_yStagCellVolume
}

Function dummy@all {
	u = u
	v = v
	p = p
}

Function Correction@(all but coarsest) {
	// e = u - v
	u@coarser -= uApprox@coarser
	v@coarser -= vApprox@coarser
	p@coarser -= pApprox@coarser

	u += CorrectionFaceX@coarser * u@coarser
	v += CorrectionFaceY@coarser * v@coarser
	p += CorrectionCell@coarser  * p@coarser
}

Function Advance@(all but coarsest) {
	uOld = u
	vOld = v
	pOld = p

	Advance@coarser ( )
}
Function Advance@coarsest {
	uOld = u
	vOld = v
	pOld = p
}

FunctionTemplate NormResidualComponent < residual > ( ) : Real {
	return sqrt ( residual * residual )
}

Instantiate NormResidualComponent < residual_u > as NormResidual_u@all
Instantiate NormResidualComponent < residual_v > as NormResidual_v@all
Instantiate NormResidualComponent < residual_p > as NormResidual_p@all
