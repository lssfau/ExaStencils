
//Field RHS             from L2
//Field Solution        from L2
//Operator Laplace      from L2

Field Residual      from Solution

Field VecP@coarsest     from Solution
Field VecGradP@coarsest from Solution

override bc for Residual@finest with 0.0


Operator RestrictionStencil from Stencil {
	[ 0,  0,  0] => 1.0 / 8.0
	[ 0,  0, -1] => 1.0 / 16.0
	[ 0,  0,  1] => 1.0 / 16.0
	[ 0, -1,  0] => 1.0 / 16.0
	[ 0,  1,  0] => 1.0 / 16.0
	[-1,  0,  0] => 1.0 / 16.0
	[ 1,  0,  0] => 1.0 / 16.0
	[ 0, -1,  1] => 1.0 / 32.0
	[ 0, -1, -1] => 1.0 / 32.0
	[ 0,  1,  1] => 1.0 / 32.0
	[ 0,  1, -1] => 1.0 / 32.0
	[-1,  0,  1] => 1.0 / 32.0
	[-1,  0, -1] => 1.0 / 32.0
	[ 1,  0,  1] => 1.0 / 32.0
	[ 1,  0, -1] => 1.0 / 32.0
	[-1, -1,  0] => 1.0 / 32.0
	[-1,  1,  0] => 1.0 / 32.0
	[ 1, -1,  0] => 1.0 / 32.0
	[ 1,  1,  0] => 1.0 / 32.0
	[-1, -1,  1] => 1.0 / 64.0
	[-1, -1, -1] => 1.0 / 64.0
	[-1,  1,  1] => 1.0 / 64.0
	[-1,  1, -1] => 1.0 / 64.0
	[ 1, -1,  1] => 1.0 / 64.0
	[ 1, -1, -1] => 1.0 / 64.0
	[ 1,  1,  1] => 1.0 / 64.0
	[ 1,  1, -1] => 1.0 / 64.0
}

Operator CorrectionStencil from Stencil {
	[    0,     0,     0] => 0.125
	[x % 2,     0,     0] => 0.125
	[    0, y % 2,     0] => 0.125
	[x % 2, y % 2,     0] => 0.125
	[    0,     0, z % 2] => 0.125
	[x % 2,     0, z % 2] => 0.125
	[    0, y % 2, z % 2] => 0.125
	[x % 2, y % 2, z % 2] => 0.125
}

/*
update Smoother ( x_l, b_l ) = D^-1 ( b - (L + U) x )
update MG ( x_l, b_l, l )
	if ( 0 == l ) CGS
	else
		x_l = Smoother ( x_l, b_l )
		r_l = b_l - A_l x_l
		x_(l-1) = 0
		MG ( x_(l-1), r_(l-1), l-1 )
		x_l += P x_(l-1)
*/

Function Smoother@((coarsest + 1) to finest) {
	repeat 3 times {
		Solution = Solution + ( ( ( 1.0 / diag ( Laplace ) ) * 0.8 ) * ( RHS - Laplace * Solution ) )
	}
}

Function VCycle@((coarsest + 1) to finest) {
	Smoother ( )

	Residual = RHS - ( Laplace * Solution )
	RHS@coarser = RestrictionStencil * Residual

	Solution@coarser = 0.0
	VCycle@coarser ( )

	Solution += CorrectionStencil * Solution@coarser

	Smoother ( )
}

Function VCycle@coarsest {
	Residual = RHS - ( Laplace * Solution )
	Var res : Real = NormResidual ( )
	Var initialRes : Real = res
	VecP = Residual
	Var cgSteps : Integer = 0

	repeat 512 times count cgSteps {
		VecGradP = Laplace * VecP
		Var alphaDenom : Real = VecP * VecGradP
		Var alpha : Real = res * res / alphaDenom
		Solution += alpha * VecP
		Residual -= alpha * VecGradP
		Var nextRes : Real = NormResidual ( )

		if ( nextRes <= 0.001 * initialRes ) {
			return
		}

		Var beta : Real = (nextRes * nextRes) / (res * res)
		VecP = Residual + beta * VecP
		res = nextRes
	}
	print ( 'Maximum number of cgs iterations (', 512, ') was exceeded' )
}

Function NormResidual@(coarsest and finest) : Real {
	return sqrt ( Residual * Residual )
}

Function Solve {
	Residual@finest = RHS@finest - ( Laplace@finest * Solution@finest )
	Var resStart_0 : Real = NormResidual@finest (  )
	Var res_0 : Real = resStart_0
	Var resOld_0 : Real = 0

	print ( 'Starting residual at 0', resStart_0 )

	repeat until res_0 < 1.0E-5 * resStart_0 {
		VCycle@finest (  )

		Residual@finest = RHS@finest - ( Laplace@finest * Solution@finest )
		resOld_0 = res_0
		res_0 = NormResidual@finest (  )
		print ( 'Residual at 0:', res_0, 'Residual reduction:', ( resStart_0 / res_0 ), 'Convergence factor:', ( res_0 / resOld_0 ) )
		Var curError_0 : Real = NormError@finest ( )
		print ( 'Error at 0:', curError_0 )
	}
}
