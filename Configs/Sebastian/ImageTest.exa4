Domain global< [ 0, 0 ] to [ 1, 1 ] >

Layout DefCellLayout < Real , Cell > @all {
	duplicateLayers	= [ 0, 0 ]
	ghostLayers		= [ 1, 1 ]
}

Field img < global, DefCellLayout, Neumann >@all

Field avg < global, DefCellLayout, None >@all
Field gradx < global, DefCellLayout, None >@all
Field grady < global, DefCellLayout, None >@all
Field gradxy < global, DefCellLayout, None >@all

Field imgOut < global, DefCellLayout, None >@all
Field diff < global, DefCellLayout, None >@finest

Stencil Average@all {
	[0, 0] =>  s0
	[1, 0] =>  s0
	[0, 1] =>  s0
	[1, 1] =>  s0
}

Stencil EdgeHorizontal@all {
	[0, 0] =>  s0
	[1, 0] => -s0
	[0, 1] =>  s0
	[1, 1] => -s0
}

Stencil EdgeVertical@all {
	[0, 0] =>  s0
	[1, 0] =>  s0
	[0, 1] => -s0
	[1, 1] => -s0
}

Stencil EdgeDiagonal@all {
	[0, 0] =>  s0
	[1, 0] => -s0
	[0, 1] => -s0
	[1, 1] =>  s0
}

Globals {
    Var s0 : Real = 0.5
}

Function Application ( ) : Unit {
	startTimer ( 'setup' )

	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )

	initGeometry ( )

	readImage ( img@finest, "lena512.jpg" )
	apply bc to img@finest

	stopTimer ( 'setup' )

	startTimer ( 'do' )

	CalcEdge@finest ( )
    ComputeImage@(coarsest + 1) ( )
	
	stopTimer ( 'do' )

	startTimer ( 'output' )

	showImage ( img@finest, avg@(finest - 1), gradx@(finest - 1), grady@(finest - 1), gradxy@(finest - 1), imgOut@finest, diff@finest )

	stopTimer ( 'output' )

	printAllTimers ( )
	destroyGlobals ( )
}

Function CalcEdge@(all but coarsest) ( ) : Unit {
	loop over avg@coarser {
		avg@coarser = Average@current * img@current
		img@coarser = avg@coarser
	}
	loop over gradx@coarser {
		gradx@coarser = EdgeHorizontal@current * img@current
	}
	loop over grady@coarser {
		grady@coarser = EdgeVertical@current * img@current
	}
	loop over gradxy@coarser {
		gradxy@coarser = EdgeDiagonal@current * img@current
	}
	
	if ( levels@coarser ( ) > levels@coarsest ( ) ) {
	    CalcEdge@coarser ( )
	}
}

Function ComputeImage@(all but coarsest) ( ) : Unit {
    loop over imgOut@current stepping [2, 2] {
        imgOut@current@[0, 0] = s0 * ( avg@coarser + gradx@coarser + grady@coarser + gradxy@coarser )
        imgOut@current@[1, 0] = s0 * ( avg@coarser - gradx@coarser + grady@coarser - gradxy@coarser )
        imgOut@current@[0, 1] = s0 * ( avg@coarser + gradx@coarser - grady@coarser - gradxy@coarser )
        imgOut@current@[1, 1] = s0 * ( avg@coarser - gradx@coarser - grady@coarser + gradxy@coarser )
    }
    
    if ( levels@finer ( ) <= levels@finest ( ) ) {
        ComputeImage@finer ( )
    } else {
		loop over diff@current {
			diff@current = fabs ( img@current - imgOut@current )
		}
	}
}
