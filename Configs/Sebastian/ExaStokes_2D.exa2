Domain global< [ 0, 0 ] to [ 1, 1 ] >


Field u with Real on Face_x of global = 0.0
Field u@finest on boundary = -4.0 * cos ( 4.0 * vf_boundaryCoord_y )
Field u@(all but finest) on boundary = 0.0

Field v with Real on Face_y of global = 0.0
Field v@finest on boundary = 2.0 * cos ( 2.0 * vf_boundaryCoord_x )
Field v@(all but finest) on boundary = 0.0

Field p with Real on Cell of global = 0.0
Field p on boundary = Neumann // TODO: currently not evaluated outside inner scope


Field residual_u with Real on Face_x of global = 0.0
Field residual_u on boundary = 0.0

Field residual_v with Real on Face_y of global = 0.0
Field residual_v on boundary = 0.0

Field residual_p with Real on Cell of global = 0.0
Field residual_p on boundary = Neumann


Field rhs_u@all with Real on Face_x of global = 0.0
Field rhs_v@all with Real on Face_y of global = 0.0
Field rhs_p@all with Real on Cell of global = 0.0


Equation uEquation@finest {
/*	0 == integrateOverXStaggeredEastFace ( 1.0 ) * p@[0, 0] - integrateOverXStaggeredWestFace ( 1.0 ) * p@[-1, 0]
		- integrateOverXStaggeredEastFace  ( 1.0 ) * ( u@[ 1,  0] - u@[0, 0] ) / vf_cellWidth_x@[1, 0]
		- integrateOverXStaggeredWestFace  ( 1.0 ) * ( u@[-1,  0] - u@[0, 0] ) / vf_cellWidth_x@[0, 0]
		- integrateOverXStaggeredNorthFace ( 1.0 ) * ( u@[ 0,  1] - u@[0, 0] ) / vf_stagCVWidth_y@[0, 1]
		- integrateOverXStaggeredSouthFace ( 1.0 ) * ( u@[ 0, -1] - u@[0, 0] ) / vf_stagCVWidth_y@[0, 0] )*/
	( integrateOverXStaggeredEastFace ( 1.0 ) * p@[0, 0] - integrateOverXStaggeredWestFace ( 1.0 ) * p@[-1, 0] +
		-1.0 * (
			  integrateOverXStaggeredEastFace  ( 1.0 ) * ( u@[ 1,  0] - u@[ 0,  0] ) / vf_cellWidth_x@[1, 0]
			- integrateOverXStaggeredWestFace  ( 1.0 ) * ( u@[ 0,  0] - u@[-1,  0] ) / vf_cellWidth_x@[0, 0]
			+ integrateOverXStaggeredNorthFace ( 1.0 ) * ( u@[ 0,  1] - u@[ 0,  0] ) / vf_stagCVWidth_y@[0, 1]
			- integrateOverXStaggeredSouthFace ( 1.0 ) * ( u@[ 0,  0] - u@[ 0, -1] ) / vf_stagCVWidth_y@[0, 0] )
	) == rhs_u
}
Equation uEquation@(all but finest) {
	( integrateOverXStaggeredEastFace ( 1.0 ) * p@[0, 0] - integrateOverXStaggeredWestFace ( 1.0 ) * p@[-1, 0] +
		-1.0 * (
			  integrateOverXStaggeredEastFace  ( 1.0 ) * ( u@[ 1,  0] - u@[ 0,  0] ) / vf_cellWidth_x@[1, 0]
			- integrateOverXStaggeredWestFace  ( 1.0 ) * ( u@[ 0,  0] - u@[-1,  0] ) / vf_cellWidth_x@[0, 0]
			+ integrateOverXStaggeredNorthFace ( 1.0 ) * ( u@[ 0,  1] - u@[ 0,  0] ) / vf_stagCVWidth_y@[0, 1]
			- integrateOverXStaggeredSouthFace ( 1.0 ) * ( u@[ 0,  0] - u@[ 0, -1] ) / vf_stagCVWidth_y@[0, 0] )
	) == 0.0
}

Equation vEquation@finest {
	-1.0 * (
			integrateOverYStaggeredEastFace  ( 1.0 ) * ( v@[ 1,  0] - v@[0, 0] ) / vf_stagCVWidth_x@[1, 0]
		+ integrateOverYStaggeredWestFace  ( 1.0 ) * ( v@[-1,  0] - v@[0, 0] ) / vf_stagCVWidth_x@[0, 0]
		+ integrateOverYStaggeredNorthFace ( 1.0 ) * ( v@[ 0,  1] - v@[0, 0] ) / vf_cellWidth_y@[0, 1]
		+ integrateOverYStaggeredSouthFace ( 1.0 ) * ( v@[ 0, -1] - v@[0, 0] ) / vf_cellWidth_y@[0, 0] )
	+ integrateOverYStaggeredNorthFace ( 1.0 ) * p@[0,0 ] - integrateOverYStaggeredSouthFace ( 1.0 ) * p@[0, -1] == rhs_v
}
Equation vEquation@(all but finest) {
	-1.0 * (
			integrateOverYStaggeredEastFace  ( 1.0 ) * ( v@[ 1,  0] - v@[0, 0] ) / vf_stagCVWidth_x@[1, 0]
		+ integrateOverYStaggeredWestFace  ( 1.0 ) * ( v@[-1,  0] - v@[0, 0] ) / vf_stagCVWidth_x@[0, 0]
		+ integrateOverYStaggeredNorthFace ( 1.0 ) * ( v@[ 0,  1] - v@[0, 0] ) / vf_cellWidth_y@[0, 1]
		+ integrateOverYStaggeredSouthFace ( 1.0 ) * ( v@[ 0, -1] - v@[0, 0] ) / vf_cellWidth_y@[0, 0] )
	+ integrateOverYStaggeredNorthFace ( 1.0 ) * p@[0,0 ] - integrateOverYStaggeredSouthFace ( 1.0 ) * p@[0, -1] == 0.0
}

Equation pEquation@finest {
	(
			integrateOverEastFace  ( 1.0 ) * u@[1, 0] - integrateOverWestFace  ( 1.0 ) * u@[0, 0]
		+ integrateOverNorthFace ( 1.0 ) * v@[0, 1] - integrateOverSouthFace ( 1.0 ) * v@[0, 0]
	) == rhs_p
}
Equation pEquation@(all but finest) {
	(
			integrateOverEastFace  ( 1.0 ) * u@[1, 0] - integrateOverWestFace  ( 1.0 ) * u@[0, 0]
		+ integrateOverNorthFace ( 1.0 ) * v@[0, 1] - integrateOverSouthFace ( 1.0 ) * v@[0, 0]
	) == 0.0
}


generate operators @all {
	equation for u is uEquation store in {
		u => A11
		p => B1
	}
	
	equation for v is vEquation store in {
		v => A22
		p => B2
	}
	
	equation for p is pEquation store in {
		u => C1
		v => C2
	}
}


// Stencil Operator_AppliedTo_WRT
/*
Operator Laplace_xStag_xStag from Stencil {
  [ 0,  0] => (
	  ( 1.0 / vf_cellWidth_x@[0, 0]   + 1.0 / vf_cellWidth_x@[1, 0] )   * vf_cellWidth_y
	+ ( 1.0 / vf_stagCVWidth_y@[0, 0] + 1.0 / vf_stagCVWidth_y@[0, 1] ) * vf_stagCVWidth_x )
  [-1,  0] => ( -1.0 / vf_cellWidth_x@[0, 0] )   * vf_cellWidth_y
  [ 1,  0] => ( -1.0 / vf_cellWidth_x@[1, 0] )   * vf_cellWidth_y
  [ 0, -1] => ( -1.0 / vf_stagCVWidth_y@[0, 0] ) * vf_stagCVWidth_x
  [ 0,  1] => ( -1.0 / vf_stagCVWidth_y@[0, 1] ) * vf_stagCVWidth_x
}

Operator Laplace_yStag_yStag from Stencil {
  [ 0,  0] => ( 1.0 / vf_stagCVWidth_x + 1.0 / vf_stagCVWidth_x@[1, 0] ) * vf_stagCVWidth_y + ( 1.0 / vf_cellWidth_y + 1.0 / vf_cellWidth_y@[0, 1] ) * vf_cellWidth_x
  [-1,  0] => ( -1.0 / vf_stagCVWidth_x@[0, 0] ) * vf_stagCVWidth_y
  [ 1,  0] => ( -1.0 / vf_stagCVWidth_x@[1, 0] ) * vf_stagCVWidth_y
  [ 0, -1] => ( -1.0 / vf_cellWidth_y@[0, 0] ) * vf_cellWidth_x
  [ 0,  1] => ( -1.0 / vf_cellWidth_y@[0, 1] ) * vf_cellWidth_x
}
*/
/*
Operator dx_Cell_xStag from Stencil {
  [-1,  0] => -vf_cellWidth_y
  [ 0,  0] =>  vf_cellWidth_y
}

Operator dy_Cell_yStag from Stencil {
  [ 0, -1] => -vf_cellWidth_x
  [ 0,  0] =>  vf_cellWidth_x
}
*/
/*
Operator dx_xStag_Cell from Stencil {
  [ 0,  0] => -vf_cellWidth_y
  [ 1,  0] =>  vf_cellWidth_y
}

Operator dy_yStag_Cell from Stencil {
  [ 0,  0] => -vf_cellWidth_x
  [ 0,  1] =>  vf_cellWidth_x
}
*/