// domain declarations

Domain global< [ 0.0, 0.0, 0.0 ] to [ 1.0, 1.0, 1.0 ] >

// field layout declarations

Layout defLayoutCell< Real, Cell >@(1) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutCell< Real, Cell >@(2) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutCell< Real, Cell >@(3) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutCell< Real, Cell >@(4) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutCell< Real, Cell >@(5) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_x< Real, Face_x >@(1) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_x< Real, Face_x >@(2) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_x< Real, Face_x >@(3) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_x< Real, Face_x >@(4) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_x< Real, Face_x >@(5) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_y< Real, Face_y >@(1) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_y< Real, Face_y >@(2) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_y< Real, Face_y >@(3) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_y< Real, Face_y >@(4) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_y< Real, Face_y >@(5) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_z< Real, Face_z >@(1) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_z< Real, Face_z >@(2) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_z< Real, Face_z >@(3) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_z< Real, Face_z >@(4) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutFace_z< Real, Face_z >@(5) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell< Array<Real><7>, Cell >@(1) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell< Array<Real><7>, Cell >@(2) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell< Array<Real><7>, Cell >@(3) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell< Array<Real><7>, Cell >@(4) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell< Array<Real><7>, Cell >@(5) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x< Array<Real><7>, Face_x >@(1) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x< Array<Real><7>, Face_x >@(2) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x< Array<Real><7>, Face_x >@(3) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x< Array<Real><7>, Face_x >@(4) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x< Array<Real><7>, Face_x >@(5) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y< Array<Real><7>, Face_y >@(1) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y< Array<Real><7>, Face_y >@(2) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y< Array<Real><7>, Face_y >@(3) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y< Array<Real><7>, Face_y >@(4) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y< Array<Real><7>, Face_y >@(5) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z< Array<Real><7>, Face_z >@(1) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z< Array<Real><7>, Face_z >@(2) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z< Array<Real><7>, Face_z >@(3) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z< Array<Real><7>, Face_z >@(4) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z< Array<Real><7>, Face_z >@(5) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayoutCell__1_1_1__1_1_1< Real, Cell >@(5) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_x__1_1_1__1_1_1< Real, Face_x >@(1) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_x__0_1_1__0_1_1< Real, Face_x >@(5) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 1, 1] with communication
}

Layout defLayoutFace_x__1_1_1__1_1_1< Real, Face_x >@(2) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_x__1_1_1__1_1_1< Real, Face_x >@(3) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_x__1_1_1__1_1_1< Real, Face_x >@(4) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_y__1_1_1__1_1_1< Real, Face_y >@(1) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_y__1_1_1__1_1_1< Real, Face_y >@(5) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_y__1_1_1__1_1_1< Real, Face_y >@(2) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_y__1_1_1__1_1_1< Real, Face_y >@(3) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_y__1_1_1__1_1_1< Real, Face_y >@(4) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_z__1_1_1__1_1_1< Real, Face_z >@(1) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_z__1_1_0__1_1_0< Real, Face_z >@(5) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 0] with communication
}

Layout defLayoutFace_z__1_1_1__1_1_1< Real, Face_z >@(2) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_z__1_1_1__1_1_1< Real, Face_z >@(3) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_z__1_1_1__1_1_1< Real, Face_z >@(4) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutCell__1_1_1__1_1_1< Real, Cell >@(1) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutCell__1_1_1__1_1_1< Real, Cell >@(2) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutCell__1_1_1__1_1_1< Real, Cell >@(3) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutCell__1_1_1__1_1_1< Real, Cell >@(4) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_x__0_1_1__0_1_1< Real, Face_x >@(1) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 1, 1] with communication
}

Layout defLayoutFace_x__1_1_1__1_1_1< Real, Face_x >@(5) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_y__1_0_1__1_0_1< Real, Face_y >@(1) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 0, 1] with communication
}

Layout defLayoutFace_z__1_1_0__1_1_0< Real, Face_z >@(1) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 0] with communication
}

Layout defLayoutFace_z__1_1_1__1_1_1< Real, Face_z >@(5) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 1] with communication
}

Layout defLayoutFace_x__0_1_1__0_1_1< Real, Face_x >@(2) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 1, 1] with communication
}

Layout defLayoutFace_x__0_1_1__0_1_1< Real, Face_x >@(3) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 1, 1] with communication
}

Layout defLayoutFace_x__0_1_1__0_1_1< Real, Face_x >@(4) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 1, 1] with communication
}

Layout defLayoutFace_y__1_0_1__1_0_1< Real, Face_y >@(2) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 0, 1] with communication
}

Layout defLayoutFace_y__1_0_1__1_0_1< Real, Face_y >@(3) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 0, 1] with communication
}

Layout defLayoutFace_y__1_0_1__1_0_1< Real, Face_y >@(4) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 0, 1] with communication
}

Layout defLayoutFace_y__1_0_1__1_0_1< Real, Face_y >@(5) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [1, 0, 1] with communication
}

Layout defLayoutFace_z__1_1_0__1_1_0< Real, Face_z >@(2) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 0] with communication
}

Layout defLayoutFace_z__1_1_0__1_1_0< Real, Face_z >@(3) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 0] with communication
}

Layout defLayoutFace_z__1_1_0__1_1_0< Real, Face_z >@(4) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [1, 1, 0] with communication
}

Layout defLayout7Face_x__0_0_0__0_0_0< Array<Real><7>, Face_x >@(1) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x__0_0_0__0_0_0< Array<Real><7>, Face_x >@(2) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x__0_0_0__0_0_0< Array<Real><7>, Face_x >@(3) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x__0_0_0__0_0_0< Array<Real><7>, Face_x >@(4) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_x__0_0_0__0_0_0< Array<Real><7>, Face_x >@(5) {
	duplicateLayers = [1, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y__0_0_0__0_0_0< Array<Real><7>, Face_y >@(1) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y__0_0_0__0_0_0< Array<Real><7>, Face_y >@(2) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y__0_0_0__0_0_0< Array<Real><7>, Face_y >@(3) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y__0_0_0__0_0_0< Array<Real><7>, Face_y >@(4) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_y__0_0_0__0_0_0< Array<Real><7>, Face_y >@(5) {
	duplicateLayers = [0, 1, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z__0_0_0__0_0_0< Array<Real><7>, Face_z >@(1) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z__0_0_0__0_0_0< Array<Real><7>, Face_z >@(2) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z__0_0_0__0_0_0< Array<Real><7>, Face_z >@(3) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z__0_0_0__0_0_0< Array<Real><7>, Face_z >@(4) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Face_z__0_0_0__0_0_0< Array<Real><7>, Face_z >@(5) {
	duplicateLayers = [0, 0, 1]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell__0_0_0__0_0_0< Array<Real><7>, Cell >@(1) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell__0_0_0__0_0_0< Array<Real><7>, Cell >@(2) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell__0_0_0__0_0_0< Array<Real><7>, Cell >@(3) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell__0_0_0__0_0_0< Array<Real><7>, Cell >@(4) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

Layout defLayout7Cell__0_0_0__0_0_0< Array<Real><7>, Cell >@(5) {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [0, 0, 0]
}

// field declarations

Field rho< global, defLayoutCell__1_1_1__1_1_1, Neumann >[2]@5

Field u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@1

Field u< global, defLayoutFace_x__0_1_1__0_1_1, 0.0 >[2]@5

Field u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@2

Field u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@3

Field u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@4

Field v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@1

Field v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >[2]@5

Field v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@2

Field v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@3

Field v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@4

Field w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@1

Field w< global, defLayoutFace_z__1_1_0__1_1_0, 0.0 >[2]@5

Field w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@2

Field w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@3

Field w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@4

Field pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@1

Field pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@5

Field pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@2

Field pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@3

Field pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@4

Field phi7< global, defLayoutCell__1_1_1__1_1_1, applyBC_t@current (  ) >@1

Field phi7< global, defLayoutCell__1_1_1__1_1_1, applyBC_t@current (  ) >[2]@5

Field phi7< global, defLayoutCell__1_1_1__1_1_1, applyBC_t@current (  ) >@2

Field phi7< global, defLayoutCell__1_1_1__1_1_1, applyBC_t@current (  ) >@3

Field phi7< global, defLayoutCell__1_1_1__1_1_1, applyBC_t@current (  ) >@4

Field p< global, defLayoutCell__1_1_1__1_1_1, Neumann >@5

Field residual_u< global, defLayoutFace_x__0_1_1__0_1_1, 0.0 >@1

Field residual_u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@2

Field residual_u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@3

Field residual_u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@4

Field residual_u< global, defLayoutFace_x__1_1_1__1_1_1, 0.0 >@5

Field residual_v< global, defLayoutFace_y__1_0_1__1_0_1, 0.0 >@1

Field residual_v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@2

Field residual_v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@3

Field residual_v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@4

Field residual_v< global, defLayoutFace_y__1_1_1__1_1_1, 0.0 >@5

Field residual_w< global, defLayoutFace_z__1_1_0__1_1_0, 0.0 >@1

Field residual_w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@2

Field residual_w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@3

Field residual_w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@4

Field residual_w< global, defLayoutFace_z__1_1_1__1_1_1, 0.0 >@5

Field residual_pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@1

Field residual_pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@2

Field residual_pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@3

Field residual_pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@4

Field residual_pc< global, defLayoutCell__1_1_1__1_1_1, Neumann >@5

Field residual_t< global, defLayoutCell__1_1_1__1_1_1, applyBC_res_t@current (  ) >@1

Field residual_t< global, defLayoutCell__1_1_1__1_1_1, applyBC_res_t@current (  ) >@2

Field residual_t< global, defLayoutCell__1_1_1__1_1_1, applyBC_res_t@current (  ) >@3

Field residual_t< global, defLayoutCell__1_1_1__1_1_1, applyBC_res_t@current (  ) >@4

Field residual_t< global, defLayoutCell__1_1_1__1_1_1, applyBC_res_t@current (  ) >@5

Field rhs_u< global, defLayoutFace_x__0_1_1__0_1_1, None >@1

Field rhs_u< global, defLayoutFace_x__0_1_1__0_1_1, None >@2

Field rhs_u< global, defLayoutFace_x__0_1_1__0_1_1, None >@3

Field rhs_u< global, defLayoutFace_x__0_1_1__0_1_1, None >@4

Field rhs_u< global, defLayoutFace_x__0_1_1__0_1_1, None >@5

Field rhs_v< global, defLayoutFace_y__1_0_1__1_0_1, None >@1

Field rhs_v< global, defLayoutFace_y__1_0_1__1_0_1, None >@2

Field rhs_v< global, defLayoutFace_y__1_0_1__1_0_1, None >@3

Field rhs_v< global, defLayoutFace_y__1_0_1__1_0_1, None >@4

Field rhs_v< global, defLayoutFace_y__1_0_1__1_0_1, None >@5

Field rhs_w< global, defLayoutFace_z__1_1_0__1_1_0, None >@1

Field rhs_w< global, defLayoutFace_z__1_1_0__1_1_0, None >@2

Field rhs_w< global, defLayoutFace_z__1_1_0__1_1_0, None >@3

Field rhs_w< global, defLayoutFace_z__1_1_0__1_1_0, None >@4

Field rhs_w< global, defLayoutFace_z__1_1_0__1_1_0, None >@5

Field rhs_pc< global, defLayoutCell__1_1_1__1_1_1, None >@1

Field rhs_pc< global, defLayoutCell__1_1_1__1_1_1, None >@2

Field rhs_pc< global, defLayoutCell__1_1_1__1_1_1, None >@3

Field rhs_pc< global, defLayoutCell__1_1_1__1_1_1, None >@4

Field rhs_pc< global, defLayoutCell__1_1_1__1_1_1, None >@5

Field rhs_t< global, defLayoutCell__1_1_1__1_1_1, None >@1

Field rhs_t< global, defLayoutCell__1_1_1__1_1_1, None >@2

Field rhs_t< global, defLayoutCell__1_1_1__1_1_1, None >@3

Field rhs_t< global, defLayoutCell__1_1_1__1_1_1, None >@4

Field rhs_t< global, defLayoutCell__1_1_1__1_1_1, None >@5

Field du< global, defLayoutFace_x__0_1_1__0_1_1, None >@5

Field dv< global, defLayoutFace_y__1_0_1__1_0_1, None >@5

Field dw< global, defLayoutFace_z__1_1_0__1_1_0, None >@5

Field AuStencilData< global, defLayout7Face_x__0_0_0__0_0_0, None >@1

Field AuStencilData< global, defLayout7Face_x__0_0_0__0_0_0, None >@2

Field AuStencilData< global, defLayout7Face_x__0_0_0__0_0_0, None >@3

Field AuStencilData< global, defLayout7Face_x__0_0_0__0_0_0, None >@4

Field AuStencilData< global, defLayout7Face_x__0_0_0__0_0_0, None >@5

Field AvStencilData< global, defLayout7Face_y__0_0_0__0_0_0, None >@1

Field AvStencilData< global, defLayout7Face_y__0_0_0__0_0_0, None >@2

Field AvStencilData< global, defLayout7Face_y__0_0_0__0_0_0, None >@3

Field AvStencilData< global, defLayout7Face_y__0_0_0__0_0_0, None >@4

Field AvStencilData< global, defLayout7Face_y__0_0_0__0_0_0, None >@5

Field AwStencilData< global, defLayout7Face_z__0_0_0__0_0_0, None >@1

Field AwStencilData< global, defLayout7Face_z__0_0_0__0_0_0, None >@2

Field AwStencilData< global, defLayout7Face_z__0_0_0__0_0_0, None >@3

Field AwStencilData< global, defLayout7Face_z__0_0_0__0_0_0, None >@4

Field AwStencilData< global, defLayout7Face_z__0_0_0__0_0_0, None >@5

Field ApcStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@1

Field ApcStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@2

Field ApcStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@3

Field ApcStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@4

Field ApcStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@5

Field AtStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@1

Field AtStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@2

Field AtStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@3

Field AtStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@4

Field AtStencilData< global, defLayout7Cell__0_0_0__0_0_0, None >@5

// external field declarations

// stencil declarations

Stencil RestrictionCell@(1) {
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.5*1.0)))
}

Stencil RestrictionCell@(2) {
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.5*1.0)))
}

Stencil RestrictionCell@(3) {
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.5*1.0)))
}

Stencil RestrictionCell@(4) {
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.5*1.0)))
}

Stencil RestrictionCell@(5) {
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.5*1.0)))
}

Stencil RestrictionFaceX@(1) {
	[-1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
}

Stencil RestrictionFaceX@(2) {
	[-1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
}

Stencil RestrictionFaceX@(3) {
	[-1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
}

Stencil RestrictionFaceX@(4) {
	[-1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
}

Stencil RestrictionFaceX@(5) {
	[-1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[-1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.25*1.0)))
	[1, 1, 1] => (0.5*(0.5*(0.25*1.0)))
}

Stencil RestrictionFaceY@(1) {
	[0, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.25*(0.5*1.0)))
}

Stencil RestrictionFaceY@(2) {
	[0, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.25*(0.5*1.0)))
}

Stencil RestrictionFaceY@(3) {
	[0, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.25*(0.5*1.0)))
}

Stencil RestrictionFaceY@(4) {
	[0, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.25*(0.5*1.0)))
}

Stencil RestrictionFaceY@(5) {
	[0, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[0, 1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, -1, 1] => (0.5*(0.25*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.25*(0.5*1.0)))
	[1, 1, 1] => (0.5*(0.25*(0.5*1.0)))
}

Stencil RestrictionFaceZ@(1) {
	[0, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.25*(0.5*(0.5*1.0)))
}

Stencil RestrictionFaceZ@(2) {
	[0, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.25*(0.5*(0.5*1.0)))
}

Stencil RestrictionFaceZ@(3) {
	[0, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.25*(0.5*(0.5*1.0)))
}

Stencil RestrictionFaceZ@(4) {
	[0, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.25*(0.5*(0.5*1.0)))
}

Stencil RestrictionFaceZ@(5) {
	[0, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[0, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[0, 1, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 0, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 0, 1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, -1] => (0.25*(0.5*(0.5*1.0)))
	[1, 1, 0] => (0.5*(0.5*(0.5*1.0)))
	[1, 1, 1] => (0.25*(0.5*(0.5*1.0)))
}

Stencil CorrectionCell@(1) {
	[0, 0, 0] => 1.0
}

Stencil CorrectionCell@(2) {
	[0, 0, 0] => 1.0
}

Stencil CorrectionCell@(3) {
	[0, 0, 0] => 1.0
}

Stencil CorrectionCell@(4) {
	[0, 0, 0] => 1.0
}

Stencil CorrectionCell@(5) {
	[0, 0, 0] => 1.0
}

Stencil CorrectionFaceX@(1) {
	[0, 0, 0] => (0.5*1.0)
	[(x%2), 0, 0] => (0.5*1.0)
}

Stencil CorrectionFaceX@(2) {
	[0, 0, 0] => (0.5*1.0)
	[(x%2), 0, 0] => (0.5*1.0)
}

Stencil CorrectionFaceX@(3) {
	[0, 0, 0] => (0.5*1.0)
	[(x%2), 0, 0] => (0.5*1.0)
}

Stencil CorrectionFaceX@(4) {
	[0, 0, 0] => (0.5*1.0)
	[(x%2), 0, 0] => (0.5*1.0)
}

Stencil CorrectionFaceX@(5) {
	[0, 0, 0] => (0.5*1.0)
	[(x%2), 0, 0] => (0.5*1.0)
}

Stencil CorrectionFaceY@(1) {
	[0, 0, 0] => (0.5*1.0)
	[0, (y%2), 0] => (0.5*1.0)
}

Stencil CorrectionFaceY@(2) {
	[0, 0, 0] => (0.5*1.0)
	[0, (y%2), 0] => (0.5*1.0)
}

Stencil CorrectionFaceY@(3) {
	[0, 0, 0] => (0.5*1.0)
	[0, (y%2), 0] => (0.5*1.0)
}

Stencil CorrectionFaceY@(4) {
	[0, 0, 0] => (0.5*1.0)
	[0, (y%2), 0] => (0.5*1.0)
}

Stencil CorrectionFaceY@(5) {
	[0, 0, 0] => (0.5*1.0)
	[0, (y%2), 0] => (0.5*1.0)
}

Stencil CorrectionFaceZ@(1) {
	[0, 0, 0] => (0.5*1.0)
	[0, 0, (z%2)] => (0.5*1.0)
}

Stencil CorrectionFaceZ@(2) {
	[0, 0, 0] => (0.5*1.0)
	[0, 0, (z%2)] => (0.5*1.0)
}

Stencil CorrectionFaceZ@(3) {
	[0, 0, 0] => (0.5*1.0)
	[0, 0, (z%2)] => (0.5*1.0)
}

Stencil CorrectionFaceZ@(4) {
	[0, 0, 0] => (0.5*1.0)
	[0, 0, (z%2)] => (0.5*1.0)
}

Stencil CorrectionFaceZ@(5) {
	[0, 0, 0] => (0.5*1.0)
	[0, 0, (z%2)] => (0.5*1.0)
}

// stencil field declarations

StencilField AuStencil< AuStencilData => AuStencilTemplate >@1

StencilField AuStencil< AuStencilData => AuStencilTemplate >@2

StencilField AuStencil< AuStencilData => AuStencilTemplate >@3

StencilField AuStencil< AuStencilData => AuStencilTemplate >@4

StencilField AuStencil< AuStencilData => AuStencilTemplate >@5

StencilField AvStencil< AvStencilData => AvStencilTemplate >@1

StencilField AvStencil< AvStencilData => AvStencilTemplate >@2

StencilField AvStencil< AvStencilData => AvStencilTemplate >@3

StencilField AvStencil< AvStencilData => AvStencilTemplate >@4

StencilField AvStencil< AvStencilData => AvStencilTemplate >@5

StencilField AwStencil< AwStencilData => AwStencilTemplate >@1

StencilField AwStencil< AwStencilData => AwStencilTemplate >@2

StencilField AwStencil< AwStencilData => AwStencilTemplate >@3

StencilField AwStencil< AwStencilData => AwStencilTemplate >@4

StencilField AwStencil< AwStencilData => AwStencilTemplate >@5

StencilField ApcStencil< ApcStencilData => ApcStencilTemplate >@1

StencilField ApcStencil< ApcStencilData => ApcStencilTemplate >@2

StencilField ApcStencil< ApcStencilData => ApcStencilTemplate >@3

StencilField ApcStencil< ApcStencilData => ApcStencilTemplate >@4

StencilField ApcStencil< ApcStencilData => ApcStencilTemplate >@5

StencilField AtStencil< AtStencilData => AtStencilTemplate >@1

StencilField AtStencil< AtStencilData => AtStencilTemplate >@2

StencilField AtStencil< AtStencilData => AtStencilTemplate >@3

StencilField AtStencil< AtStencilData => AtStencilTemplate >@4

StencilField AtStencil< AtStencilData => AtStencilTemplate >@5

Layout DefCellLayout< Real, cell >@all {
	duplicateLayers = [0, 0, 0]
	ghostLayers = [1, 1, 1] with communication
}

Field vis< global, DefCellLayout, Neumann(1) >@finest

Field miu< global, DefCellLayout, Neumann(1) >@finest

Field gamma< global, DefCellLayout, Neumann(1) >@finest

Globals {
	Value printInterval : Real = 100
	Value dt : Real = 0.5
	Value maxTime : Real = 10.0
	Value maxSimpleIterations : Integer = 1000000
	Value rhoref : Real = 0.0
	Value rhocon : Real = 999.7
	Value visl : Real = 1.0E-5
	Value th : Real = 283.15
	Value tc : Real = 273.15
	Value t_ph : Real = 273.15
	Value temp_ref : Real = 270.592
	Value delta_temp : Real = 0.2
	Value t_sol : Real = (t_ph+delta_temp)
	Value t_liq : Real = (t_ph-delta_temp)
	Value hls : Real = 335000.0
	Value miu_liq : Real = 0.001197941294207
	Value cp_liq : Real = 4202.1178518932
	Value rho_liq : Real = 1000.12926014462
	Value cond_liq : Real = 0.7207161
	Value rho_sol : Real = 1000.10152281425
	Value cp_sol : Real = 4202.85969356982
	Value cond_sol : Real = 0.7204897
	Value a_den : Real = 999.840281
	Value b_den : Real = 0.0673268
	Value c_den : Real = -0.00894484
	Value d_den : Real = 8.7846287E-5
	Value e_den : Real = -6.6213979E-7
	Value useNonNewtonian : Boolean = false
	Value n_index : Real = 0.6
	Variable curTime : Real = 0.0
	Variable totalInitRes : Real = 0.0
	Variable lastTotalInitRes : Real = 0.0
	Variable converged_u : Boolean = false
	Variable converged_v : Boolean = false
	Variable converged_w : Boolean = false
	Variable converged_pc : Boolean = false
	Variable converged_t : Boolean = false
	Variable nextPrintTime : Real = (maxTime+dt)
	Variable relax_1 : Real = 0.5
	Variable relax_2 : Real = 0.5
	Variable relax_3 : Real = 0.5
	Variable relax_4 : Real = 0.5
	Variable relax_7 : Real = 0.5
	Variable targetResPerComp : Real = 1.0E-6
	Variable stagnationThreshold : Real = 0.01
}


Function applyBC_t@finest ( ) : Unit {
	loop over phi7@current only ghost [-1, 0, 0] on boundary{
		phi7[activeSlot]@current = ((2.0*th)-phi7[activeSlot]@current@[1, 0, 0])
	}
	loop over phi7@current only ghost [1, 0, 0] on boundary{
		phi7[activeSlot]@current = ((2.0*tc)-phi7[activeSlot]@current@[-1, 0, 0])
	}
	loop over phi7@current only ghost [0, -1, 0] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, 1, 0]
	}
	loop over phi7@current only ghost [0, 1, 0] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, -1, 0]
	}
	loop over phi7@current only ghost [0, 0, -1] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, 0, 1]
	}
	loop over phi7@current only ghost [0, 0, 1] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, 0, -1]
	}
}

Function applyBC_t@(coarsest to (finest - 1)) ( ) : Unit {
	loop over phi7@current only ghost [-1, 0, 0] on boundary{
		phi7[activeSlot]@current = (0.0-phi7[activeSlot]@current@[1, 0, 0])
	}
	loop over phi7@current only ghost [1, 0, 0] on boundary{
		phi7[activeSlot]@current = (0.0-phi7[activeSlot]@current@[-1, 0, 0])
	}
	loop over phi7@current only ghost [0, -1, 0] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, 1, 0]
	}
	loop over phi7@current only ghost [0, 1, 0] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, -1, 0]
	}
	loop over phi7@current only ghost [0, 0, -1] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, 0, 1]
	}
	loop over phi7@current only ghost [0, 0, 1] on boundary{
		phi7[activeSlot]@current = phi7[activeSlot]@current@[0, 0, -1]
	}
}

Function applyBC_res_t@all ( ) : Unit {
	loop over residual_t@current only ghost [-1, 0, 0] on boundary{
		residual_t@current = (0.0-residual_t@current@[1, 0, 0])
	}
	loop over residual_t@current only ghost [1, 0, 0] on boundary{
		residual_t@current = (0.0-residual_t@current@[-1, 0, 0])
	}
	loop over residual_t@current only ghost [0, -1, 0] on boundary{
		residual_t@current = residual_t@current@[0, 1, 0]
	}
	loop over residual_t@current only ghost [0, 1, 0] on boundary{
		residual_t@current = residual_t@current@[0, -1, 0]
	}
	loop over residual_t@current only ghost [0, 0, -1] on boundary{
		residual_t@current = residual_t@current@[0, 0, 1]
	}
	loop over residual_t@current only ghost [0, 0, 1] on boundary{
		residual_t@current = residual_t@current@[0, 0, -1]
	}
}

Function Application ( ) : Unit {
	startTimer ( "setup" )
	initGlobals (  )
	initDomain (  )
	initFieldsWithZero (  )
	initGeometry (  )
	InitFields@finest (  )
	stopTimer ( "setup" )
	TimeLoop (  )
	printAllTimers (  )
	destroyGlobals (  )
}

Function TimeLoop ( ) : Unit {
	repeat until (curTime>=maxTime){
		startTimer ( "timeStep" )
		if ((0.0==curTime)) {
			if (useNonNewtonian) {
				UpdatePropertiesNN@finest (  )
			} else {
				UpdateProperties@finest (  )
			}
		}
		AdvanceFields@finest (  )
		Solve@finest (  )
		curTime += dt
		stopTimer ( "timeStep" )
	}
}

Function Solve@finest ( ) : Unit {
	Variable converged : Boolean = false
	Variable curIt : Integer = 0
	converged_u = false
	converged_v = false
	converged_w = false
	converged_pc = false
	converged_t = false
	repeat until (converged||(curIt>=maxSimpleIterations)){
		startTimer ( "solve" )
		lastTotalInitRes = totalInitRes
		totalInitRes = 0.0
		startTimer ( "UpdateProperties" )
		if (useNonNewtonian) {
			UpdatePropertiesNN@current (  )
		} else {
			UpdateProperties@current (  )
		}
		stopTimer ( "UpdateProperties" )
		startTimer ( "UpdateVelocities" )
		startTimer ( "CompileStencil_u" )
		CompileStencil_u@current (  )
		stopTimer ( "CompileStencil_u" )
		startTimer ( "Solve_u" )
		Solve_u@current (  )
		stopTimer ( "Solve_u" )
		startTimer ( "CompileStencil_v" )
		CompileStencil_v@current (  )
		stopTimer ( "CompileStencil_v" )
		startTimer ( "Solve_v" )
		Solve_v@current (  )
		stopTimer ( "Solve_v" )
		startTimer ( "CompileStencil_w" )
		CompileStencil_w@current (  )
		stopTimer ( "CompileStencil_w" )
		startTimer ( "Solve_w" )
		Solve_w@current (  )
		stopTimer ( "Solve_w" )
		stopTimer ( "UpdateVelocities" )
		startTimer ( "PressureCorrection" )
		loop over pc@current starting [-1, -1, -1] ending [-1, -1, -1] {
			pc[activeSlot]@current = 0.0
		}
		startTimer ( "CompileStencil_pc" )
		CompileStencil_pc@current (  )
		stopTimer ( "CompileStencil_pc" )
		startTimer ( "Solve_pc" )
		Solve_pc@current (  )
		stopTimer ( "Solve_pc" )
		loop over p@current {
			p@current += (relax_4*pc@current)
		}
		communicate p@current
		apply bc to p@current
		loop over u@current {
			u[activeSlot]@current += (du@current*(pc@current@[-1, 0, 0]-pc@current))
		}
		communicate u[activeSlot]@current
		apply bc to u[activeSlot]@current
		loop over v@current {
			v[activeSlot]@current += (dv@current*(pc@current@[0, -1, 0]-pc@current))
		}
		communicate v[activeSlot]@current
		apply bc to v[activeSlot]@current
		loop over w@current {
			w[activeSlot]@current += (dw@current*(pc@current@[0, 0, -1]-pc@current))
		}
		communicate w[activeSlot]@current
		apply bc to w[activeSlot]@current
		stopTimer ( "PressureCorrection" )
		startTimer ( "UpdateTemperature" )
		startTimer ( "CompileStencil_t" )
		CompileStencil_t@current (  )
		stopTimer ( "CompileStencil_t" )
		startTimer ( "Solve_t" )
		Solve_t@current (  )
		stopTimer ( "Solve_t" )
		stopTimer ( "UpdateTemperature" )
		startTimer ( "convergenceCheck" )
		if (((((converged_u&&converged_v)&&converged_w)&&converged_pc)&&converged_t)) {
			converged = true
		}
		if (((!(converged)&&(0==(curIt%100)))&&(curIt>0))) {
			Value res_u : Real = NormResidual_u@current (  )
			Value res_v : Real = NormResidual_v@current (  )
			Value res_w : Real = NormResidual_w@current (  )
			Value res_pc : Real = NormResidual_pc@current (  )
			Value res_t : Real = NormResidual_t@current (  )
			print ( curTime, curIt )
			printVal ( res_u )
			printVal ( res_v )
			printVal ( res_w )
			printVal ( res_pc )
			printVal ( res_t )
		}
		stopTimer ( "convergenceCheck" )
		stopTimer ( "solve" )
		curIt += 1
	}
	if ((curTime>=nextPrintTime)) {
		nextPrintTime += printInterval
		Variable index : Integer = (curTime/printInterval)
		Variable filename_rho : String
		buildString ( filename_rho, "rho_", index, ".csv" )
		Variable filename_u : String
		buildString ( filename_u, "u_", index, ".csv" )
		Variable filename_v : String
		buildString ( filename_v, "v_", index, ".csv" )
		Variable filename_w : String
		buildString ( filename_w, "w_", index, ".csv" )
		Variable filename_temp : String
		buildString ( filename_temp, "temp_", index, ".csv" )
		printField ( filename_rho, rho[activeSlot]@current, (2**(levels@current (  )-1)==z) )
		printField ( filename_u, u[activeSlot]@current, (2**(levels@current (  )-1)==z) )
		printField ( filename_v, v[activeSlot]@current, (2**(levels@current (  )-1)==z) )
		printField ( filename_w, w[activeSlot]@current, (2**(levels@current (  )-1)==z) )
		printField ( filename_temp, phi7[activeSlot]@current, (2**(levels@current (  )-1)==z) )
	}
	Value res_u : Real = NormResidual_u@current (  )
	Value res_v : Real = NormResidual_v@current (  )
	Value res_w : Real = NormResidual_w@current (  )
	Value res_pc : Real = NormResidual_pc@current (  )
	Value res_t : Real = NormResidual_t@current (  )
	print ( curTime, curIt )
	printVal ( res_u )
	printVal ( res_v )
	printVal ( res_w )
	printVal ( res_pc )
	printVal ( res_t )
}

Function printVal (toPrint : Real ) : Unit {
	print ( toPrint )
}

Function InitFields@finest ( ) : Unit {
	loop over rho@current {
		rho[activeSlot]@current = rhocon
		rho[previousSlot]@current = rhocon
	}
	communicate rho[activeSlot]@current
	apply bc to rho[activeSlot]@current
	communicate rho[previousSlot]@current
	apply bc to rho[previousSlot]@current
	loop over vis@current {
		vis@current = visl
	}
	communicate vis@current
	apply bc to vis@current
	loop over phi7@current {
		phi7[activeSlot]@current = th
		phi7[previousSlot]@current = th
	}
	communicate phi7[activeSlot]@current
	apply bc to phi7[activeSlot]@current
	communicate phi7[previousSlot]@current
	apply bc to phi7[previousSlot]@current
}

Function calc_diflow (flow : Real, diff : Real ) : Real {
	Variable tmp : Real = ((diff-(0.1*fabs ( flow )))/diff)
	return max ( 0.0, (diff*tmp**5) )
}

Function UpdateProperties@finest ( ) : Unit {
	loop over vis@current {
		rho[activeSlot]@current = ((((a_den+(b_den*(phi7[activeSlot]@current-t_ph)))+(c_den*(phi7[activeSlot]@current-t_ph)**2))+(d_den*(phi7[activeSlot]@current-t_ph)**3))+(e_den*(phi7[activeSlot]@current-t_ph)**4))
		Value cp : Real = (((-3755.9+(67.953*phi7[activeSlot]@current))-(0.19149*phi7[activeSlot]@current**2))+(1.785E-4*phi7[activeSlot]@current**3))
		Value cond : Real = (((-0.63262+(0.0071959*phi7[activeSlot]@current))-(1.144E-5*phi7[activeSlot]@current**2))+(4.2365E-9*phi7[activeSlot]@current**3))
		vis@current = (0.038208/(phi7[activeSlot]@current-252.33))
		gamma@current = (cond/cp)
	}
	communicate vis@current
	apply bc to vis@current
	communicate rho[activeSlot]@current
	apply bc to rho[activeSlot]@current
	communicate gamma@current
	apply bc to gamma@current
}

Function UpdatePropertiesNN@finest ( ) : Unit {
	loop over miu@current {
		rho[activeSlot]@current = ((((a_den+(b_den*(phi7[activeSlot]@current-t_ph)))+(c_den*(phi7[activeSlot]@current-t_ph)**2))+(d_den*(phi7[activeSlot]@current-t_ph)**3))+(e_den*(phi7[activeSlot]@current-t_ph)**4))
		Value cp : Real = (((-3755.9+(67.953*phi7[activeSlot]@current))-(0.19149*phi7[activeSlot]@current**2))+(1.785E-4*phi7[activeSlot]@current**3))
		Value cond : Real = (((-0.63262+(0.0071959*phi7[activeSlot]@current))-(1.144E-5*phi7[activeSlot]@current**2))+(4.2365E-9*phi7[activeSlot]@current**3))
		miu@current = (0.038208/(phi7[activeSlot]@current-252.33))
		gamma@current = (cond/cp)
	}
	communicate miu@current
	apply bc to miu@current
	communicate rho[activeSlot]@current
	apply bc to rho[activeSlot]@current
	communicate gamma@current
	apply bc to gamma@current
	loop over vis@current {
		Value dudx : Real = ((evalAtEastFace ( u[activeSlot]@current )-evalAtWestFace ( u[activeSlot]@current ))/vf_cellWidth_x@current)
		Value dvdx : Real = ((0.5*(((evalAtEastFace ( v[activeSlot]@current )-evalAtWestFace ( v[activeSlot]@current ))+evalAtEastFace ( v[activeSlot]@current@[0, 1, 0] ))-evalAtWestFace ( v[activeSlot]@current@[0, 1, 0] )))/vf_cellWidth_x@current)
		Value dwdx : Real = ((0.5*(((evalAtEastFace ( w[activeSlot]@current )-evalAtWestFace ( w[activeSlot]@current ))+evalAtEastFace ( w[activeSlot]@current@[0, 0, 1] ))-evalAtWestFace ( w[activeSlot]@current@[0, 0, 1] )))/vf_cellWidth_x@current)
		Value dudy : Real = ((0.5*(((evalAtNorthFace ( u[activeSlot]@current )-evalAtSouthFace ( u[activeSlot]@current ))+evalAtNorthFace ( u[activeSlot]@current@[1, 0, 0] ))-evalAtSouthFace ( u[activeSlot]@current@[1, 0, 0] )))/vf_cellWidth_y@current)
		Value dvdy : Real = ((evalAtNorthFace ( v[activeSlot]@current )-evalAtSouthFace ( v[activeSlot]@current ))/vf_cellWidth_y@current)
		Value dwdy : Real = ((0.5*(((evalAtNorthFace ( w[activeSlot]@current )-evalAtSouthFace ( w[activeSlot]@current ))+evalAtNorthFace ( w[activeSlot]@current@[0, 0, 1] ))-evalAtSouthFace ( w[activeSlot]@current@[0, 0, 1] )))/vf_cellWidth_y@current)
		Value dudz : Real = ((0.5*(((evalAtTopFace ( u[activeSlot]@current )-evalAtBottomFace ( u[activeSlot]@current ))+evalAtTopFace ( u[activeSlot]@current@[1, 0, 0] ))-evalAtBottomFace ( u[activeSlot]@current@[1, 0, 0] )))/vf_cellWidth_z@current)
		Value dvdz : Real = ((0.5*(((evalAtTopFace ( v[activeSlot]@current )-evalAtBottomFace ( v[activeSlot]@current ))+evalAtTopFace ( v[activeSlot]@current@[0, 1, 0] ))-evalAtBottomFace ( v[activeSlot]@current@[0, 1, 0] )))/vf_cellWidth_z@current)
		Value dwdz : Real = ((evalAtTopFace ( w[activeSlot]@current )-evalAtBottomFace ( w[activeSlot]@current ))/vf_cellWidth_z@current)
		Value gamap : Real = ((((2.0*((dvdy**2+dudx**2)+dwdz**2))+(dvdx+dudy)**2)+(dwdx+dudz)**2)+(dvdz+dwdy)**2)
		Variable gama : Real = sqrt ( gamap )
		gama = max ( gama, 0.01 )
		vis@current = (miu@current*gama**(n_index-1.0))
	}
	communicate vis@current
	apply bc to vis@current
}

Function CompileStencil_u@finest ( ) : Unit {
	loop over AuStencil@current {
		Value flow_e@current : Real = integrateOverXStaggeredEastFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_w@current : Real = integrateOverXStaggeredWestFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_n@current : Real = integrateOverXStaggeredNorthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_s@current : Real = integrateOverXStaggeredSouthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_t@current : Real = integrateOverXStaggeredTopFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_b@current : Real = integrateOverXStaggeredBottomFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value diff_e : Real = (integrateOverXStaggeredEastFace ( vis@current )/vf_cellWidth_x@current)
		Value diff_w : Real = (integrateOverXStaggeredWestFace ( vis@current )/vf_cellWidth_x@current@[-1, 0, 0])
		Value diff_n : Real = (integrateOverXStaggeredNorthFace ( evalAtXStaggeredNorthFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_y@current@[0, 1, 0])
		Value diff_s : Real = (integrateOverXStaggeredSouthFace ( evalAtXStaggeredSouthFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_y@current)
		Value diff_t : Real = (integrateOverXStaggeredTopFace ( evalAtXStaggeredTopFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_z@current@[0, 0, 1])
		Value diff_b : Real = (integrateOverXStaggeredBottomFace ( evalAtXStaggeredBottomFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_z@current)
		AuStencil@current:[1, 0, 0] = (-1.0*(calc_diflow ( flow_e@current, diff_e )+max ( 0.0, (-1.0*flow_e@current) )))
		AuStencil@current:[-1, 0, 0] = (-1.0*(calc_diflow ( flow_w@current, diff_w )+max ( 0.0, flow_w@current )))
		AuStencil@current:[0, 1, 0] = (-1.0*(calc_diflow ( flow_n@current, diff_n )+max ( 0.0, (-1.0*flow_n@current) )))
		AuStencil@current:[0, -1, 0] = (-1.0*(calc_diflow ( flow_s@current, diff_s )+max ( 0.0, flow_s@current )))
		AuStencil@current:[0, 0, 1] = (-1.0*(calc_diflow ( flow_t@current, diff_t )+max ( 0.0, (-1.0*flow_t@current) )))
		AuStencil@current:[0, 0, -1] = (-1.0*(calc_diflow ( flow_b@current, diff_b )+max ( 0.0, flow_b@current )))
		Variable smasa : Real = (((((((flow_e@current-flow_w@current)+flow_n@current)-flow_s@current)+flow_t@current)-flow_b@current)/vf_xStagCellVolume@current)+((rho[activeSlot]@current-rho[previousSlot]@current)/dt))
		smasa = max ( 0.0, smasa )
		AuStencil@current:[0, 0, 0] = smasa
		AuStencil@current:[0, 0, 0] += (evalAtWestFace ( rho[activeSlot]@current )/dt)
		AuStencil@current:[0, 0, 0] = ((((((((AuStencil@current:[0, 0, 0]*vf_xStagCellVolume@current)-AuStencil@current:[1, 0, 0])-AuStencil@current:[-1, 0, 0])-AuStencil@current:[0, 1, 0])-AuStencil@current:[0, -1, 0])-AuStencil@current:[0, 0, 1])-AuStencil@current:[0, 0, -1])/relax_1)
		rhs_u@current = ((u[activeSlot]@current*smasa)+((u[previousSlot]@current*evalAtWestFace ( rho[previousSlot]@current ))/dt))
		rhs_u@current = ((rhs_u@current*vf_xStagCellVolume@current)+(((1.0-relax_1)*AuStencil@current:[0, 0, 0])*u[activeSlot]@current))
		rhs_u@current += ((vf_cellWidth_y@current*vf_cellWidth_z@current)*(p@current@[-1, 0, 0]-p@current))
	}
	communicate AuStencil@current
	StencilRestriction_u@current (  )
	loop over du@current {
		du@current = ((vf_cellWidth_y@current*vf_cellWidth_z@current)/AuStencil@current:[0, 0, 0])
	}
	communicate du@current
	apply bc to du@current
}

Function CompileStencil_v@finest ( ) : Unit {
	loop over AvStencil@current {
		Value flow_e@current : Real = integrateOverYStaggeredEastFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_w@current : Real = integrateOverYStaggeredWestFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_n@current : Real = integrateOverYStaggeredNorthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_s@current : Real = integrateOverYStaggeredSouthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_t@current : Real = integrateOverYStaggeredTopFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_b@current : Real = integrateOverYStaggeredBottomFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value diff_e : Real = (integrateOverYStaggeredEastFace ( evalAtYStaggeredEastFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_x@current@[1, 0, 0])
		Value diff_w : Real = (integrateOverYStaggeredWestFace ( evalAtYStaggeredWestFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_x@current)
		Value diff_n : Real = (integrateOverYStaggeredNorthFace ( vis@current )/vf_cellWidth_y@current)
		Value diff_s : Real = (integrateOverYStaggeredSouthFace ( vis@current )/vf_cellWidth_y@current@[0, -1, 0])
		Value diff_t : Real = (integrateOverYStaggeredTopFace ( evalAtYStaggeredTopFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_z@current@[0, 0, 1])
		Value diff_b : Real = (integrateOverYStaggeredBottomFace ( evalAtYStaggeredBottomFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_z@current)
		AvStencil@current:[1, 0, 0] = (-1.0*(calc_diflow ( flow_e@current, diff_e )+max ( 0.0, (-1.0*flow_e@current) )))
		AvStencil@current:[-1, 0, 0] = (-1.0*(calc_diflow ( flow_w@current, diff_w )+max ( 0.0, flow_w@current )))
		AvStencil@current:[0, 1, 0] = (-1.0*(calc_diflow ( flow_n@current, diff_n )+max ( 0.0, (-1.0*flow_n@current) )))
		AvStencil@current:[0, -1, 0] = (-1.0*(calc_diflow ( flow_s@current, diff_s )+max ( 0.0, flow_s@current )))
		AvStencil@current:[0, 0, 1] = (-1.0*(calc_diflow ( flow_t@current, diff_t )+max ( 0.0, (-1.0*flow_t@current) )))
		AvStencil@current:[0, 0, -1] = (-1.0*(calc_diflow ( flow_b@current, diff_b )+max ( 0.0, flow_b@current )))
		Variable smasa : Real = (((((((flow_e@current-flow_w@current)+flow_n@current)-flow_s@current)+flow_t@current)-flow_b@current)/vf_yStagCellVolume@current)+((rho[activeSlot]@current-rho[previousSlot]@current)/dt))
		smasa = max ( 0.0, smasa )
		AvStencil@current:[0, 0, 0] = smasa
		AvStencil@current:[0, 0, 0] += (evalAtSouthFace ( rho[activeSlot]@current )/dt)
		AvStencil@current:[0, 0, 0] = ((((((((AvStencil@current:[0, 0, 0]*vf_yStagCellVolume@current)-AvStencil@current:[1, 0, 0])-AvStencil@current:[-1, 0, 0])-AvStencil@current:[0, 1, 0])-AvStencil@current:[0, -1, 0])-AvStencil@current:[0, 0, 1])-AvStencil@current:[0, 0, -1])/relax_2)
		rhs_v@current = (-9.81*(rho[activeSlot]@current-rhoref))
		rhs_v@current += ((v[activeSlot]@current*smasa)+((v[previousSlot]@current*evalAtSouthFace ( rho[previousSlot]@current ))/dt))
		rhs_v@current = ((rhs_v@current*vf_yStagCellVolume@current)+(((1.0-relax_2)*AvStencil@current:[0, 0, 0])*v[activeSlot]@current))
		rhs_v@current += ((vf_cellWidth_x@current*vf_cellWidth_z@current)*(p@current@[0, -1, 0]-p@current))
	}
	communicate AvStencil@current
	StencilRestriction_v@current (  )
	loop over dv@current {
		dv@current = ((vf_cellWidth_x@current*vf_cellWidth_z@current)/AvStencil@current:[0, 0, 0])
	}
	communicate dv@current
	apply bc to dv@current
}

Function CompileStencil_w@finest ( ) : Unit {
	loop over AwStencil@current {
		Value flow_e@current : Real = integrateOverZStaggeredEastFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_w@current : Real = integrateOverZStaggeredWestFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_n@current : Real = integrateOverZStaggeredNorthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_s@current : Real = integrateOverZStaggeredSouthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_t@current : Real = integrateOverZStaggeredTopFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_b@current : Real = integrateOverZStaggeredBottomFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value diff_e : Real = (integrateOverZStaggeredEastFace ( evalAtZStaggeredEastFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_x@current@[1, 0, 0])
		Value diff_w : Real = (integrateOverZStaggeredWestFace ( evalAtZStaggeredWestFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_x@current)
		Value diff_n : Real = (integrateOverZStaggeredNorthFace ( evalAtZStaggeredNorthFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_y@current@[0, 1, 0])
		Value diff_s : Real = (integrateOverZStaggeredSouthFace ( evalAtZStaggeredSouthFace ( vis@current, "harmonicMean" ) )/vf_stagCVWidth_y@current)
		Value diff_t : Real = (integrateOverZStaggeredTopFace ( vis@current )/vf_cellWidth_z@current)
		Value diff_b : Real = (integrateOverZStaggeredBottomFace ( vis@current )/vf_cellWidth_z@current@[0, 0, -1])
		AwStencil@current:[1, 0, 0] = (-1.0*(calc_diflow ( flow_e@current, diff_e )+max ( 0.0, (-1.0*flow_e@current) )))
		AwStencil@current:[-1, 0, 0] = (-1.0*(calc_diflow ( flow_w@current, diff_w )+max ( 0.0, flow_w@current )))
		AwStencil@current:[0, 1, 0] = (-1.0*(calc_diflow ( flow_n@current, diff_n )+max ( 0.0, (-1.0*flow_n@current) )))
		AwStencil@current:[0, -1, 0] = (-1.0*(calc_diflow ( flow_s@current, diff_s )+max ( 0.0, flow_s@current )))
		AwStencil@current:[0, 0, 1] = (-1.0*(calc_diflow ( flow_t@current, diff_t )+max ( 0.0, (-1.0*flow_t@current) )))
		AwStencil@current:[0, 0, -1] = (-1.0*(calc_diflow ( flow_b@current, diff_b )+max ( 0.0, flow_b@current )))
		Variable smasa : Real = (((((((flow_e@current-flow_w@current)+flow_n@current)-flow_s@current)+flow_t@current)-flow_b@current)/vf_zStagCellVolume@current)+((rho[activeSlot]@current-rho[previousSlot]@current)/dt))
		smasa = max ( 0.0, smasa )
		AwStencil@current:[0, 0, 0] = smasa
		AwStencil@current:[0, 0, 0] += (evalAtBottomFace ( rho[activeSlot]@current )/dt)
		AwStencil@current:[0, 0, 0] = ((((((((AwStencil@current:[0, 0, 0]*vf_zStagCellVolume@current)-AwStencil@current:[1, 0, 0])-AwStencil@current:[-1, 0, 0])-AwStencil@current:[0, 1, 0])-AwStencil@current:[0, -1, 0])-AwStencil@current:[0, 0, 1])-AwStencil@current:[0, 0, -1])/relax_3)
		rhs_w@current = ((w[activeSlot]@current*smasa)+((w[previousSlot]@current*evalAtBottomFace ( rho[previousSlot]@current ))/dt))
		rhs_w@current = ((rhs_w@current*vf_zStagCellVolume@current)+(((1.0-relax_3)*AwStencil@current:[0, 0, 0])*w[activeSlot]@current))
		rhs_w@current += ((vf_cellWidth_x@current*vf_cellWidth_y@current)*(p@current@[0, 0, -1]-p@current))
	}
	communicate AwStencil@current
	StencilRestriction_w@current (  )
	loop over dw@current {
		dw@current = ((vf_cellWidth_x@current*vf_cellWidth_y@current)/AwStencil@current:[0, 0, 0])
	}
	communicate dw@current
	apply bc to dw@current
}

Function CompileStencil_pc@finest ( ) : Unit {
	loop over ApcStencil@current {
		ApcStencil@current:[1, 0, 0] = (-1.0*integrateOverEastFace ( (du@current*rho[activeSlot]@current) ))
		ApcStencil@current:[-1, 0, 0] = (-1.0*integrateOverWestFace ( (du@current*rho[activeSlot]@current) ))
		ApcStencil@current:[0, 1, 0] = (-1.0*integrateOverNorthFace ( (dv@current*rho[activeSlot]@current) ))
		ApcStencil@current:[0, -1, 0] = (-1.0*integrateOverSouthFace ( (dv@current*rho[activeSlot]@current) ))
		ApcStencil@current:[0, 0, 1] = (-1.0*integrateOverTopFace ( (dw@current*rho[activeSlot]@current) ))
		ApcStencil@current:[0, 0, -1] = (-1.0*integrateOverBottomFace ( (dw@current*rho[activeSlot]@current) ))
		ApcStencil@current:[0, 0, 0] = (-1.0*(((((ApcStencil@current:[1, 0, 0]+ApcStencil@current:[-1, 0, 0])+ApcStencil@current:[0, 1, 0])+ApcStencil@current:[0, -1, 0])+ApcStencil@current:[0, 0, 1])+ApcStencil@current:[0, 0, -1]))
		rhs_pc@current = ((((((integrateOverWestFace ( (u[activeSlot]@current*rho[activeSlot]@current) )-integrateOverEastFace ( (u[activeSlot]@current*rho[activeSlot]@current) ))+integrateOverSouthFace ( (v[activeSlot]@current*rho[activeSlot]@current) ))-integrateOverNorthFace ( (v[activeSlot]@current*rho[activeSlot]@current) ))+integrateOverBottomFace ( (w[activeSlot]@current*rho[activeSlot]@current) ))-integrateOverTopFace ( (w[activeSlot]@current*rho[activeSlot]@current) ))+((((vf_cellWidth_y@current*vf_cellWidth_z@current)*vf_cellWidth_x@current)*(rho[previousSlot]@current-rho[activeSlot]@current))/dt))
	}
	StencilRestriction_pc@current (  )
}

Function CompileStencil_t@finest ( ) : Unit {
	loop over AtStencil@current {
		Value flow_e@current : Real = integrateOverEastFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_w@current : Real = integrateOverWestFace ( (u[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_n@current : Real = integrateOverNorthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_s@current : Real = integrateOverSouthFace ( (v[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_t@current : Real = integrateOverTopFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value flow_b@current : Real = integrateOverBottomFace ( (w[activeSlot]@current*rho[activeSlot]@current) )
		Value diff_e : Real = (integrateOverEastFace ( evalAtEastFace ( gamma@current, "harmonicMean" ) )/vf_stagCVWidth_x@current@[1, 0, 0])
		Value diff_w : Real = (integrateOverWestFace ( evalAtWestFace ( gamma@current, "harmonicMean" ) )/vf_stagCVWidth_x@current)
		Value diff_n : Real = (integrateOverNorthFace ( evalAtNorthFace ( gamma@current, "harmonicMean" ) )/vf_stagCVWidth_y@current@[0, 1, 0])
		Value diff_s : Real = (integrateOverSouthFace ( evalAtSouthFace ( gamma@current, "harmonicMean" ) )/vf_stagCVWidth_y@current)
		Value diff_t : Real = (integrateOverTopFace ( evalAtTopFace ( gamma@current, "harmonicMean" ) )/vf_stagCVWidth_z@current@[0, 0, 1])
		Value diff_b : Real = (integrateOverBottomFace ( evalAtBottomFace ( gamma@current, "harmonicMean" ) )/vf_stagCVWidth_z@current)
		AtStencil@current:[1, 0, 0] = (-1.0*(calc_diflow ( flow_e@current, diff_e )+max ( 0.0, (-1.0*flow_e@current) )))
		AtStencil@current:[-1, 0, 0] = (-1.0*(calc_diflow ( flow_w@current, diff_w )+max ( 0.0, flow_w@current )))
		AtStencil@current:[0, 1, 0] = (-1.0*(calc_diflow ( flow_n@current, diff_n )+max ( 0.0, (-1.0*flow_n@current) )))
		AtStencil@current:[0, -1, 0] = (-1.0*(calc_diflow ( flow_s@current, diff_s )+max ( 0.0, flow_s@current )))
		AtStencil@current:[0, 0, 1] = (-1.0*(calc_diflow ( flow_t@current, diff_t )+max ( 0.0, (-1.0*flow_t@current) )))
		AtStencil@current:[0, 0, -1] = (-1.0*(calc_diflow ( flow_b@current, diff_b )+max ( 0.0, flow_b@current )))
		Variable smasa : Real = (((((((flow_e@current-flow_w@current)+flow_n@current)-flow_s@current)+flow_t@current)-flow_b@current)/vf_cellVolume@current)+((rho[activeSlot]@current-rho[previousSlot]@current)/dt))
		smasa = max ( 0.0, smasa )
		AtStencil@current:[0, 0, 0] = (smasa+(rho[activeSlot]@current/dt))
		AtStencil@current:[0, 0, 0] = ((((((((AtStencil@current:[0, 0, 0]*vf_cellVolume@current)-AtStencil@current:[1, 0, 0])-AtStencil@current:[-1, 0, 0])-AtStencil@current:[0, 1, 0])-AtStencil@current:[0, -1, 0])-AtStencil@current:[0, 0, 1])-AtStencil@current:[0, 0, -1])/relax_7)
		rhs_t@current = ((smasa*phi7[activeSlot]@current)+((rho[activeSlot]@current/dt)*phi7[previousSlot]@current))
		rhs_t@current = ((rhs_t@current*vf_cellVolume@current)+(((1.0-relax_7)*AtStencil@current:[0, 0, 0])*phi7[activeSlot]@current))
	}
	StencilRestriction_t@current (  )
}

FunctionTemplate SolveComponent < vCycle, normFunction, maxSteps, rhs, converged > (  ) : Unit {
	Variable initRes : Real = normFunction@current (  )
	Variable curRes : Real = initRes
	Variable prevRes : Real = curRes
	Variable numIt : Integer = 0
	totalInitRes += initRes
	Variable normRHS : Real = 0
	loop over rhs with reduction ( + : normRHS ) {
		normRHS += rhs**2
	}
	normRHS = sqrt ( normRHS )
	if ((curRes<=(targetResPerComp*(1.0+normRHS)))) {
		converged = true
	}
	repeat until ((numIt>0)&&(((curRes<=(targetResPerComp*(1.0+normRHS)))||(numIt>=maxSteps))||((numIt>0)&&((prevRes-curRes)<(stagnationThreshold*targetResPerComp))))){
		vCycle@current (  )
		prevRes = curRes
		curRes = normFunction@current (  )
		numIt += 1
	}
}

FunctionTemplate StencilRestrictionComponent < self, source, dest, restrictionStencil > (  ) : Unit {
	loop over dest {
		dest:[0, 0, 0] = (restrictionStencil*source:[0, 0, 0])
		dest:[-1, 0, 0] = (restrictionStencil*source:[-1, 0, 0])
		dest:[1, 0, 0] = (restrictionStencil*source:[1, 0, 0])
		dest:[0, -1, 0] = (restrictionStencil*source:[0, -1, 0])
		dest:[0, 1, 0] = (restrictionStencil*source:[0, 1, 0])
		dest:[0, 0, -1] = (restrictionStencil*source:[0, 0, -1])
		dest:[0, 0, 1] = (restrictionStencil*source:[0, 0, 1])
	}
	communicate dest
	apply bc to dest
	if (((levels@current (  )-1)>levels@coarsest (  ))) {
		self@coarser (  )
	}
}

Instantiate SolveComponent < VCycle_u, NormResidual_u, 100, rhs_u@current, converged_u >  as Solve_u@finest

Instantiate StencilRestrictionComponent < StencilRestriction_u, AuStencil@current, AuStencil@coarser, RestrictionFaceX@current >  as StencilRestriction_u@((coarsest + 1) to finest)

Instantiate SolveComponent < VCycle_v, NormResidual_v, 100, rhs_v@current, converged_v >  as Solve_v@finest

Instantiate StencilRestrictionComponent < StencilRestriction_v, AvStencil@current, AvStencil@coarser, RestrictionFaceY@current >  as StencilRestriction_v@((coarsest + 1) to finest)

Instantiate SolveComponent < VCycle_w, NormResidual_w, 100, rhs_w@current, converged_w >  as Solve_w@finest

Instantiate StencilRestrictionComponent < StencilRestriction_w, AwStencil@current, AwStencil@coarser, RestrictionFaceZ@current >  as StencilRestriction_w@((coarsest + 1) to finest)

Instantiate SolveComponent < VCycle_pc, NormResidual_pc, 100, rhs_pc@current, converged_pc >  as Solve_pc@finest

Instantiate StencilRestrictionComponent < StencilRestriction_pc, ApcStencil@current, ApcStencil@coarser, RestrictionCell@current >  as StencilRestriction_pc@((coarsest + 1) to finest)

Instantiate SolveComponent < VCycle_t, NormResidual_t, 100, rhs_t@current, converged_t >  as Solve_t@finest

Instantiate StencilRestrictionComponent < StencilRestriction_t, AtStencil@current, AtStencil@coarser, RestrictionCell@current >  as StencilRestriction_t@((coarsest + 1) to finest)

Function InitFields ( ) : Unit {
	
}

Function AdvanceFields@(5) ( ) : Unit {
	loop over u[nextSlot]@current {
		u[nextSlot]@current = u@current
	}
	apply bc to u[nextSlot]@current
	
	loop over v[nextSlot]@current {
		v[nextSlot]@current = v@current
	}
	apply bc to v[nextSlot]@current
	
	loop over w[nextSlot]@current {
		w[nextSlot]@current = w@current
	}
	apply bc to w[nextSlot]@current
	
	loop over rho[nextSlot]@current {
		rho[nextSlot]@current = rho@current
	}
	apply bc to rho[nextSlot]@current
	
	loop over phi7[nextSlot]@current {
		phi7[nextSlot]@current = phi7@current
	}
	apply bc to phi7[nextSlot]@current
	
}

Function Smooth_u@(2, 1, 3, 4, 5) ( ) : Unit {
	repeat 3 times {
		communicate ghost to [1, 1, 1] of u@current
		loop over u@current where (0==(((x+y)+z)%2)){
			u@current += ((1.0*diag_inv ( AuStencil@current ))*(rhs_u@current-(AuStencil@current*u@current)))
		}
		apply bc to u@current
		communicate ghost to [1, 1, 1] of u@current
		loop over u@current where (1==(((x+y)+z)%2)){
			u@current += ((1.0*diag_inv ( AuStencil@current ))*(rhs_u@current-(AuStencil@current*u@current)))
		}
		apply bc to u@current
	}
}

Function Smooth_v@(2, 1, 3, 4, 5) ( ) : Unit {
	repeat 3 times {
		communicate ghost to [1, 1, 1] of v@current
		loop over v@current where (0==(((x+y)+z)%2)){
			v@current += ((1.0*diag_inv ( AvStencil@current ))*(rhs_v@current-(AvStencil@current*v@current)))
		}
		apply bc to v@current
		communicate ghost to [1, 1, 1] of v@current
		loop over v@current where (1==(((x+y)+z)%2)){
			v@current += ((1.0*diag_inv ( AvStencil@current ))*(rhs_v@current-(AvStencil@current*v@current)))
		}
		apply bc to v@current
	}
}

Function Smooth_w@(2, 1, 3, 4, 5) ( ) : Unit {
	repeat 3 times {
		communicate ghost to [1, 1, 1] of w@current
		loop over w@current where (0==(((x+y)+z)%2)){
			w@current += ((1.0*diag_inv ( AwStencil@current ))*(rhs_w@current-(AwStencil@current*w@current)))
		}
		apply bc to w@current
		communicate ghost to [1, 1, 1] of w@current
		loop over w@current where (1==(((x+y)+z)%2)){
			w@current += ((1.0*diag_inv ( AwStencil@current ))*(rhs_w@current-(AwStencil@current*w@current)))
		}
		apply bc to w@current
	}
}

Function Smooth_pc@(2, 1, 3, 4, 5) ( ) : Unit {
	repeat 3 times {
		communicate ghost to [1, 1, 1] of pc@current
		loop over pc@current where (0==(((x+y)+z)%2)){
			pc@current += ((0.8*diag_inv ( ApcStencil@current ))*(rhs_pc@current-(ApcStencil@current*pc@current)))
		}
		apply bc to pc@current
		communicate ghost to [1, 1, 1] of pc@current
		loop over pc@current where (1==(((x+y)+z)%2)){
			pc@current += ((0.8*diag_inv ( ApcStencil@current ))*(rhs_pc@current-(ApcStencil@current*pc@current)))
		}
		apply bc to pc@current
	}
}

Function Smooth_t@(2, 1, 3, 4, 5) ( ) : Unit {
	repeat 3 times {
		communicate ghost to [1, 1, 1] of phi7@current
		loop over phi7@current where (0==(((x+y)+z)%2)){
			phi7@current += ((1.0*diag_inv ( AtStencil@current ))*(rhs_t@current-(AtStencil@current*phi7@current)))
		}
		apply bc to phi7@current
		communicate ghost to [1, 1, 1] of phi7@current
		loop over phi7@current where (1==(((x+y)+z)%2)){
			phi7@current += ((1.0*diag_inv ( AtStencil@current ))*(rhs_t@current-(AtStencil@current*phi7@current)))
		}
		apply bc to phi7@current
	}
}

Function VCycle_u@(2, 3, 4, 5) ( ) : Unit {
	Smooth_u@current (  )
	communicate ghost to [1, 1, 1] of u@current
	loop over residual_u@current {
		residual_u@current = (rhs_u@current-(AuStencil@current*u@current))
	}
	apply bc to residual_u@current
	communicate ghost to [1, 1, 1] of residual_u@current
	loop over rhs_u@coarser {
		rhs_u@coarser = (RestrictionFaceX@current*residual_u@current)
	}
	apply bc to rhs_u@coarser
	loop over u@coarser {
		u@coarser = 0.0
	}
	apply bc to u@coarser
	VCycle_u@coarser (  )
	communicate ghost to [1, 0, 0] of u@coarser
	loop over u@current {
		u@current += (CorrectionFaceX@current*u@coarser)
	}
	apply bc to u@current
	Smooth_u@current (  )
}

Function VCycle_v@(2, 3, 4, 5) ( ) : Unit {
	Smooth_v@current (  )
	communicate ghost to [1, 1, 1] of v@current
	loop over residual_v@current {
		residual_v@current = (rhs_v@current-(AvStencil@current*v@current))
	}
	apply bc to residual_v@current
	communicate ghost to [1, 1, 1] of residual_v@current
	loop over rhs_v@coarser {
		rhs_v@coarser = (RestrictionFaceY@current*residual_v@current)
	}
	apply bc to rhs_v@coarser
	loop over v@coarser {
		v@coarser = 0.0
	}
	apply bc to v@coarser
	VCycle_v@coarser (  )
	communicate ghost to [0, 1, 0] of v@coarser
	loop over v@current {
		v@current += (CorrectionFaceY@current*v@coarser)
	}
	apply bc to v@current
	Smooth_v@current (  )
}

Function VCycle_w@(2, 3, 4, 5) ( ) : Unit {
	Smooth_w@current (  )
	communicate ghost to [1, 1, 1] of w@current
	loop over residual_w@current {
		residual_w@current = (rhs_w@current-(AwStencil@current*w@current))
	}
	apply bc to residual_w@current
	communicate ghost to [1, 1, 1] of residual_w@current
	loop over rhs_w@coarser {
		rhs_w@coarser = (RestrictionFaceZ@current*residual_w@current)
	}
	apply bc to rhs_w@coarser
	loop over w@coarser {
		w@coarser = 0.0
	}
	apply bc to w@coarser
	VCycle_w@coarser (  )
	communicate ghost to [0, 0, 1] of w@coarser
	loop over w@current {
		w@current += (CorrectionFaceZ@current*w@coarser)
	}
	apply bc to w@current
	Smooth_w@current (  )
}

Function VCycle_pc@(2, 3, 4, 5) ( ) : Unit {
	Smooth_pc@current (  )
	communicate ghost to [1, 1, 1] of pc@current
	loop over residual_pc@current {
		residual_pc@current = (rhs_pc@current-(ApcStencil@current*pc@current))
	}
	apply bc to residual_pc@current
	communicate ghost to [1, 1, 1] of residual_pc@current
	loop over rhs_pc@coarser {
		rhs_pc@coarser = (RestrictionCell@current*residual_pc@current)
	}
	apply bc to rhs_pc@coarser
	loop over pc@coarser {
		pc@coarser = 0.0
	}
	apply bc to pc@coarser
	VCycle_pc@coarser (  )
	loop over pc@current {
		pc@current += (CorrectionCell@current*pc@coarser)
	}
	apply bc to pc@current
	Smooth_pc@current (  )
}

Function VCycle_t@(2, 3, 4, 5) ( ) : Unit {
	Smooth_t@current (  )
	communicate ghost to [1, 1, 1] of phi7@current
	loop over residual_t@current {
		residual_t@current = (rhs_t@current-(AtStencil@current*phi7@current))
	}
	apply bc to residual_t@current
	communicate ghost to [1, 1, 1] of residual_t@current
	loop over rhs_t@coarser {
		rhs_t@coarser = (RestrictionCell@current*residual_t@current)
	}
	apply bc to rhs_t@coarser
	loop over phi7@coarser {
		phi7@coarser = 0.0
	}
	apply bc to phi7@coarser
	VCycle_t@coarser (  )
	loop over phi7@current {
		phi7@current += (CorrectionCell@current*phi7@coarser)
	}
	apply bc to phi7@current
	Smooth_t@current (  )
}

Function VCycle_u@(1) ( ) : Unit {
	repeat 4 times {
		communicate ghost to [1, 1, 1] of u@current
		loop over u@current where (0==(((x+y)+z)%2)){
			u@current += (((1.0/diag ( AuStencil@current ))*1.0)*(rhs_u@current-(AuStencil@current*u@current)))
		}
		apply bc to u@current
		communicate ghost to [1, 1, 1] of u@current
		loop over u@current where (1==(((x+y)+z)%2)){
			u@current += (((1.0/diag ( AuStencil@current ))*1.0)*(rhs_u@current-(AuStencil@current*u@current)))
		}
		apply bc to u@current
	}
}

Function VCycle_v@(1) ( ) : Unit {
	repeat 4 times {
		communicate ghost to [1, 1, 1] of v@current
		loop over v@current where (0==(((x+y)+z)%2)){
			v@current += (((1.0/diag ( AvStencil@current ))*1.0)*(rhs_v@current-(AvStencil@current*v@current)))
		}
		apply bc to v@current
		communicate ghost to [1, 1, 1] of v@current
		loop over v@current where (1==(((x+y)+z)%2)){
			v@current += (((1.0/diag ( AvStencil@current ))*1.0)*(rhs_v@current-(AvStencil@current*v@current)))
		}
		apply bc to v@current
	}
}

Function VCycle_w@(1) ( ) : Unit {
	repeat 4 times {
		communicate ghost to [1, 1, 1] of w@current
		loop over w@current where (0==(((x+y)+z)%2)){
			w@current += (((1.0/diag ( AwStencil@current ))*1.0)*(rhs_w@current-(AwStencil@current*w@current)))
		}
		apply bc to w@current
		communicate ghost to [1, 1, 1] of w@current
		loop over w@current where (1==(((x+y)+z)%2)){
			w@current += (((1.0/diag ( AwStencil@current ))*1.0)*(rhs_w@current-(AwStencil@current*w@current)))
		}
		apply bc to w@current
	}
}

Function VCycle_pc@(1) ( ) : Unit {
	repeat 4 times {
		communicate ghost to [1, 1, 1] of pc@current
		loop over pc@current where (0==(((x+y)+z)%2)){
			pc@current += (((1.0/diag ( ApcStencil@current ))*0.8)*(rhs_pc@current-(ApcStencil@current*pc@current)))
		}
		apply bc to pc@current
		communicate ghost to [1, 1, 1] of pc@current
		loop over pc@current where (1==(((x+y)+z)%2)){
			pc@current += (((1.0/diag ( ApcStencil@current ))*0.8)*(rhs_pc@current-(ApcStencil@current*pc@current)))
		}
		apply bc to pc@current
	}
}

Function VCycle_t@(1) ( ) : Unit {
	repeat 4 times {
		communicate ghost to [1, 1, 1] of phi7@current
		loop over phi7@current where (0==(((x+y)+z)%2)){
			phi7@current += (((1.0/diag ( AtStencil@current ))*1.0)*(rhs_t@current-(AtStencil@current*phi7@current)))
		}
		apply bc to phi7@current
		communicate ghost to [1, 1, 1] of phi7@current
		loop over phi7@current where (1==(((x+y)+z)%2)){
			phi7@current += (((1.0/diag ( AtStencil@current ))*1.0)*(rhs_t@current-(AtStencil@current*phi7@current)))
		}
		apply bc to phi7@current
	}
}

Function UpdateResidual_u@(1) ( ) : Unit {
	communicate ghost to [1, 1, 1] of u@current
	loop over residual_u@current {
		residual_u@current = (rhs_u@current-(AuStencil@current*u@current))
	}
	apply bc to residual_u@current
}

Function UpdateResidual_v@(1) ( ) : Unit {
	communicate ghost to [1, 1, 1] of v@current
	loop over residual_v@current {
		residual_v@current = (rhs_v@current-(AvStencil@current*v@current))
	}
	apply bc to residual_v@current
}

Function UpdateResidual_w@(1) ( ) : Unit {
	communicate ghost to [1, 1, 1] of w@current
	loop over residual_w@current {
		residual_w@current = (rhs_w@current-(AwStencil@current*w@current))
	}
	apply bc to residual_w@current
}

Function UpdateResidual_pc@(1) ( ) : Unit {
	communicate ghost to [1, 1, 1] of pc@current
	loop over residual_pc@current {
		residual_pc@current = (rhs_pc@current-(ApcStencil@current*pc@current))
	}
	apply bc to residual_pc@current
}

Function UpdateResidual_t@(1) ( ) : Unit {
	communicate ghost to [1, 1, 1] of phi7@current
	loop over residual_t@current {
		residual_t@current = (rhs_t@current-(AtStencil@current*phi7@current))
	}
	apply bc to residual_t@current
}

Function NormResidual_u@(5) ( ) : Real {
	communicate ghost to [1, 1, 1] of u@current
	loop over residual_u@current {
		residual_u@current = (rhs_u@current-(AuStencil@current*u@current))
	}
	apply bc to residual_u@current
	Variable reductionVar_0 : Real = 0.0
	loop over residual_u@current with reduction ( + : reductionVar_0 ) {
		reductionVar_0 += (residual_u@current*residual_u@current)
	}
	return sqrt ( reductionVar_0 )
}

Function NormResidual_v@(5) ( ) : Real {
	communicate ghost to [1, 1, 1] of v@current
	loop over residual_v@current {
		residual_v@current = (rhs_v@current-(AvStencil@current*v@current))
	}
	apply bc to residual_v@current
	Variable reductionVar_0 : Real = 0.0
	loop over residual_v@current with reduction ( + : reductionVar_0 ) {
		reductionVar_0 += (residual_v@current*residual_v@current)
	}
	return sqrt ( reductionVar_0 )
}

Function NormResidual_w@(5) ( ) : Real {
	communicate ghost to [1, 1, 1] of w@current
	loop over residual_w@current {
		residual_w@current = (rhs_w@current-(AwStencil@current*w@current))
	}
	apply bc to residual_w@current
	Variable reductionVar_0 : Real = 0.0
	loop over residual_w@current with reduction ( + : reductionVar_0 ) {
		reductionVar_0 += (residual_w@current*residual_w@current)
	}
	return sqrt ( reductionVar_0 )
}

Function NormResidual_pc@(5) ( ) : Real {
	communicate ghost to [1, 1, 1] of pc@current
	loop over residual_pc@current {
		residual_pc@current = (rhs_pc@current-(ApcStencil@current*pc@current))
	}
	apply bc to residual_pc@current
	Variable reductionVar_0 : Real = 0.0
	loop over residual_pc@current with reduction ( + : reductionVar_0 ) {
		reductionVar_0 += (residual_pc@current*residual_pc@current)
	}
	return sqrt ( reductionVar_0 )
}

Function NormResidual_t@(5) ( ) : Real {
	communicate ghost to [1, 1, 1] of phi7@current
	loop over residual_t@current {
		residual_t@current = (rhs_t@current-(AtStencil@current*phi7@current))
	}
	apply bc to residual_t@current
	Variable reductionVar_0 : Real = 0.0
	loop over residual_t@current with reduction ( + : reductionVar_0 ) {
		reductionVar_0 += (residual_t@current*residual_t@current)
	}
	return sqrt ( reductionVar_0 )
}

