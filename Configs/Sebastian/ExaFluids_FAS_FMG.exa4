// layer 4 code

Domain global< [ 0, 0, 0 ] to [ 0.05, 0.05, 0.05 ] >

Layout DefCellLayout < Real , Cell > @all {
	duplicateLayers	= [ 0, 0, 0 ]
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceXLayout < Real , Face_x > @all {
	duplicateLayers	= [ 1, 0, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceYLayout < Real , Face_y > @all {
	duplicateLayers	= [ 0, 1, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout DefFaceZLayout < Real , Face_z > @all {
	duplicateLayers	= [ 0, 0, 1 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout CellStencilLayout < Array<Real><7>, Cell > @all {
	duplicateLayers	= [ 0, 0, 0 ]
	ghostLayers		= [ 1, 1, 1 ] // no communication necessary since only required for subexpression re-usage
}

Layout FaceXStencilLayout < Array<Real><7>, Face_x > @all {
	duplicateLayers	= [ 1, 0, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication	// only communicate face dim's ghost layers -> fix in communicate call
}

Layout FaceYStencilLayout < Array<Real><7>, Face_y > @all {
	duplicateLayers	= [ 0, 1, 0 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

Layout FaceZStencilLayout < Array<Real><7>, Face_z > @all {
	duplicateLayers	= [ 0, 0, 1 ] with communication
	ghostLayers		= [ 1, 1, 1 ] with communication
}

// values associated with u, ie face_x

Field u < global, DefFaceXLayout, 0.0 >[2] @all
Field uApprox < global, DefFaceXLayout, 0.0 > @all

Field residual_u < global, DefFaceXLayout, 0.0 > @all
Field rhs_u < global, DefFaceXLayout, None > @all

Field AuStencilData< global, FaceXStencilLayout, None > @all
StencilField AuStencil< AuStencilData => SevenPointStencil > @all

// values associated with v, ie face_y

Field v < global, DefFaceYLayout, 0.0 >[2] @all
Field vApprox < global, DefFaceYLayout, 0.0 > @all

Field residual_v < global, DefFaceYLayout, 0.0 > @all
Field rhs_v < global, DefFaceYLayout, None > @all

Field AvStencilData< global, FaceYStencilLayout, None > @all
StencilField AvStencil< AvStencilData => SevenPointStencil > @all

// values associated with w, ie face_z

Field w < global, DefFaceZLayout, 0.0 >[2] @all
Field wApprox < global, DefFaceZLayout, 0.0 > @all

Field residual_w < global, DefFaceZLayout, 0.0 > @all
Field rhs_w < global, DefFaceZLayout, None > @all

Field AwStencilData< global, FaceZStencilLayout, None > @all
StencilField AwStencil< AwStencilData => SevenPointStencil > @all

// values associated with p and rho, ie cell center

Field rho < global, DefCellLayout, Neumann >[2] @all
Field p < global, DefCellLayout, Neumann > @all
Field pApprox < global, DefCellLayout, Neumann > @all

Field residual_p < global, DefCellLayout, 0.0 > @all
Field rhs_p < global, DefCellLayout, None > @all

// values associated with phi7, ie cell center

Field phi7 < global, DefCellLayout, applyBC_t@current ( ) >[2] @all
Field phi7Approx < global, DefCellLayout, applyBC_tApprox@current ( ) > @all

Field residual_t < global, DefCellLayout, Neumann > @all
Field rhs_t < global, DefCellLayout, None > @all

Field AtStencilData< global, CellStencilLayout, None > @all
StencilField AtStencil< AtStencilData => SevenPointStencil > @all

// auxilary fields

Field vis < global, DefCellLayout, Neumann > @all
Field miu < global, DefCellLayout, Neumann > @all

Field gamma < global, DefCellLayout, Neumann > @all

// stencils and stencils templates

Stencil SevenPointStencil@all {
	[ 0,  0,  0] =>  6.0
	[-1,  0,  0] => -1.0
	[ 1,  0,  0] => -1.0
	[ 0, -1,  0] => -1.0
	[ 0,  1,  0] => -1.0
	[ 0,  0, -1] => -1.0
	[ 0,  0,  1] => -1.0
}

Stencil CorrectionCell@all {
	[ 0,  0,  0] => 1.0
}
/*
// TODO: nodePos -> faceXPos
Stencil CorrectionFaceX@all {
	[    0,  0,  0] => (
		  ( vf_nodePosition_x@current@[ 1,  0,  0] - vf_nodePosition_x@current@[ 0,  0,  0] )
		/ ( vf_nodePosition_x@current@[ 1,  0,  0] - vf_nodePosition_x@current@[-1,  0,  0] ) ) // 0.5
	[x % 2,  0,  0] => (
		  ( vf_nodePosition_x@current@[ 0,  0,  0] - vf_nodePosition_x@current@[-1,  0,  0] )
		/ ( vf_nodePosition_x@current@[ 1,  0,  0] - vf_nodePosition_x@current@[-1,  0,  0] ) ) // 0.5
}

// TODO: nodePos -> faceYPos
Stencil CorrectionFaceY@all {
	[    0,  0,  0] => (
		  ( vf_nodePosition_y@current@[ 0,  1,  0] - vf_nodePosition_y@current@[ 0,  0,  0] ) 
		/ ( vf_nodePosition_y@current@[ 0,  1,  0] - vf_nodePosition_y@current@[ 0, -1,  0] ) ) // 0.5
	[ 0, y % 2,  0] => (
		  ( vf_nodePosition_y@current@[ 0,  0,  0] - vf_nodePosition_y@current@[ 0, -1,  0] )
		/ ( vf_nodePosition_y@current@[ 0,  1,  0] - vf_nodePosition_y@current@[ 0, -1,  0] ) ) // 0.5
}

// TODO: nodePos -> faceZPos
Stencil CorrectionFaceZ@all {
	[    0,  0,  0] => (
		  ( vf_nodePosition_z@current@[ 0,  0,  1] - vf_nodePosition_z@current@[ 0,  0,  0] ) 
		/ ( vf_nodePosition_z@current@[ 0,  0,  1] - vf_nodePosition_z@current@[ 0,  0, -1] ) ) // 0.5
	[ 0,  0, z % 2] => (
		  ( vf_nodePosition_z@current@[ 0,  0,  0] - vf_nodePosition_z@current@[ 0,  0, -1] )
		/ ( vf_nodePosition_z@current@[ 0,  0,  1] - vf_nodePosition_z@current@[ 0,  0, -1] ) ) // 0.5
}
*/
// TODO: nodePos -> faceXPos
Stencil CorrectionFaceX@all {
	[    0,  0,  0] => 0.5
	[x % 2,  0,  0] => 0.5
}

// TODO: nodePos -> faceYPos
Stencil CorrectionFaceY@all {
	[    0,  0,  0] => 0.5
	[ 0, y % 2,  0] => 0.5
}

// TODO: nodePos -> faceZPos
Stencil CorrectionFaceZ@all {
	[    0,  0,  0] => 0.5
	[ 0,  0, z % 2] => 0.5
}

Stencil RestrictionCell@all {
	[ 0,  0,  0] => 0.125
    [ 0,  0,  1] => 0.125
    [ 0,  1,  0] => 0.125
    [ 1,  0,  0] => 0.125
    [ 0,  1,  1] => 0.125
    [ 1,  0,  1] => 0.125
    [ 1,  1,  0] => 0.125
    [ 1,  1,  1] => 0.125
}

Stencil RestrictionFaceX@all {
	[ 0,  0,  0] => 0.125
	[-1,  0,  0] => 0.0625
	[ 1,  0,  0] => 0.0625

	[ 0,  1,  0] => 0.125
	[-1,  1,  0] => 0.0625
	[ 1,  1,  0] => 0.0625

	[ 0,  0,  1] => 0.125
	[-1,  0,  1] => 0.0625
	[ 1,  0,  1] => 0.0625

	[ 0,  1,  1] => 0.125
	[-1,  1,  1] => 0.0625
	[ 1,  1,  1] => 0.0625
}

Stencil RestrictionFaceY@all {
	[ 0,  0,  0] => 0.125
	[ 0, -1,  0] => 0.0625
	[ 0,  1,  0] => 0.0625

	[ 0,  0,  1] => 0.125
	[ 0, -1,  1] => 0.0625
	[ 0,  1,  1] => 0.0625

	[ 1,  0,  0] => 0.125
	[ 1, -1,  0] => 0.0625
	[ 1,  1,  0] => 0.0625

	[ 1,  0,  1] => 0.125
	[ 1, -1,  1] => 0.0625
	[ 1,  1,  1] => 0.0625
}

Stencil RestrictionFaceZ@all {
	[ 0,  0,  0] => 0.125
	[ 0,  0, -1] => 0.0625
	[ 0,  0,  1] => 0.0625

	[ 1,  0,  0] => 0.125
	[ 1,  0, -1] => 0.0625
	[ 1,  0,  1] => 0.0625

	[ 0,  1,  0] => 0.125
	[ 0,  1, -1] => 0.0625
	[ 0,  1,  1] => 0.0625

	[ 1,  1,  0] => 0.125
	[ 1,  1, -1] => 0.0625
	[ 1,  1,  1] => 0.0625
}

Globals {
	// global states
	Var curTime : Real          = 0.0

	Var totalInitRes : Real     = 0.0
	Var lastTotalInitRes : Real = 0.0

	Var converged_u : Boolean	= false
	Var converged_v : Boolean	= false
	Var converged_w : Boolean	= false
	Var converged_pc : Boolean	= false
	Var converged_t : Boolean	= false

	// printing
	Var nextPrintTime : Real	= 0
	Var printInterval : Real	= 100// * dt

	// solver constants
	Var dt : Real 		        = 100.0
	Var maxTime : Real          = 10000.0

	// TODO: per level? adaptive?
	/*Var relax_u@(all, not (finest, finest-1)) : Real = 0.125
	Var relax_v@(all, not (finest, finest-1)) : Real = 0.125
	Var relax_w@(all, not (finest, finest-1)) : Real = 0.125
	Var relax_p@(all, not (finest, finest-1)) : Real = 0.125
	Var relax_t@(all, not (finest, finest-1)) : Real = 0.125

	Var relax_u@(finest-1) : Real                    = 0.25
	Var relax_v@(finest-1) : Real                    = 0.25
	Var relax_w@(finest-1) : Real                    = 0.25
	Var relax_p@(finest-1) : Real                    = 0.25
	Var relax_t@(finest-1) : Real                    = 0.25

	Var relax_u@(finest) : Real                      = 0.5
	Var relax_v@(finest) : Real                      = 0.5
	Var relax_w@(finest) : Real                      = 0.5
	Var relax_p@(finest) : Real                      = 0.5
	Var relax_t@(finest) : Real                      = 0.5*/

	Var relax_u@all : Real = 1
	Var relax_v@all : Real = 1
	Var relax_w@all : Real = 1
	Var relax_p@all : Real = 1
	Var relax_t@all : Real = 1

	// exit criteria
	Var targetResPerComp : Real		= 1.0e-6
	Var stagnationThreshold : Real	= 1.0e-4
	Val maxSimpleIterations : Int	= 1000000

	// density constants
	Val rhoref : Real           = 0.0
	Val rhocon : Real           = 999.7 // overwritten by updateProperties
	Val visl : Real             = 1.0e-5 // overwritten by updateProperties

	// temperature constants
	Val th : Real               = 283.15
	Val tc : Real               = 273.15
	Val t_ph : Real             = 273.15
	Val temp_ref : Real         = 270.592
	Val delta_temp : Real       = 0.2

	// temperatures solidus & liquidus
	Val t_sol : Real            = t_ph + delta_temp
	Val t_liq : Real            = t_ph - delta_temp

	// phase change enthalpy
	Val hls : Real              = 3.35e5

	// phase properties
	Val miu_liq : Real          = 0.001197941294207
	Val cp_liq : Real           = 4202.1178518932
	Val rho_liq : Real          = 1000.12926014462
	Val cond_liq : Real         = 0.7207161
	Val rho_sol : Real          = 1000.10152281425
	Val cp_sol : Real           = 4202.85969356982
	Val cond_sol : Real         = 0.7204897

	// density contants Gangi et al. (Kohlrausch)
	Val a_den : Real            = 999.840281
	Val b_den : Real            = 0.0673268
	Val c_den : Real            = -0.00894484
	Val d_den : Real            = 8.7846287e-5
	Val e_den : Real            = -6.6213979e-7

	// non-Newtonian parameters
	Val useNonNewtonian : Bool	= false
	Val n_index : Real			= 0.6 // 0.95
	
	// ML extension
	Var curSolveLevel : Int     = 0

	Var maxNumIt : Int          = 1000

	Var adaptFreq : Int         = 3
	Var adaptThres : Real       = 1e-3
	Var adaptFactor : Real      = 0.985
	Var adaptProlong : Real     = 2.5
	
	Var alwaysUseFMG : Bool		= false
}

/// specialized boundary handling functions

Function applyBC_t@all ( ) : Unit {
	loop over phi7@current only ghost [-1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * th - phi7[active]@current@[ 1,  0,  0]
	}
	loop over phi7@current only ghost [ 1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * tc - phi7[active]@current@[-1,  0,  0]
	}
	loop over phi7@current only ghost [ 0, -1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  1,  0]
	}
	loop over phi7@current only ghost [ 0,  1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0, -1,  0]
	}
	loop over phi7@current only ghost [ 0,  0, -1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0,  1]
	}
	loop over phi7@current only ghost [ 0,  0,  1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0, -1]
	}
}

Function applyBC_tApprox@all ( ) : Unit {
	loop over phi7Approx@current only ghost [-1,  0,  0] on boundary {
		phi7Approx[active]@current = 2.0 * th - phi7Approx[active]@current@[ 1,  0,  0]
	}
	loop over phi7Approx@current only ghost [ 1,  0,  0] on boundary {
		phi7Approx[active]@current = 2.0 * tc - phi7Approx[active]@current@[-1,  0,  0]
	}
	loop over phi7Approx@current only ghost [ 0, -1,  0] on boundary {
		phi7Approx[active]@current = phi7Approx[active]@current@[ 0,  1,  0]
	}
	loop over phi7Approx@current only ghost [ 0,  1,  0] on boundary {
		phi7Approx[active]@current = phi7Approx[active]@current@[ 0, -1,  0]
	}
	loop over phi7Approx@current only ghost [ 0,  0, -1] on boundary {
		phi7Approx[active]@current = phi7Approx[active]@current@[ 0,  0,  1]
	}
	loop over phi7Approx@current only ghost [ 0,  0,  1] on boundary {
		phi7Approx[active]@current = phi7Approx[active]@current@[ 0,  0, -1]
	}
}

Function applyBC_tZero@all ( ) : Unit {
	loop over phi7@current only ghost [-1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * 0 - phi7[active]@current@[ 1,  0,  0]
	}
	loop over phi7@current only ghost [ 1,  0,  0] on boundary {
		phi7[active]@current = 2.0 * 0 - phi7[active]@current@[-1,  0,  0]
	}
	loop over phi7@current only ghost [ 0, -1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  1,  0]
	}
	loop over phi7@current only ghost [ 0,  1,  0] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0, -1,  0]
	}
	loop over phi7@current only ghost [ 0,  0, -1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0,  1]
	}
	loop over phi7@current only ghost [ 0,  0,  1] on boundary {
		phi7[active]@current = phi7[active]@current@[ 0,  0, -1]
	}
}

/// main functions

Function Application ( ) : Unit {
	startTimer ( 'setup' )

	initGlobals ( )
	initDomain ( )
	initFieldsWithZero ( )

	initGeometry ( )
	InitFields@finest ( )

	stopTimer ( 'setup' )

	TimeLoop@finest ( )

	printAllTimers ( )
	destroyGlobals ( )
}

Function TimeLoop@finest ( ) : Unit {
	repeat until curTime > maxTime {
		startTimer ( 'timeStep' )

		if ( 0.0 == curTime ) {
			// initialize 'negative' timestep
			UpdateProperties@current ( )
		}

		AdvanceFields@current ( )

		if ( curTime >= nextPrintTime ) {
			nextPrintTime += printInterval

			Var index : Integer = curTime / printInterval

			Var filename_rho : String
			buildString ( filename_rho, "rho_", index, ".csv" )
			Var filename_u : String
			buildString ( filename_u, "u_", index, ".csv" )
			Var filename_v : String
			buildString ( filename_v, "v_", index, ".csv" )
			Var filename_w : String
			buildString ( filename_w, "w_", index, ".csv" )
			Var filename_temp : String
			buildString ( filename_temp, "temp_", index, ".csv" )

			printField ( filename_rho, rho[active]@current, 2**( levels@current ( ) - 1 ) == z )
			printField ( filename_u, u[active]@current, 2**( levels@current ( ) - 1 ) == z )
			printField ( filename_v, v[active]@current, 2**( levels@current ( ) - 1 ) == z )
			printField ( filename_w, w[active]@current, 2**( levels@current ( ) - 1 ) == z )
			printField ( filename_temp, phi7[active]@current, 2**( levels@current ( ) - 1 ) == z )
		}

		if ( 0.0 == curTime || alwaysUseFMG ) {
			relax_u@coarsest = 1.0
			relax_v@coarsest = 1.0
			relax_w@coarsest = 1.0
			relax_p@coarsest = 1.0
			relax_t@coarsest = 1.0
			LocalTimeStep@coarsest ( )
		} else {
			relax_u@finest = 1.0
			relax_v@finest = 1.0
			relax_w@finest = 1.0
			relax_p@finest = 1.0
			relax_t@finest = 1.0
			LocalTimeStep@finest ( )
		}
		
		curTime += dt

		stopTimer ( 'timeStep' )
	}
}

Function LocalTimeStep@all ( ) : Unit {

	Solve@current ( )

	if ( levels@finer ( ) <= levels@finest ( ) ) {
		// propagation
		PropagateSolution@finer ( )
		
		// solve on finer level
		LocalTimeStep@finer ( )
	}
}

Function PropagateSolution@(all, not (coarsest)) ( ) : Unit {
	loop over u@current{
		u@current = CorrectionFaceX@current * u@coarser
	}
	communicate u@current
	apply bc to u@current

	loop over v@current{
		v@current = CorrectionFaceY@current * v@coarser
	}
	communicate v@current
	apply bc to v@current

	loop over w@current{
		w@current = CorrectionFaceZ@current * w@coarser
	}
	communicate w@current
	apply bc to w@current
	
	loop over phi7@current{
		phi7@current = CorrectionCell@current * phi7@coarser
	}
	communicate phi7@current
	apply bc to phi7@current

	loop over p@current{
		p@current = CorrectionCell@current * p@coarser
	}
	communicate p@current
	apply bc to p@current
}

Function Cycle@((coarsest + 1) to finest) ( ) : Unit {
	NonLinearSmooth@current ( )
	
	Restriction@current ( )
	
	//NonLinearSmooth@coarser ( )
	Cycle@coarser ( )

	Correction@current ( )
	
	NonLinearSmooth@current ( )
}

Function Cycle@coarsest ( ) : Unit {
	NonLinearSmooth@current ( )
}

Function Solve@all ( ) : Unit {
	Var converged : Bool = false
	Var curIt : Int      = 0
	
	curSolveLevel        = levels@current ( )
	
	Var res_u : Real     = 0
	Var res_v : Real     = 0
	Var res_w : Real     = 0
	Var res_p : Real     = 0
	Var res_t : Real     = 0
	Var prevRes_u : Real = 0
	Var prevRes_v : Real = 0
	Var prevRes_w : Real = 0
	Var prevRes_p : Real = 0
	Var prevRes_t : Real = 0
	
	repeat until converged || curIt > maxNumIt {
		Cycle@current ( )

		// check convergence
		if ( curIt > 0 && 0 == curIt % adaptFreq ) {
			prevRes_u = res_u
			prevRes_v = res_v
			prevRes_w = res_w
			prevRes_p = res_p
			prevRes_t = res_t
		}
		
		CompileLSEsNoRelax@current ( )
		res_u = NormResidual_u@current ( )
		res_v = NormResidual_v@current ( )
		res_w = NormResidual_w@current ( )
		res_p = NormResidual_p@current ( )
		res_t = NormResidual_t@current ( )

		if ( curIt > adaptFreq && 0 == curIt % adaptFreq ) {
			if ( prevRes_u - res_u < adaptThres * res_u ) {
				relax_u@current *= adaptFactor
			}
			if ( prevRes_v - res_v < adaptThres * res_v ) {
				relax_v@current *= adaptFactor
			}
			if ( prevRes_w - res_w < adaptThres * res_w ) {
				relax_w@current *= adaptFactor
			}
			if ( prevRes_p - res_p < adaptThres * res_p ) {
				relax_p@current *= adaptFactor
			}
			if ( prevRes_t - res_t < adaptThres * res_t ) {
				relax_t@current *= adaptFactor
			}
		}
		
		if ( res_u < targetResPerComp && res_v < targetResPerComp && res_w < targetResPerComp && res_p < targetResPerComp && res_t < targetResPerComp ) {
			converged = true
		}

		if ( converged || 0 == curIt % 100 ) {
			print ( levels@current ( ), curTime, curIt , res_u, res_v, res_w, res_p, res_t)
		}

		curIt += 1
	}
	
	print ( "Relax for", levels@current ( ), relax_u@current, relax_v@current, relax_w@current, relax_p@current, relax_t@current )
	
	if ( levels@finer ( ) <= levels@finest ( ) ) {
		relax_u@finer = min ( 1.0, adaptProlong * relax_u@current )
		relax_v@finer = min ( 1.0, adaptProlong * relax_v@current )
		relax_w@finer = min ( 1.0, adaptProlong * relax_w@current )
		relax_p@finer = min ( 1.0, adaptProlong * relax_p@current )
		relax_t@finer = min ( 1.0, adaptProlong * relax_t@current )
	}
}

Function NonLinearSmooth@all ( ) : Unit {
	CompileLSEs@current ( )
	
	repeat 2 times {
		Smooth_uvwp@current ( )
	}
	repeat 5 times {
		Smooth_t@current ( )
	}
}

Function CompileLSEs@all ( ) : Unit {
	UpdateProperties@current ( )
	CompileStencil_u@current ( relax_u@current )
	CompileStencil_v@current ( relax_v@current )
	CompileStencil_w@current ( relax_w@current )
	CompileStencil_p@current ( relax_p@current )
	CompileStencil_t@current ( relax_t@current )
}

Function CompileLSEsNoRelax@all ( ) : Unit {
	UpdateProperties@current ( )
	CompileStencil_u@current ( 1.0 )
	CompileStencil_v@current ( 1.0 )
	CompileStencil_w@current ( 1.0 )
	CompileStencil_p@current ( 1.0 )
	CompileStencil_t@current ( 1.0 )
}

Function Smooth_uvwp@all ( ) : Unit {
	loop over p@current {
		solve locally {
			u@current@[0, 0, 0] => AuStencil@current@[0, 0, 0] * u@current@[0, 0, 0] == rhs_u@current@[0, 0, 0] + vf_cellWidth_y@current * vf_cellWidth_z@current * ( p@current@[-1, 0, 0] - p@current@[0, 0, 0] )
			u@current@[1, 0, 0] => AuStencil@current@[1, 0, 0] * u@current@[1, 0, 0] == rhs_u@current@[1, 0, 0] + vf_cellWidth_y@current * vf_cellWidth_z@current * ( p@current@[0, 0, 0] - p@current@[1, 0, 0] )
			
			v@current@[0, 0, 0] => AvStencil@current@[0, 0, 0] * v@current@[0, 0, 0] == rhs_v@current@[0, 0, 0] + vf_cellWidth_x@current * vf_cellWidth_z@current * ( p@current@[0, -1, 0] - p@current@[0, 0, 0] )
			v@current@[0, 1, 0] => AvStencil@current@[0, 1, 0] * v@current@[0, 1, 0] == rhs_v@current@[0, 1, 0] + vf_cellWidth_x@current * vf_cellWidth_z@current * ( p@current@[0, 0, 0] - p@current@[0, 1, 0] )
			
			w@current@[0, 0, 0] => AwStencil@current@[0, 0, 0] * w@current@[0, 0, 0] == rhs_w@current@[0, 0, 0] + vf_cellWidth_x@current * vf_cellWidth_y@current * ( p@current@[0, 0, -1] - p@current@[0, 0, 0] )
			w@current@[0, 0, 1] => AwStencil@current@[0, 0, 1] * w@current@[0, 0, 1] == rhs_w@current@[0, 0, 1] + vf_cellWidth_x@current * vf_cellWidth_y@current * ( p@current@[0, 0, 0] - p@current@[0, 0, 1] )
			
			p@current@[0, 0, 0] => (
					integrateOverEastFace ( u@current * rho@current )
					- integrateOverWestFace ( u@current * rho@current )
					+ integrateOverNorthFace ( v@current * rho@current )
					- integrateOverSouthFace ( v@current * rho@current )
					+ integrateOverTopFace ( w@current * rho@current )
					- integrateOverBottomFace ( w@current * rho@current )
				) == rhs_p@current
		}
	}
	communicate u@current
	apply bc to u@current
	communicate v@current
	apply bc to v@current
	communicate w@current
	apply bc to w@current
	communicate p@current
	apply bc to p@current
}



Function Restriction@((coarsest + 1) to finest) ( ) : Unit {
	// update residual values
	UpRes@current ( )

	// coarsen current guess
	CoarsenGuess@current ( )
	
	// re-compute the coarser systems
	SetupCoarseSystem@current ( )
	
	// f = r + A v
	SetupCoarseRHS@current ( )
}

Function UpRes@((coarsest + 1) to finest) ( ) : Unit {
	CompileLSEsNoRelax@current ( )
	
	loop over residual_u@current {
		residual_u@current = rhs_u@current + vf_cellWidth_y@current * vf_cellWidth_z@current * ( p@current@[-1, 0, 0] - p@current@[0, 0, 0] ) - AuStencil@current * u@current
	}
	communicate residual_u@current
	apply bc to residual_u@current

	loop over residual_v@current {
		residual_v@current = rhs_v@current + vf_cellWidth_x@current * vf_cellWidth_z@current * ( p@current@[0, -1, 0] - p@current@[0, 0, 0] ) - AvStencil@current * v@current
	}
	communicate residual_v@current
	apply bc to residual_v@current

	loop over residual_w@current {
		residual_w@current = rhs_w@current + vf_cellWidth_x@current * vf_cellWidth_y@current * ( p@current@[0, 0, -1] - p@current@[0, 0, 0] ) - AwStencil@current * w@current
	}
	communicate residual_w@current
	apply bc to residual_w@current

	loop over residual_p@current {
		residual_p@current = ( vf_cellWidth_y@current * vf_cellWidth_z@current * vf_cellWidth_x@current * ( rho[previous]@current - rho[active]@current ) / dt ) - (
				integrateOverEastFace ( u@current * rho@current )
				- integrateOverWestFace ( u@current * rho@current )
				+ integrateOverNorthFace ( v@current * rho@current )
				- integrateOverSouthFace ( v@current * rho@current )
				+ integrateOverTopFace ( w@current * rho@current )
				- integrateOverBottomFace ( w@current * rho@current )
			)
	}
	communicate residual_p@current
	apply bc to residual_p@current

	loop over residual_t@current {
		residual_t@current = rhs_t@current - AtStencil@current * phi7@current
	}
	communicate residual_t@current
	apply bc to residual_t@current
}

Function CoarsenGuess@((coarsest + 1) to finest) ( ) : Unit {
	loop over uApprox@coarser {
		uApprox@coarser = RestrictionFaceX@current * u@current
		u@coarser = uApprox@coarser
	}
	communicate uApprox@coarser
	apply bc to uApprox@coarser
	communicate u@coarser
	apply bc to u@coarser

	loop over vApprox@coarser {
		vApprox@coarser = RestrictionFaceY@current * v@current
		v@coarser = vApprox@coarser
	}
	communicate vApprox@coarser
	apply bc to vApprox@coarser
	communicate v@coarser
	apply bc to v@coarser

	loop over wApprox@coarser {
		wApprox@coarser = RestrictionFaceZ@current * w@current
		w@coarser = wApprox@coarser
	}
	communicate wApprox@coarser
	apply bc to wApprox@coarser
	communicate w@coarser
	apply bc to w@coarser

	loop over pApprox@coarser {
		pApprox@coarser = RestrictionCell@current * p@current
		p@coarser = pApprox@coarser
	}
	communicate pApprox@coarser
	apply bc to pApprox@coarser
	communicate p@coarser
	apply bc to p@coarser

	loop over phi7Approx@coarser {
		phi7Approx@coarser = RestrictionCell@current * phi7@current
		phi7@coarser = phi7Approx@coarser
	}
	communicate phi7Approx@coarser
	apply bc to phi7Approx@coarser
	communicate phi7@coarser
	apply bc to phi7@coarser
}

Function SetupCoarseSystem@((coarsest + 1) to finest) ( ) : Unit {
	if (0) {
		loop over rho@coarser {
			rho@coarser = RestrictionCell@current * rho@current
		}
		communicate rho@coarser
		apply bc to rho@coarser
		StencilRestriction_u@current ( )
		StencilRestriction_v@current ( )
		StencilRestriction_w@current ( )
		//StencilRestriction_p@current ( )
		StencilRestriction_t@current ( )
	} else {
		CompileLSEs@coarser ( )
	}
}

Function SetupCoarseRHS@((coarsest + 1) to finest) ( ) : Unit {
	loop over rhs_u@coarser {
		rhs_u@coarser = RestrictionFaceX@current * residual_u@current + AuStencil@coarser * uApprox@coarser - vf_cellWidth_y@coarser * vf_cellWidth_z@coarser * ( pApprox@coarser@[-1, 0, 0] - pApprox@coarser@[0, 0, 0] )
	}
	communicate rhs_u@coarser
	apply bc to rhs_u@coarser

	loop over rhs_v@coarser {
		rhs_v@coarser = RestrictionFaceY@current * residual_v@current + AvStencil@coarser * vApprox@coarser - vf_cellWidth_x@coarser * vf_cellWidth_z@coarser * ( pApprox@coarser@[0, -1, 0] - pApprox@coarser@[0, 0, 0] )
	}
	communicate rhs_v@coarser
	apply bc to rhs_v@coarser

	loop over rhs_w@coarser {
		rhs_w@coarser = RestrictionFaceZ@current * residual_w@current + AwStencil@coarser * wApprox@coarser - vf_cellWidth_x@coarser * vf_cellWidth_y@coarser * ( pApprox@coarser@[0, 0, -1] - pApprox@coarser@[0, 0, 0] )
	}
	communicate rhs_w@coarser
	apply bc to rhs_w@coarser

	loop over rhs_p@coarser {
		rhs_p@coarser = RestrictionCell@current * residual_p@current/* + ApStencil@coarser * pApprox@coarser*/ + (
				integrateOverEastFace ( uApprox@coarser * rho@coarser )
				- integrateOverWestFace ( uApprox@coarser * rho@coarser )
				+ integrateOverNorthFace ( vApprox@coarser * rho@coarser )
				- integrateOverSouthFace ( vApprox@coarser * rho@coarser )
				+ integrateOverTopFace ( wApprox@coarser * rho@coarser )
				- integrateOverBottomFace ( wApprox@coarser * rho@coarser )
			)
	}
	communicate rhs_p@coarser
	apply bc to rhs_p@coarser

	loop over rhs_t@coarser {
		rhs_t@coarser = RestrictionCell@current * residual_t@current + AtStencil@coarser * phi7Approx@coarser
	}
	communicate rhs_t@coarser
	apply bc to rhs_t@coarser
}

Function Correction@((coarsest + 1) to finest) ( ) : Unit {
	// correction
	CalcCoarseError@current ( )
	
	// actual prolongation and correction
	DoCorrection@current ( )
}

Function CalcCoarseError@((coarsest + 1) to finest) ( ) : Unit {
	// e = u - v
	loop over u@coarser {
		u@coarser -= uApprox@coarser
	}
	communicate u@coarser
	apply bc to u@coarser
	
	loop over v@coarser {
		v@coarser -= vApprox@coarser
	}
	communicate v@coarser
	apply bc to v@coarser

	loop over w@coarser {
		w@coarser -= wApprox@coarser
	}
	communicate w@coarser
	apply bc to w@coarser

	loop over p@coarser {
		p@coarser -= pApprox@coarser
	}
	communicate p@coarser
	apply bc to p@coarser

	loop over phi7@coarser {
		phi7@coarser -= phi7Approx@coarser
	}
	communicate phi7@coarser
	//apply bc to phi7@coarser
	applyBC_tZero@coarser ( )
}

Function DoCorrection@((coarsest + 1) to finest) ( ) : Unit {
	loop over u@current {
		u@current += CorrectionFaceX@current * u@coarser
	}
	communicate u@current
	apply bc to u@current

	loop over v@current {
		v@current += CorrectionFaceY@current * v@coarser
	}
	communicate v@current
	apply bc to v@current

	loop over w@current {
		w@current += CorrectionFaceZ@current * w@coarser
	}
	communicate w@current
	apply bc to w@current

	loop over p@current {
		p@current += CorrectionCell@current * p@coarser
	}
	communicate p@current
	apply bc to p@current

	loop over phi7@current {
		phi7@current += CorrectionCell@current * phi7@coarser
	}
	communicate phi7@current
	apply bc to phi7@current
}












/// init functions

Function InitFields@all ( ) : Unit {
	// fields that are not initialized with 0

	loop over rho@current {
		rho[active]@current = rhocon
		rho[previous]@current = rhocon
	}

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate rho[previous]@current
	apply bc to rho[previous]@current

	loop over vis@current {
		vis@current = visl
	}

	communicate vis@current
	apply bc to vis@current

	loop over phi7@current {
		phi7[active]@current = th
		phi7[previous]@current = th
	}

	communicate phi7[active]@current
	apply bc to phi7[active]@current

	communicate phi7[previous]@current
	apply bc to phi7[previous]@current
	
	if ( levels@coarser ( ) >= levels@coarsest ( ) ) {
		InitFields@coarser ( )
	}
}

/// utility functions

Function AdvanceFields@finest ( ) : Unit {
	loop over phi7@current starting [-1, -1, -1] ending [-1, -1, -1] {
		phi7[next]@current = phi7[active]@current
	}
	advance phi7@current

	loop over u@current starting [-1, -1, -1] ending [-1, -1, -1] {
		u[next]@current = u[active]@current
	}
	advance u@current

	loop over v@current starting [-1, -1, -1] ending [-1, -1, -1] {
		v[next]@current = v[active]@current
	}
	advance v@current

	loop over w@current starting [-1, -1, -1] ending [-1, -1, -1] {
		w[next]@current = w[active]@current
	}
	advance w@current

	loop over rho@current starting [-1, -1, -1] ending [-1, -1, -1] {
		rho[next]@current = rho[active]@current
	}
	advance rho@current

	if ( levels@coarser ( ) >= levels@coarsest ( ) ) {
		AdvanceFields@coarser ( )
	}
}

Function AdvanceFields@(coarsest to (finest - 1)) ( ) : Unit {
	loop over u@current {
		u@current = RestrictionFaceX@finer * u@finer
	}
	communicate u@current
	apply bc to u@current

	loop over u@current starting [-1, -1, -1] ending [-1, -1, -1] {
		u[next]@current = u[active]@current
	}
	advance u@current


	loop over v@current {
		v@current = RestrictionFaceY@finer * v@finer
	}
	communicate v@current
	apply bc to v@current

	loop over v@current starting [-1, -1, -1] ending [-1, -1, -1] {
		v[next]@current = v[active]@current
	}
	advance v@current


	loop over w@current {
		w@current = RestrictionFaceZ@finer * w@finer
	}
	communicate w@current
	apply bc to w@current

	loop over w@current starting [-1, -1, -1] ending [-1, -1, -1] {
		w[next]@current = w[active]@current
	}
	advance w@current


	loop over rho@current {
		rho@current = RestrictionCell@finer * rho@finer
	}
	communicate rho@current
	apply bc to rho@current

	loop over rho@current starting [-1, -1, -1] ending [-1, -1, -1] {
		rho[next]@current = rho[active]@current
	}
	advance rho@current


	loop over phi7@current {
		phi7@current = RestrictionCell@finer * phi7@finer
	}
	communicate phi7@current
	apply bc to phi7@current

	loop over phi7@current starting [-1, -1, -1] ending [-1, -1, -1] {
		phi7[next]@current = phi7[active]@current
	}
	advance phi7@current

	if ( levels@coarser ( ) >= levels@coarsest ( ) ) {
		AdvanceFields@coarser ( )
	}
}

Function calc_diflow ( flow : Real, diff : Real ) : Real {
	Var tmp : Real = ( diff - 0.1 * fabs ( flow ) ) / diff
	return max ( 0.0, diff * ( tmp ** 5 ) )
}

/// general functions

Function UpdateProperties@all ( ) : Unit {
	if ( useNonNewtonian ) {
		UpdatePropertiesNN@current ( )
	} else {
		UpdatePropertiesN@current ( )
	}
}

Function UpdatePropertiesN@all ( ) : Unit {
	// previously props and Gamsor_flu and Gamsor_phi

	loop over vis@current {
		// Gangi et al. (Kohlrausch) Density
		rho[active]@current = ( a_den + b_den * ( phi7[active]@current - t_ph )
			+ c_den * ( phi7[active]@current - t_ph )**2
			+ d_den * ( phi7[active]@current - t_ph )**3
			+ e_den * ( phi7[active]@current - t_ph )**4 )

		// Zografos et al. Specific heat, thermal conductivity and viscosity
		Val cp : Real = ( -3755.9 + 67.953 * phi7[active]@current
			- 0.19149 * phi7[active]@current**2
			+ 1.7850e-4 * phi7[active]@current**3 )
		Val cond : Real = ( -0.63262 + 7.1959e-3 * phi7[active]@current
			- 1.144e-5 * phi7[active]@current**2
			+ 4.2365e-9 * phi7[active]@current**3 )
		vis@current = 3.8208e-2 / ( phi7[active]@current - 252.33 )

		gamma@current = cond / cp
	}

	communicate vis@current
	apply bc to vis@current

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate gamma@current
	apply bc to gamma@current
}

Function UpdatePropertiesNN@all ( ) : Unit {
	// previously props and non_new and Gamsor_flu and Gamsor_phi

	loop over miu@current {
		// Gangi et al. (Kohlrausch) Density
		rho[active]@current = ( a_den + b_den * ( phi7[active]@current - t_ph )
			+ c_den * ( phi7[active]@current - t_ph )**2
			+ d_den * ( phi7[active]@current - t_ph )**3
			+ e_den * ( phi7[active]@current - t_ph )**4 )

		// Zografos et al. Specific heat, thermal conductivity and viscosity
		Val cp : Real = ( -3755.9 + 67.953 * phi7[active]@current
			- 0.19149 * phi7[active]@current**2
			+ 1.7850e-4 * phi7[active]@current**3 )
		Val cond : Real = ( -0.63262 + 7.1959e-3 * phi7[active]@current
			- 1.144e-5 * phi7[active]@current**2
			+ 4.2365e-9 * phi7[active]@current**3 )
		miu@current = 3.8208e-2 / ( phi7[active]@current - 252.33 )

		gamma@current = cond / cp
	}

	communicate miu@current
	apply bc to miu@current

	communicate rho[active]@current
	apply bc to rho[active]@current

	communicate gamma@current
	apply bc to gamma@current

	loop over vis@current {
		// TODO: add evalAtCellCenter, evalAtXFaceCenter, evalAtXYCorner, etc
		// du/dx and dv/dx and dw/dx
		Val dudx : Real = ( evalAtEastFace ( u[active]@current ) - evalAtWestFace ( u[active]@current ) ) / vf_cellWidth_x@current

		Val dvdx : Real = 0.5 * ( evalAtEastFace ( v[active]@current ) - evalAtWestFace ( v[active]@current )
			+ evalAtEastFace ( v[active]@current@[ 0,  1,  0] ) - evalAtWestFace ( v[active]@current@[ 0,  1,  0] ) ) / vf_cellWidth_x@current

		Val dwdx : Real = 0.5 * ( evalAtEastFace ( w[active]@current ) - evalAtWestFace ( w[active]@current )
			+ evalAtEastFace ( w[active]@current@[ 0,  0,  1] ) - evalAtWestFace ( w[active]@current@[ 0,  0,  1] ) ) / vf_cellWidth_x@current

		// du/dy and dv/dy and dw/dy
		Val dudy : Real = 0.5 * ( evalAtNorthFace ( u[active]@current ) - evalAtSouthFace ( u[active]@current )
			+ evalAtNorthFace ( u[active]@current@[ 1,  0,  0] ) - evalAtSouthFace ( u[active]@current@[ 1,  0,  0] ) ) / vf_cellWidth_y@current

		Val dvdy : Real = ( evalAtNorthFace ( v[active]@current ) - evalAtSouthFace ( v[active]@current ) ) / vf_cellWidth_y@current

		Val dwdy : Real = 0.5 * ( evalAtNorthFace ( w[active]@current ) - evalAtSouthFace ( w[active]@current )
			+ evalAtNorthFace ( w[active]@current@[ 0,  0,  1] ) - evalAtSouthFace ( w[active]@current@[ 0,  0,  1] ) ) / vf_cellWidth_y@current

		// du/dz and dv/dz and dw/dz
		Val dudz : Real = 0.5 * ( evalAtTopFace ( u[active]@current ) - evalAtBottomFace ( u[active]@current )
			+ evalAtTopFace ( u[active]@current@[ 1,  0,  0] ) - evalAtBottomFace ( u[active]@current@[ 1,  0,  0] ) ) / vf_cellWidth_z@current

		Val dvdz : Real = 0.5 * ( evalAtTopFace ( v[active]@current ) - evalAtBottomFace ( v[active]@current )
			+ evalAtTopFace ( v[active]@current@[ 0,  1,  0] ) - evalAtBottomFace ( v[active]@current@[ 0,  1,  0] ) ) / vf_cellWidth_z@current

		Val dwdz : Real = ( evalAtTopFace ( w[active]@current ) - evalAtBottomFace ( w[active]@current ) ) / vf_cellWidth_z@current

		// compile values
		Val gamap : Real = 2.0 * ( dvdy**2 + dudx**2 + dwdz**2 ) + ( dvdx + dudy )**2 + ( dwdx + dudz )**2 + ( dvdz + dwdy )**2
		Var gama : Real = sqrt ( gamap )

		// j.non.newt.fluid mech. 15(1984)75-83
		//gama = max ( gama, 0.01 )
		//vis@current = rel + ( 1.0 - rel ) / ( 1.0 + sqrt ( lambda * gama ) )

		// Int. J. Heat & Mass Transfer 34(1991) 1083-1096 CMC/Power law
		gama = max ( gama, 0.01 )
		vis@current = miu@current * gama**( n_index - 1.0 )
	}

	communicate vis@current
	apply bc to vis@current
}

/// stencil compilation functions

Function CompileStencil_u@all ( relax : Real ) : Unit {
	loop over AuStencil@current {
		Val flow_e@current : Real = integrateOverXStaggeredEastFace ( u[active]@current * rho[active]@current )
		Val flow_w@current : Real = integrateOverXStaggeredWestFace ( u[active]@current * rho[active]@current )

		Val flow_n@current : Real = integrateOverXStaggeredNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s@current : Real = integrateOverXStaggeredSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t@current : Real = integrateOverXStaggeredTopFace ( w[active]@current * rho[active]@current )
		Val flow_b@current : Real = integrateOverXStaggeredBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverXStaggeredEastFace ( vis@current ) / vf_cellWidth_x@current
		Val diff_w : Real = integrateOverXStaggeredWestFace ( vis@current ) / vf_cellWidth_x@current@[-1,  0,  0]

		Val diff_n : Real = integrateOverXStaggeredNorthFace ( evalAtXStaggeredNorthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[ 0,  1,  0]
		Val diff_s : Real = integrateOverXStaggeredSouthFace ( evalAtXStaggeredSouthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current

		Val diff_t : Real = integrateOverXStaggeredTopFace ( evalAtXStaggeredTopFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[ 0,  0,  1]
		Val diff_b : Real = integrateOverXStaggeredBottomFace ( evalAtXStaggeredBottomFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current

		AuStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e@current, diff_e ) + max ( 0.0, -1.0 * flow_e@current ) )
		AuStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w@current, diff_w ) + max ( 0.0,        flow_w@current ) )

		AuStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n@current, diff_n ) + max ( 0.0, -1.0 * flow_n@current ) )
		AuStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s@current, diff_s ) + max ( 0.0,        flow_s@current ) )

		AuStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t@current, diff_t ) + max ( 0.0, -1.0 * flow_t@current ) )
		AuStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b@current, diff_b ) + max ( 0.0,        flow_b@current ) )

		Var smasa : Real = (
			( flow_e@current - flow_w@current + flow_n@current - flow_s@current + flow_t@current - flow_b@current ) / vf_xStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AuStencil@current:[ 0,  0,  0] = smasa
		AuStencil@current:[ 0,  0,  0] += evalAtWestFace ( rho[active]@current ) / dt
		AuStencil@current:[ 0,  0,  0] = ( AuStencil@current:[ 0,  0,  0] * vf_xStagCellVolume@current
			- AuStencil@current:[ 1,  0,  0] - AuStencil@current:[-1,  0,  0]
			- AuStencil@current:[ 0,  1,  0] - AuStencil@current:[ 0, -1,  0]
			- AuStencil@current:[ 0,  0,  1] - AuStencil@current:[ 0,  0, -1] )

		if ( curSolveLevel == levels@current ( ) ) {
			rhs_u@current = ( u[active]@current * smasa + u[previous]@current * evalAtWestFace ( rho[previous]@current ) / dt )
			rhs_u@current = rhs_u@current * vf_xStagCellVolume@current
		} else if ( levels@finer ( ) <= levels@finest ( ) ) {
			rhs_u@current = RestrictionFaceX@finer * residual_u@finer + AuStencil@current * uApprox@current - vf_cellWidth_y@current * vf_cellWidth_z@current * ( pApprox@current@[-1, 0, 0] - pApprox@current@[0, 0, 0] )
		}

		if (1) {
			rhs_u@current -= ( 1.0 - 1.0 / relax ) * AuStencil@current:[ 0,  0,  0] * u[active]@current
			AuStencil@current:[ 0,  0,  0] /= relax
		}
	}

	communicate AuStencil@current
	apply bc to AuStencil@current

	communicate rhs_u@current
	apply bc to rhs_u@current	
}

Function CompileStencil_v@all ( relax : Real ) : Unit {
	loop over AvStencil@current {
		Val flow_e@current : Real = integrateOverYStaggeredEastFace ( u[active]@current * rho[active]@current )
		Val flow_w@current : Real = integrateOverYStaggeredWestFace ( u[active]@current * rho[active]@current )

		Val flow_n@current : Real = integrateOverYStaggeredNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s@current : Real = integrateOverYStaggeredSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t@current : Real = integrateOverYStaggeredTopFace ( w[active]@current * rho[active]@current )
		Val flow_b@current : Real = integrateOverYStaggeredBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverYStaggeredEastFace ( evalAtYStaggeredEastFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[ 1,  0,  0]
		Val diff_w : Real = integrateOverYStaggeredWestFace ( evalAtYStaggeredWestFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current

		Val diff_n : Real = integrateOverYStaggeredNorthFace ( vis@current ) / vf_cellWidth_y@current
		Val diff_s : Real = integrateOverYStaggeredSouthFace ( vis@current ) / vf_cellWidth_y@current@[ 0, -1,  0]

		Val diff_t : Real = integrateOverYStaggeredTopFace ( evalAtYStaggeredTopFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[ 0,  0,  1]
		Val diff_b : Real = integrateOverYStaggeredBottomFace ( evalAtYStaggeredBottomFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current

		AvStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e@current, diff_e ) + max ( 0.0, -1.0 * flow_e@current ) )
		AvStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w@current, diff_w ) + max ( 0.0,        flow_w@current ) )

		AvStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n@current, diff_n ) + max ( 0.0, -1.0 * flow_n@current ) )
		AvStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s@current, diff_s ) + max ( 0.0,        flow_s@current ) )

		AvStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t@current, diff_t ) + max ( 0.0, -1.0 * flow_t@current ) )
		AvStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b@current, diff_b ) + max ( 0.0,        flow_b@current ) )

		Var smasa : Real = (
			( flow_e@current - flow_w@current + flow_n@current - flow_s@current + flow_t@current - flow_b@current ) / vf_yStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AvStencil@current:[ 0,  0,  0] = smasa
		AvStencil@current:[ 0,  0,  0] += evalAtSouthFace ( rho[active]@current ) / dt
		AvStencil@current:[ 0,  0,  0] = ( AvStencil@current:[ 0,  0,  0] * vf_yStagCellVolume@current
			- AvStencil@current:[ 1,  0,  0] - AvStencil@current:[-1,  0,  0]
			- AvStencil@current:[ 0,  1,  0] - AvStencil@current:[ 0, -1,  0]
			- AvStencil@current:[ 0,  0,  1] - AvStencil@current:[ 0,  0, -1] )

		if ( curSolveLevel == levels@current ( ) ) {
			rhs_v@current = -9.81 * ( rho[active]@current - rhoref ) // incorporate gravity
			rhs_v@current += v[active]@current * smasa + v[previous]@current * evalAtSouthFace ( rho[previous]@current ) / dt
			rhs_v@current = rhs_v@current * vf_yStagCellVolume@current
		} else if ( levels@finer ( ) <= levels@finest ( ) ) {
			rhs_v@current = RestrictionFaceY@finer * residual_v@finer + AvStencil@current * vApprox@current - vf_cellWidth_x@current * vf_cellWidth_z@current * ( pApprox@current@[0, -1, 0] - pApprox@current@[0, 0, 0] )
		}

		if (1) {
			rhs_v@current -= ( 1.0 - 1.0 / relax ) * AvStencil@current:[ 0,  0,  0] * v[active]@current
			AvStencil@current:[ 0,  0,  0] /= relax
		}
	}

	communicate AvStencil@current
	apply bc to AvStencil@current

	communicate rhs_v@current
	apply bc to rhs_v@current	
}

Function CompileStencil_w@all ( relax : Real ) : Unit {
	loop over AwStencil@current {
		Val flow_e@current : Real = integrateOverZStaggeredEastFace ( u[active]@current * rho[active]@current )
		Val flow_w@current : Real = integrateOverZStaggeredWestFace ( u[active]@current * rho[active]@current )

		Val flow_n@current : Real = integrateOverZStaggeredNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s@current : Real = integrateOverZStaggeredSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t@current : Real = integrateOverZStaggeredTopFace ( w[active]@current * rho[active]@current )
		Val flow_b@current : Real = integrateOverZStaggeredBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverZStaggeredEastFace ( evalAtZStaggeredEastFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[ 1,  0,  0]
		Val diff_w : Real = integrateOverZStaggeredWestFace ( evalAtZStaggeredWestFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current

		Val diff_n : Real = integrateOverZStaggeredNorthFace ( evalAtZStaggeredNorthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[ 0,  1,  0]
		Val diff_s : Real = integrateOverZStaggeredSouthFace ( evalAtZStaggeredSouthFace ( vis@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current

		Val diff_t : Real = integrateOverZStaggeredTopFace ( vis@current ) / vf_cellWidth_z@current
		Val diff_b : Real = integrateOverZStaggeredBottomFace ( vis@current ) / vf_cellWidth_z@current@[ 0,  0, -1]

		AwStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e@current, diff_e ) + max ( 0.0, -1.0 * flow_e@current ) )
		AwStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w@current, diff_w ) + max ( 0.0,        flow_w@current ) )

		AwStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n@current, diff_n ) + max ( 0.0, -1.0 * flow_n@current ) )
		AwStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s@current, diff_s ) + max ( 0.0,        flow_s@current ) )

		AwStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t@current, diff_t ) + max ( 0.0, -1.0 * flow_t@current ) )
		AwStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b@current, diff_b ) + max ( 0.0,        flow_b@current ) )

		Var smasa : Real = (
			( flow_e@current - flow_w@current + flow_n@current - flow_s@current + flow_t@current - flow_b@current ) / vf_zStagCellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		AwStencil@current:[ 0,  0,  0] = smasa
		AwStencil@current:[ 0,  0,  0] += evalAtBottomFace ( rho[active]@current ) / dt
		AwStencil@current:[ 0,  0,  0] = ( AwStencil@current:[ 0,  0,  0] * vf_zStagCellVolume@current
			- AwStencil@current:[ 1,  0,  0] - AwStencil@current:[-1,  0,  0]
			- AwStencil@current:[ 0,  1,  0] - AwStencil@current:[ 0, -1,  0]
			- AwStencil@current:[ 0,  0,  1] - AwStencil@current:[ 0,  0, -1] )

		if ( curSolveLevel == levels@current ( ) ) {
			rhs_w@current = w[active]@current * smasa + w[previous]@current * evalAtBottomFace ( rho[previous]@current ) / dt
			rhs_w@current = rhs_w@current * vf_zStagCellVolume@current
		} else if ( levels@finer ( ) <= levels@finest ( ) ) {
			rhs_w@current = RestrictionFaceZ@finer * residual_w@finer + AwStencil@current * wApprox@current - vf_cellWidth_x@current * vf_cellWidth_y@current * ( pApprox@current@[0, 0, -1] - pApprox@current@[0, 0, 0] )
		}

		if (1) {
			rhs_w@current -= ( 1.0 - 1.0 / relax ) * AwStencil@current:[ 0,  0,  0] * w[active]@current
			AwStencil@current:[ 0,  0,  0] /= relax
		}
	}

	communicate AwStencil@current
	apply bc to AwStencil@current

	communicate rhs_w@current
	apply bc to rhs_w@current	
}

Function CompileStencil_p@all ( relax : Real ) : Unit {
	if ( curSolveLevel == levels@current ( ) ) {
		loop over rhs_p@current {
			rhs_p@current = vf_cellVolume@current * ( rho[previous]@current - rho[active]@current ) / dt
		}
	} else if ( levels@finer ( ) <= levels@finest ( ) ) {
		loop over rhs_p@current {
			rhs_p@current = RestrictionCell@finer * residual_p@finer/* + ApStencil@current * pApprox@current*/ + (
					integrateOverEastFace ( uApprox@current * rho@current )
					- integrateOverWestFace ( uApprox@current * rho@current )
					+ integrateOverNorthFace ( vApprox@current * rho@current )
					- integrateOverSouthFace ( vApprox@current * rho@current )
					+ integrateOverTopFace ( wApprox@current * rho@current )
					- integrateOverBottomFace ( wApprox@current * rho@current )
				)
		}
	}

	communicate rhs_p@current
	apply bc to rhs_p@current	
}

Function CompileStencil_t@all ( relax : Real ) : Unit {
	loop over AtStencil@current {
		Val flow_e@current : Real = integrateOverEastFace ( u[active]@current * rho[active]@current )
		Val flow_w@current : Real = integrateOverWestFace ( u[active]@current * rho[active]@current )

		Val flow_n@current : Real = integrateOverNorthFace ( v[active]@current * rho[active]@current )
		Val flow_s@current : Real = integrateOverSouthFace ( v[active]@current * rho[active]@current )

		Val flow_t@current : Real = integrateOverTopFace ( w[active]@current * rho[active]@current )
		Val flow_b@current : Real = integrateOverBottomFace ( w[active]@current * rho[active]@current )

		Val diff_e : Real = integrateOverEastFace ( evalAtEastFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current@[ 1,  0,  0]
		Val diff_w : Real = integrateOverWestFace ( evalAtWestFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_x@current

		Val diff_n : Real = integrateOverNorthFace ( evalAtNorthFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current@[ 0,  1,  0]
		Val diff_s : Real = integrateOverSouthFace ( evalAtSouthFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_y@current

		Val diff_t : Real = integrateOverTopFace ( evalAtTopFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current@[ 0,  0,  1]
		Val diff_b : Real = integrateOverBottomFace ( evalAtBottomFace ( gamma@current, "harmonicMean" ) ) / vf_stagCVWidth_z@current

		AtStencil@current:[ 1,  0,  0] = -1.0 * ( calc_diflow ( flow_e@current, diff_e ) + max ( 0.0, -1.0 * flow_e@current ) )
		AtStencil@current:[-1,  0,  0] = -1.0 * ( calc_diflow ( flow_w@current, diff_w ) + max ( 0.0,        flow_w@current ) )

		AtStencil@current:[ 0,  1,  0] = -1.0 * ( calc_diflow ( flow_n@current, diff_n ) + max ( 0.0, -1.0 * flow_n@current ) )
		AtStencil@current:[ 0, -1,  0] = -1.0 * ( calc_diflow ( flow_s@current, diff_s ) + max ( 0.0,        flow_s@current ) )

		AtStencil@current:[ 0,  0,  1] = -1.0 * ( calc_diflow ( flow_t@current, diff_t ) + max ( 0.0, -1.0 * flow_t@current ) )
		AtStencil@current:[ 0,  0, -1] = -1.0 * ( calc_diflow ( flow_b@current, diff_b ) + max ( 0.0,        flow_b@current ) )

		Var smasa : Real = (
			( flow_e@current - flow_w@current + flow_n@current - flow_s@current + flow_t@current - flow_b@current ) / vf_cellVolume@current
			+ ( rho[active]@current - rho[previous]@current ) / dt )
		smasa = max ( 0.0, smasa )

		// TODO: check AtStencil@current:[ 0,  0,  0] = smasa + phi7@current * rho[active]@current / dt
		AtStencil@current:[ 0,  0,  0] = smasa + rho[active]@current / dt
		AtStencil@current:[ 0,  0,  0] = ( AtStencil@current:[ 0,  0,  0] * vf_cellVolume@current
			- AtStencil@current:[ 1,  0,  0] - AtStencil@current:[-1,  0,  0]
			- AtStencil@current:[ 0,  1,  0] - AtStencil@current:[ 0, -1,  0]
			- AtStencil@current:[ 0,  0,  1] - AtStencil@current:[ 0,  0, -1] )

		if ( curSolveLevel == levels@current ( ) ) {
			rhs_t@current = smasa * phi7[active]@current + ( rho[active]@current / dt ) * phi7[previous]@current
			rhs_t@current *= vf_cellVolume@current
		} else if ( levels@finer ( ) <= levels@finest ( ) ) {
			rhs_t@current = RestrictionCell@finer * residual_t@finer + AtStencil@current * phi7Approx@current
		}

		if (1) {
			rhs_t@current -= ( 1.0 - 1.0 / relax ) * AtStencil@current:[ 0,  0,  0] * phi7[active]@current
			AtStencil@current:[ 0,  0,  0] /= relax
		}
	}

	communicate AtStencil@current
	apply bc to AtStencil@current

	communicate rhs_t@current
	apply bc to rhs_t@current	
}



Function NormResidual_u@all ( ) : Real {
	Var totalRes : Real = 0
	loop over u@current with reduction( + : totalRes ) {
		Var curRes : Real = rhs_u@current + vf_cellWidth_y@current * vf_cellWidth_z@current * ( p@current@[-1, 0, 0] - p@current@[0, 0, 0] ) - AuStencil@current * u@current
		totalRes += curRes ** 2
	}
	return sqrt ( totalRes )
}

Function NormResidual_v@all ( ) : Real {
	Var totalRes : Real = 0
	loop over u@current with reduction( + : totalRes ) {
		Var curRes : Real = rhs_v@current + vf_cellWidth_x@current * vf_cellWidth_z@current * ( p@current@[0, -1, 0] - p@current@[0, 0, 0] ) - AvStencil@current * v@current
		totalRes += curRes ** 2
	}
	return sqrt ( totalRes )
}

Function NormResidual_w@all ( ) : Real {
	Var totalRes : Real = 0
	loop over u@current with reduction( + : totalRes ) {
		Var curRes : Real = rhs_w@current + vf_cellWidth_x@current * vf_cellWidth_y@current * ( p@current@[0, 0, -1] - p@current@[0, 0, 0] ) - AwStencil@current * w@current
		totalRes += curRes ** 2
	}
	return sqrt ( totalRes )
}

Function NormResidual_p@all ( ) : Real {
	Var totalRes : Real = 0
	loop over u@current with reduction( + : totalRes ) {
		Var curRes : Real = rhs_p@current - (
				integrateOverEastFace ( u@current * rho@current )
				- integrateOverWestFace ( u@current * rho@current )
				+ integrateOverNorthFace ( v@current * rho@current )
				- integrateOverSouthFace ( v@current * rho@current )
				+ integrateOverTopFace ( w@current * rho@current )
				- integrateOverBottomFace ( w@current * rho@current )
			)
		totalRes += curRes ** 2
	}
	return sqrt ( totalRes )
}


/// templates for (multigrid) solver components

FunctionTemplate NormResidualComponent < solution, stencil, rhs > ( ) : Real {
	Var totalRes : Real = 0
	loop over solution with reduction( + : totalRes ) {
		Var curRes : Real = rhs - stencil * solution
		totalRes += curRes ** 2
	}
	return sqrt ( totalRes )
}

FunctionTemplate SmoothComponent < solution, stencil, rhs, omega, requiresBcUpdate > ( ) : Unit {
	loop over solution where 0 == ((x + y + z) % 2) {
		solution += ( ( 1.0 / diag ( stencil ) ) * omega ) * ( rhs - stencil * solution )
	}
	communicate solution

	loop over solution where 1 == ((x + y + z) % 2) {
		solution += ( ( 1.0 / diag ( stencil ) ) * omega ) * ( rhs - stencil * solution )
	}
	communicate solution

	if ( requiresBcUpdate ) {
		apply bc to solution
	}
}

FunctionTemplate StencilRestrictionComponent < self, source, dest, restrictionStencil > ( ) : Unit {
	loop over dest {
		dest:[ 0,  0,  0] = restrictionStencil * source:[ 0,  0,  0]
		dest:[-1,  0,  0] = restrictionStencil * source:[-1,  0,  0]
		dest:[ 1,  0,  0] = restrictionStencil * source:[ 1,  0,  0]
		dest:[ 0, -1,  0] = restrictionStencil * source:[ 0, -1,  0]
		dest:[ 0,  1,  0] = restrictionStencil * source:[ 0,  1,  0]
		dest:[ 0,  0, -1] = restrictionStencil * source:[ 0,  0, -1]
		dest:[ 0,  0,  1] = restrictionStencil * source:[ 0,  0,  1]
	}

	communicate dest
	apply bc to dest

	//if ( levels@current ( ) - 1 > levels@coarsest ( ) ) {
	//	self@coarser ( )
	//}
}

// instantiations

Instantiate NormResidualComponent < phi7[active]@current, AtStencil@current, rhs_t@current > as NormResidual_t@all
Instantiate SmoothComponent < phi7[active]@current, AtStencil@current, rhs_t@current, 1.0, true > as Smooth_t@all



Instantiate StencilRestrictionComponent < StencilRestriction_u, AuStencil@current, AuStencil@coarser, RestrictionFaceX@current > as StencilRestriction_u@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_v, AvStencil@current, AvStencil@coarser, RestrictionFaceY@current > as StencilRestriction_v@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_w, AwStencil@current, AwStencil@coarser, RestrictionFaceZ@current > as StencilRestriction_w@( ( coarsest + 1 ) to finest )
//Instantiate StencilRestrictionComponent < StencilRestriction_pc, ApcStencil@current, ApcStencil@coarser, RestrictionCell@current > as StencilRestriction_pc@( ( coarsest + 1 ) to finest )
Instantiate StencilRestrictionComponent < StencilRestriction_t, AtStencil@current, AtStencil@coarser, RestrictionCell@current > as StencilRestriction_t@( ( coarsest + 1 ) to finest )
